<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>模糊测试 | BLOG</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="JUHUA"><link rel=canonical href=https://juhuax.github.io/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><link rel=icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://juhuax.github.io/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="模糊测试"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://juhuax.github.io/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="模糊测试"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juhuax.github.io/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://juhuax.github.io/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juhuax.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://juhuax.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juhuax.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juhuax.github.io/about/ title=about><span>about</span></a></li><li><a href=https://juhuax.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://juhuax.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juhuax.github.io/categories/>Categories</a></div><h1>模糊测试
<a href=/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection</h2></header><div class=entry-content><p>中文译名：使用上下文敏感软件故障注入模糊化错误处理代码
作者：蒋mingzhu 单位：清华大学 国家： #中国 年份： #2020年 来源： #USENIX会议 关键字： #fuzzing #故障注入 代码地址： 笔记建立时间： 2023-06-29 10:36 #TODO 这篇文章的作者和 [[Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection]] 一样，是进一步的后续工作。
Abstract FIFUZZ的核心是上下文敏感的软件故障注入 (SFI)方法，该方法可以有效覆盖不同调用上下文中的错误处理代码，从而发现隐藏在复杂上下文中的错误处理代码中的深层错误。 Background 现有的基于sfi的方法存在一个关键的限制: 据我们所知，它们只执行上下文（执行路径）不敏感的故障注入，这通常会阻止测试的深入。可能某些错误会在特定的调用上下文中才会被触发。 举例 函数P存在double free漏洞，但是如果是上下文不敏感的故障注入，在函数P的错误处理代码（if）中注入故障，每次执行到函数A程序就会触发故障而不会到达函数B，也就不会触发double free错误，如果进行上下文敏感的故障注入，只有在函数B调用函数P的时候引入故障，那么就可以触发double free错误。
方法 Error Sequence Model 在 [[Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection]] 的error site序列（$ErrSeq = [ErrPt1, ErrPt2, …, ErrPtx], ErrPti = {0, 1}$）的基础上，作者增加了执行错误站点时的运行的调用堆栈作为上下文 $ErrPt =&lt; ErrLoc,CallCtx >$ $CallCtx$ 就是上下文 $CallCtx = [CallIn f o1,CallIn f o2, …,CallIn f ox]$ $CallIn f o =&lt; CallLoc, FuncLoc >$ callloc应该是该函数的位置，funcloc是该函数调用的函数的位置（应该是这样吧） 作者存储相关信息的结构就是Errpt的hash作为键，0/1作为值 作者指出，因为要考虑上下文，所以故障注入不能再静态的注入，而是要动态的进行注入。比如说当一个error site等待注入，但是有N个上下文，那么实际上相当于要注入N个不同的error site...</p></div><footer class=entry-footer><span title='2023-06-29 00:00:00 +0000 UTC'>June 29, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;120 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-29 00:00:00 +0000 UTC'>June 29, 2023</span>&nbsp;|&nbsp;时长: 1分钟&nbsp;|&nbsp;JUHUA</footer><a class=entry-link aria-label="post link to Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection" href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-using-context-sensitive-software-fault-injection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection</h2></header><div class=entry-content><p>中文译名：基于软件故障注入的设备驱动程序模糊错误处理代码 作者：蒋mingzhu 单位： 清华大学 国家： #中国 年份： #2019年 来源： #IEEE_ISSRE_CCFB 关键字： #fuzzing #故障注入 代码地址： 笔记建立时间： 2023-06-27 17:15
Abstract much error handing code in drivers is triggered by occasional errors (such as insufficient memory and hardware malfunctions) that not related to inputs this method based on software fault injection firstly, at complie time, FIZZER uses static analysis to reccommend possible error sites that can trigger error handling code. Then, during driver execution, by analyzing runtime information, it automatically fuzzes error-site sequences for fault injection to improve code coverage....</p></div><footer class=entry-footer><span title='2023-06-27 00:00:00 +0000 UTC'>June 27, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;436 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-27 00:00:00 +0000 UTC'>June 27, 2023</span>&nbsp;|&nbsp;时长: 3分钟&nbsp;|&nbsp;JUHUA</footer><a class=entry-link aria-label="post link to Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection" href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-in-device-drivers-based-on-software-fault-injection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>AFLNET: A Greybox Fuzzer for Network Protocols 论文笔记</h2></header><div class=entry-content><p>中文译名：AFLNET：网络协议灰盒模糊器 作者：Van-Thuan Pham 单位：蒙纳士大学 国家： #澳大利亚 年份： #2020年 来源： #IEEE_ICST_CCFC 关键字： #fuzzing 代码地址： https://github.com/aflnet/aflnet 笔记建立时间： 2023-06-23 10:50
现状 当前的模糊测试器对协议进行模糊测试的效果不好
缺乏针对状态的变异策略 需要已知协议模型 方法 AFLNET使自动状态模型推理和覆盖引导模糊协同工作; 模糊化有助于生成新的消息序列来覆盖新的状态，并使状态模型逐渐更加完整。同时，动态构建的状态模型通过使用保留消息序列的状态覆盖和代码覆盖信息，帮助将模糊测试推向更重要的代码部分。 输入是捕捉的流量pcap文件 使用wireshark自动提取request序列 request sequence parser生成初始信息序列语料库 使用协议规格信息提取单个请求 首先从pcap文件中过滤出响应，利用响应跟踪client的请求 识别每个跟踪中消息的开始和结束（利用特定报头和结束符） 按照相应的服务器状态转换顺序将每个消息关联起来（通过逐个发送消息和解析响应来完成的。） 信息序列语料库的形式是信息序列的链表 State Machine Learner 利用服务器响应，并用新观察到的状态和转换增强已实现的协议状态机 (IPSM)。 通过提取response中的状态码实现 AFLnet维护一个状态语料库，包括状态条目列表（包含状态相关信息）和将状态条目列表映射到对应信息序列条目的哈希映射 Target State Selector利用IPSM的信息来选择AFLnet聚焦的下一个状态（倾向于未出现，很少出现的状态） 利用启发式算法 例如选择状态s的概率和变异后的消息序列中已执行了s的比例成反比，说人话就是s执行的越少越容易被选择 为了最大化发现新状态转换的可能性，AFLNET优先选择在以前选择时特别成功地增加了代码或状态覆盖率的状态。 值得注意的是Target State Selector在初期是随机选择，只有在积累了足够多的状态信息后才会开始利用启发式算法进行选择 Sequence Selector在Target State Selector选择了状态后，利用哈希映射选择一个可以到达已选状态的消息序列（随机选择） Sequence Mutator是用协议感知的突变操作符（protocol-aware mutation operators）增强了AFL的fuzz_one方法。 基于Sequence Selector选择的序列M生成M‘, 并且保证M’同样可以达到状态s 为了确保能M‘也可以达到状态s，AFLnet将序列M分为M1、M2、M3，只对M2进行变异，组合后得到M' M1是到达状态s的序列 M2是出于状态s的序列 M3是剩下的序列 变异的操作称之为协议感知的突变操作符，很高大上，其实还是变异的老操作（替换插入复制删除），区别是应用在消息层面，除此之外，仍然保留了字节级别的变异 如果M’出发了新状态或者新的状态转换或者出发了server的源代码的新分支，则也会被加入语料库 原文第四页给了个例子</p></div><footer class=entry-footer><span title='2023-06-23 00:00:00 +0000 UTC'>June 23, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;68 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-23 00:00:00 +0000 UTC'>June 23, 2023</span>&nbsp;|&nbsp;时长: 1分钟&nbsp;|&nbsp;JUHUA</footer><a class=entry-link aria-label="post link to AFLNET: A Greybox Fuzzer for Network Protocols 论文笔记" href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflnet-a-greybox-fuzzer-for-network-protocols/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>AFLGO Directed Greybox Fuzzing</h2></header><div class=entry-content><p>#定向fuzzing
ABSTRACT 背景（问题）：现有灰盒fuzzer不能进行有效的定向fuzz 方法：基于模拟退火的power schedule，可以将更多的能量分配给更接近目标位置的种子，同时减少分配给距离目标距离更远的种子的能量。 成果：优于基于符号执行的定向白盒测试和非定向的灰盒测试；可以和谷歌持续模糊测试平台OSS-Fuzz进行整合；可以在几个模糊不清的安全关键项目（如LibXML2）中发现39个bug INTRODUCTION 定向fuzz的应用：补丁测试；崩溃重现；信息流检测
基于符号执行的白盒定向模糊测试的问题：耗时长
DFG：在本文中，我们介绍了定向灰盒模糊(DGF)，它专注于到达程序中给定的目标位置集。在高层次上，我们将可达性作为一个优化问题，并使用特定的元启发式来最小化生成的种子到目标的距离。为了计算种子距离，我们首先计算并测量每个基本块到目标的距离。虽然种子距离是过程间的，但我们的新度量只需要对调用图进行一次分析，对每个过程内CFG进行一次分析。在运行时，fuzzer聚合每个练习的基本块的距离值，以计算种子距离作为它们的平均值。DGF用于最小化种子距离的元启发式方法被称为模拟退火[19]，并被实现为功率调度。能量表控制所有种子[6]的能量。种子的能量是指种子发毛所花费的时间。像所有的灰盒模糊技术一样，通过将分析转移到编译时，我们可以最小化运行时的开销。
与基于符号执行的白盒定向模糊测试的区别：DGF将目标位置的可达性作为优化问题，而现有的定向（白盒）模糊方法将可达性作为迭代约束满足问题。
主要工作：灰盒模糊和模拟退火的整合；可以考虑多个目标、在检测时预先计算、可以运行时导出的，适用于程序间的一种正式的距离度量方法；AFLGO的实现整合和实验
MOTIVATING EXAMPLE 以心脏滴血漏洞为例子，简单来说该漏洞原理就是没有做边界检测而导致的数据溢出。
2.1 heartbleed and patch testing 简单的说，服务器端得到数据包，数据包长度为plen_real，而数据包中包含一个字节表明有效负载数据长度plen_fake，数据包剩下的部分是有效负载数据，长度为plen_real-1。整个数据包存储在一个char型数组之中。而服务器端构造新数据包时，先分配一段plen_fake+1的内存空间，前两个字节存放plen_fake，之后使用memcpy从收到的数据包有效负载数据起始位置向新数据包拷贝plen_fake字节数据。正常情况下plen_fake = plen_real-1，当用户有意设置plen_fake大于实际有效负载长度plen_real-1时，服务器就会发送plen_fake长度的数据，其中包括plen_fake - plen_real-1长度的数据，这些数据可能是一些用户密码或者密钥。
作者将AFLGO和KATCH比较，KATCH是最先进的基于符号执行的自动补丁测试工具。
2.2Fuzzing the Heartbleed-Introducing Source Code Commit 简述KATCH的工作原理：首先识别最接近目标t的基本块bi，然后构建可以到达该基本块的路径约束，接着识别决定从bi到达t的字节是哪个，最后把完整的路径约束放到SMT中求解。 基于符号执行的定向白盒模糊测试缺陷：耗时久，每探索一条路径都要重新计算距离；搜索可能不完整，解释器和求解器可能不支持语言特性或字节码；贪婪搜索可能陷入局部最优 AFLGO优势：AFLGo每秒生成并执行数千个输入，并在不到20分钟的时间内暴露Heartbleed；在运行时几乎不需要程序分析，只需要在编译/插装时进行轻量级程序分析；实现了基于模拟退火的全局搜索；实现了并行搜索，同时搜索多个目标 AFLGO测试心脏滴血流程 首先对OPENSSL插桩。对于插桩后的二进制程序，AFL负责检测代码覆盖率，AFLGO负责检测种子到目标的距离 然后使用模拟退火对OPENSSL模糊测试。 AFLGo进入探索阶段，并像AFL一样工作。在探索阶段，AFLGo随机变异提供的种子，以产生许多新的输入。如果一个新的输入增加了代码覆盖率，它将被添加到要模糊化的种子集;否则，将被丢弃。提供的和生成的种子在一个连续的循环中被模糊化。 在开发阶段，AFLGo从离目标更近的种子中产生更多的新输入，基本上不会浪费宝贵的时间去模糊太远的种子。AFLGo根据作为功率调度实现的退火函数，慢慢地从探索阶段过渡到开发阶段。 3 TRCHNIQUE 3.2Measure of Distance between a Seed Input and Multiple Target Locations 为函数调用图和基本块级的CFG中的每个节点分配一个值。
将距离为f (n,n’)的函数定义为调用图CG中函数n和n’之间沿最短路径的边数。我们将函数n与目标函数Tf之间的函数级目标距离df(n,Tf)定义为n与任何可达目标函数tf∈Tf之间的函数距离的调和平均值
m是基本块，n是函数
R（n,Tf）是所有可以从n到达的目标函数集合
db(m1,m2)是基本块m1和m2之间沿着最短路径的边数。
N(m)是基本块m调用的函数集合
T是图Gi中的基本块的集合
Gi是控制流图
基于上面的定义，基本块m到目标基本块Tb的距离为这个
种子s到目标基本块Tb的距离（normalized seed distance）为这个（种子的路径包含的基本块到目标基本块的和除以种子路径包含基本块的数量） $$d(s,T_{b})=\frac{\sum_{m\in\xi(s)}d_{b}(m,T_{b})}{|\xi(s)|} $$
作者还定义了normalized seed distance $$\tilde{d} (s,T_b)$$，这是种子s到目标基本块Tb的距离和种子序列中与目标基本块Tb的最小距离的差值比上最大距离和最小距离的差值 $$ \tilde { d } ( s , T _ { b } ) = \frac { d ( s , T _ { b } ) - \mathrm { m i n D } } { \mathrm { m a x } \mathrm { D - m i nD } } $$...</p></div><footer class=entry-footer><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;时长: 2分钟&nbsp;|&nbsp;JUHUA</footer><a class=entry-link aria-label="post link to AFLGO Directed Greybox Fuzzing" href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflgo-directed-greybox-fuzzing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing</h2></header><div class=entry-content><p>中文译名：通过日志引导的安卓智慧电视漏洞模糊测试 作者：Yousra Aafer 单位：滑铁卢大学 国家： #法国 年份： #2021年 来源： #USENIX会议 关键字： #fuzzing 代码地址： 笔记建立时间： 2023-04-22 14:16
abstract 开发了一种新的动态模糊方法，其特点是基于日志的动态输入规范推导和反馈收集。我们的解决方案进一步引入了一种新的外部观察者，它可以监测与电视相关的物理症状 (即视觉和听觉)，以检测潜在的身体异常。
introduction 静态分析发现“有趣”的定值目标，作者专注于供应商集成到操作系统中的 API 动态分析曹勇即时日志分析技术，推断目标 API 的输入规范并收集执行反馈。 background 操作系统定制化 API 多 操作设备物理状态的 API 运行在高权限环境中 大多数 API 缺乏保护机制 挑战 逆向分析目标接口 对输入标准的逆向 对本地层的 API 描述符的逆向 评估执行反馈——主要是程序肯能不会崩溃，但是设备的物理反应会存在异常 0 Design Overview 4 Fuzzing Target Locator 目的：提取程序中的定制服务 方法：将提取的 api 和 AOSP 模型的 API 比较，AOSP 中没有的就是定制 api 检测系统服务 API java 层 api 可以从相应服务 IBinder 接口的字节码中提取 本机层 api 求助于在底层 Binder IPC 中提取本地函数的接口 也就是说，对于每个本机 API，我们的目标是从本机二进制文件中恢复事务 id、参数、回复数据类型 提取本地函数接口 对这部分不感兴趣，跳过。...</p></div><footer class=entry-footer><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;120 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;时长: 1分钟&nbsp;|&nbsp;JUHUA</footer><a class=entry-link aria-label="post link to Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing" href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/android-smarttvs-vulnerability-discovery-via-log-guided-fuzzing/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://juhuax.github.io/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://juhuax.github.io/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>