<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法知识点 on Blog</title>
    <link>https://example.com/tags/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
    <description>Recent content in 算法知识点 on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Athul</copyright>
    <lastBuildDate>Thu, 22 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/tags/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前缀和（前缀和矩阵）</title>
      <link>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5/</guid>
      <description>前缀和 //构建前缀和数组 for (int i = 1; i &amp;lt;= n; i ++ ) s[i] = x + s[i - 1]; //计算某n个连续的数的和 sum = s[i] - s[i - n]; 前缀和矩阵 //构建前缀和矩阵 for (int i = 1; i &amp;lt;= n; i ++ ) for (int j = 1; j &amp;lt;= n; j ++ ) { int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); s[i][j] = x + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } //计算矩阵块的和 int get_sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; } //计算矩阵块的大小 int get_cnt(int x1, int y1, int x2, int y2) { return (x2 - x1 + 1) * (y2 - y1 + 1); } </description>
    </item>
    
    <item>
      <title>差分</title>
      <link>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/</guid>
      <description>参考：(17条消息) 差分 &amp;ndash;算法竞赛专题解析（32）罗勇军的博客-CSDN博客</description>
    </item>
    
    <item>
      <title>邻接表</title>
      <link>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8/</guid>
      <description>模板代码 int idx； int h[N], e[N], ne[N], w[N;] // 注意这里要初始化 head 为 -1 memset(h, 0xff, sizeof(h)); // 加入有向边 (x, y)，权值为 z void add(int x, int y, int z) { // 真实数据 e[idx] = y, w[idx] = z; // 在表头 x 处插入 ne[idx] = h[x], h[x] = idx++; } // 访问从 x 出发的所有边，注意这里终止条件的不同 for (int i = h[x]; ~i; i = ne[i]) {//~i表示i不等于-1 int y = e[i], z = w[i]; } 邻接表构成的数据结构图示 注意这里有个容易搞混的点，每条链表上挂的是从对应头结点的所有出边，而不是图中的一条路径。</description>
    </item>
    
    <item>
      <title>闫氏DP分析法</title>
      <link>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%97%AB%E6%B0%8Fdp%E5%88%86%E6%9E%90%E6%B3%95/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%97%AB%E6%B0%8Fdp%E5%88%86%E6%9E%90%E6%B3%95/</guid>
      <description>题干：N 个物品，每个物品有对应的价值和体积，背包容量为 V，如何选择物品使得在不超过背包容量的前提下，价值之和最大。 每个物品都可以选和不选，两种选择，那么一共有 $2^N$ 两种方案，所以题目是一个有限集合的最值问题，所以可以用 y 氏 DP 法来分析
步骤一：状态表示 $f(i,j)$
确定集合：（i 和 j 表示的意思）在只考虑前 i 个物品，并且物品总体积不超过 j 的选法的集合 属性：（$f(i,j)$ 的值代表的意思，和题意相关）当前集合中的最大价值 步骤二：状态计算 那么 $f(i,j)$ 如何计算呢，对于上述的集合，我们可以分为两个子集 一个子集是没有选择物品 i 的集合 如果不选择物品 i，那么我们只需要找到只考虑前 $i-1$ 个物品，并且物品总体积不超过 j 的选法集合中的最大价值，也就是 $f(i-1,j)$ 一个子集是选择了物品 i 的集合 如果选择了物品 i，那么我们只需要找到只考虑前 $i-1$ 个物品，并且物品总体积不超过 $j-v[i]$ 的选法集合中的最大价值，也就是 $f(i-1,j-v[i])$ 然后加上物品 i 的价值 $w [i]$ $f(i-1,j-v[i])+w[i]$ 注意 j 和 v[i]的大小 板子 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; const int N=1005; int n,v; int V[N],W[N]; int dp[N][N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;v; for(int i=1;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;V[i]&amp;gt;&amp;gt;W[i]; for(int i=1;i&amp;lt;=n;i++){ for(int j=0;j&amp;lt;=v;j++){ dp[i][j]=dp[i-1][j]; if(j&amp;gt;=V[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-V[i]]+W[i]); } } cout&amp;lt;&amp;lt;dp[n][v]; return 0; } 优化 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; const int N=1005; int n,v; int V[N],W[N]; int dp[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;v; for(int i=1;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;V[i]&amp;gt;&amp;gt;W[i]; for(int i=1;i&amp;lt;=n;i++) for(int j=v;j&amp;gt;=V[i];j--) dp[j]=max(dp[j],dp[j-V[i]]+W[i]); cout&amp;lt;&amp;lt;dp[v]; return 0; } </description>
    </item>
    
  </channel>
</rss>
