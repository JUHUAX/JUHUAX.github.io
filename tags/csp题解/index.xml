<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CSP题解 on BLOG</title>
    <link>https://juhuax.github.io/tags/csp%E9%A2%98%E8%A7%A3/</link>
    <description>Recent content in CSP题解 on BLOG</description>
    <image>
      <title>BLOG</title>
      <url>https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 22 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://juhuax.github.io/tags/csp%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>13年12月CCF计算机软件能力认证</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/13%E5%B9%B412%E6%9C%88ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/13%E5%B9%B412%E6%9C%88ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>如此编码 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 25; int n,m; int a[N],c[N],b[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(int i = 1; i &amp;lt;= n; i++) cin&amp;gt;&amp;gt;a[i]; c[0] = 1; c[1] = a[1]; for(int i = 2 ; i &amp;lt;= n; i++) c[i] = c[i-1] * a[i]; for(int i = 1; i &amp;lt;= n; i++){ b[i] = m % a[i]; m = m / a[i]; } for(int i = 1; i &amp;lt;= n; i++) cout&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; return 0; } 出现次数最多的数 #include&amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>第21次CCF计算机软件能力认证</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC21%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC21%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>期末预测之安全指数 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int n, sum = 0; cin&amp;gt;&amp;gt;n; while(n--){ int s, w; cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;w; sum += (s*w); } int ans = max(0, sum); cout&amp;lt;&amp;lt;ans; return 0; } n = int(input()) sum = 0 for i in range(0, n): s, w = map(int, input().split()) sum = sum + s * w ans = max(0, sum) print(ans) 期末预测之最佳阈值 关键：巧妙的将计数转变为前缀和问题 问题的关键在于如何快速的统计每一个阈值预测正确的个数？ Y 总的方法是采用前缀和的方法来统计个数，如何将分散的数据转变为可以用前缀和的数据呢，就是按照阈值对数据进行排序。这样的效果就是阈值 i 预测正确的个数就是在 i 前的数据的预测结果为 0 的个数加上在 i 后数据预测结果为 1 的个数。 那么我们维护两个前缀和数组 s1 和 s0，s1 [i]表示 i 前（包括 i）的数据中 1 的个数，s0 [i]同理。那么对于数据 i 对应的阈值来说，预测正确的个数就是 s1 [m] - s1 [i - 1] + s0[i - 1]</description>
    </item>
    
    <item>
      <title>第22次CCF-CSP计算机软件能力认证题解</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC22%E6%AC%A1ccf-csp%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC22%E6%AC%A1ccf-csp%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>灰度直方图 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 500; const int L = 256; int gray_L[L]; int main(){ int n, m, l, tmp; cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;l; for(int i = 0; i &amp;lt; n; i ++){ for(int j = 0; j &amp;lt; m; j ++){ cin&amp;gt;&amp;gt;tmp; gray_L[tmp]++; } } for(int i = 0; i &amp;lt; l; i ++){ cout&amp;lt;&amp;lt;gray_L[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } return 0; } n, m, l = map(int, input().split()) ans = [ 0 for i in range(0, 257)] for i in range(0, n): L = list(map(int, input().</description>
    </item>
    
    <item>
      <title>第23次CCF-CSP计算机软件能力认证题解</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC23%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC23%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>数组推导 当 b[i] == a[i]的情况下，数组 a 的和是最大的情况 当 b[i] == b[i-1]的时候，a[i] == 0 的情况下，数组 a 最小 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 105; int a[N], b[N]; int n; int main(){ int sum_max = 0, sum_min = 0; cin &amp;gt;&amp;gt; n; cin &amp;gt;&amp;gt; b[0]; sum_max = b[0]; sum_min = b[0]; for(int i = 1; i &amp;lt; n; i++){ cin&amp;gt;&amp;gt; b[i]; sum_max += b[i]; if(b[i] != b[i - 1]) sum_min += b[i]; } cout &amp;lt;&amp;lt; sum_max &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; sum_min; return 0; } 非零段划分 参考 我们可以先做下面这个题，本题算是下面这个题的简化版本。 2014.</description>
    </item>
    
    <item>
      <title>第27次CCF-CSP计算机软件能力认证题解</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC27%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC27%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>如此编码 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 25; int n,m; int a[N],c[N],b[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(int i = 1; i &amp;lt;= n; i++) cin&amp;gt;&amp;gt;a[i]; c[0] = 1; c[1] = a[1]; for(int i = 2 ; i &amp;lt;= n; i++) c[i] = c[i-1] * a[i]; for(int i = 1; i &amp;lt;= n; i++){ b[i] = m % a[i]; m = m / a[i]; } for(int i = 1; i &amp;lt;= n; i++) cout&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; return 0; } 何以包邮 ？ 暴力循环的写法，可以过 70%的数据</description>
    </item>
    
    <item>
      <title>第二十次CCF计算机软件能力认证题解</title>
      <link>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>称检测点查询 直接排序选择前三就行
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int N = 210; int n, X, Y; struct Point { int x, y, d; int id; bool operator&amp;lt; (const Point&amp;amp; t) const { if (d != t.d) return d &amp;lt; t.d; return id &amp;lt; t.id; } }q[N]; int get_dist(int x1, int y1, int x2, int y2) { int dx = x1 - x2; int dy = y1 - y2; return dx * dx + dy * dy; } int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y; for (int i = 0; i &amp;lt; n; i ++ ) { int x, y; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; q[i] = {x, y, get_dist(X, Y, x, y), i + 1}; } sort(q, q + n); for (int i = 0; i &amp;lt; 3; i ++ ) cout &amp;lt;&amp;lt; q[i].</description>
    </item>
    
  </channel>
</rss>
