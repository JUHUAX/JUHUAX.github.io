<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits | JUHUA&#39;s Blog</title>
<meta name="keywords" content="论文阅读">
<meta name="description" content="中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美">
<meta name="author" content="JUHUA">
<link rel="canonical" href="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6fe7a734c938045d38ba208ee06988876feb2f2b31ad362b01be1af9ca77256f.css" integrity="sha256-b&#43;enNMk4BF04uiCO4GmIh2/rLysxrTYrAb4a&#43;cp3JW8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" />

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits" />
<meta property="og:description" content="中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/" /><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" /><meta property="og:site_name" content="JUHUA&#39;s Blog" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits"/>
<meta name="twitter:description" content="中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://juhuax.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "学习",
      "item": "https://juhuax.github.io/posts/study/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits",
      "item": "https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits",
  "name": "SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits",
  "description": "中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美",
  "keywords": [
    "论文阅读"
  ],
  "articleBody": "中文译名：SemFuzz:基于语义的概念验证漏洞自动生成 作者：wei you btw 二作和三作是 IIE，三作是陈凯 单位：印第安纳大学伯明顿分校 国家： #美国 年份： #2017年 来源： #ccs\n关键字： #fuzzing #定向fuzzing #generate_poc 代码地址： 笔记建立时间： 2023-04-10 09:47\n摘要 提出 semfuzz，利用漏洞相关文本（例如，CVE 报告和 Linux git 日志）来指导 PoC 的自动生成 基于 NLP 来进行信息提取 基于语义的模糊处理来生成 PoC SemFuzz 运行了过去五年报告的112个 Linux 内核缺陷，成功触发了其中的18个，并进一步发现了一个零日漏洞和一个未公开的漏洞。 怎么感觉成功触发的有点少啊\nInstruction 漏洞的 CVE 报告，Linux git 日志、论坛和博客上发布的错误描述都可以用来帮助自动生成 PoC\n从攻击方角度来说如何去利用这些信息 从防守方角度来说，如何控制这些信息的泄露 自动生成 exploit 的挑战 自动生成 exp 很困难，目前能够实现的都是针对一些简单的输入验证类的漏洞。其他类型的漏洞 (如不受控制的资源消耗、死锁、内存损坏等)的 exp 自动生成过于复杂，目前（2017 年前）还没人做。 目前的方法主要就是符号执行找到约束，求解约束 但是就算是简单的输入验证类漏洞，符号执行和约束求解也是困难的。因为现实世界的程序的漏洞的路径约束往往是非线性的，增大了求解难度 本文方法 利用与漏洞相关的非代码文本，特别是 CVE 报告和 Linux git 日志，来提取指南，这些指南被认为是有助于发现和触发一组深层错误的信息。 本文的技术是基于语义的模糊测试，自动分析错误报告，以在 Linux 内核漏洞上创建端到端的 PoC 首先利用 NLP 来分析 CVE 和 git 日志，利用这些信息来创建一个到达漏洞函数的调用序列 利用模糊测试迭代的调整各个调用的参数，以移动到函数内部的修补代码，直到触发漏洞。（我的理解就是被测程序实际上是没有这个修补代码的，已修补的程序修补代码的位置就是未修补程序漏洞的位置） SemFuzz 能够处理内核代码中的各种漏洞 DESIGN OVERVIEW SemFUZZ 主要是两个步骤：\n语义信息提取 基于语义的 fuzzing 上图是个示例，左上方是 CVE 描述，左下方是漏洞的 git 日志。semfuzz 首先启动内核准备 fuzz 环境，使用从描述中发现的概念 (即“MSG MORE”，“loopback”，“UDP”)构建种子输入——就是右上的 system call。在 fuzzing 过程中根据从补丁中提取到的信息（cfg）和监控关键变量的反馈对输入进行变异，直到触发漏洞。 说明。 语义信息的提取 基于正则表达式的字符串匹配等语法手段直接提取信息的效果不好，没有考虑单词之间互相的依赖性，没有考虑语句的语义。 采用 NLP、词性标记 POS、短语解析和句法解析，SemFuzz 构建了一个解析树来识别每个单词的 POS 标记，并识别句子中的句法子句以进行语义分析。 生成解析树 使用 NLP 工具 pyStatParser 从 Penn 树库学习概率上下文无关语法，并为 CVE 和 git 日志中的每个句子生成解析树。上图右下角展示的就是\"the whole skb len is dangerous\"的语法树，每个叶子的父节点是单词对应的 POS 标记。\n提取受影响的版本 先利用正则表达式在 CVE 和 git 日志中识别版本号，然后在解析树中定位包含版本号的句子。定位句子主要是为了过滤信息，因为 SemFuzz 是对 Linux 内核的 fuzz，所以只找 Linux 的版本号，过滤其他应用程序的版本号。\n提取漏洞类型 作者根据 CWE 为 SemFuzz 设置了 16 种漏洞候选类型，SemFuzz 在解析树中的 NP（名词短语）节点中寻找候选类型，如果没有找 到，就用 CVE 编号作为关键字去 NVD 中搜索 Technical Details 字段得到漏洞类型。\n提取漏洞函数 SemFuzz 将未修补的 Linux 内核版本与修补过的 Linux 内核版本 (在 git 日志中表示)进行比较，并将修改过的函数定位为候选脆弱函数。 通过以下观察进一步定位真实的漏洞: (1)如果在 CVE 描述中还提到了一个修补过的函数，则该函数更有可能是漏洞函数;(2)如果 CVE 描述或补丁描述中提到的某个变量，则更有可能与该脆弱功能有关。 SemFuzz 首先在解析树中搜索修补函数的名称，并将发现的函数视为脆弱函数。如果没有发现，SemFuzz 将解析树中的名词与补丁函数中的变量进行比较。\n提取关键变量 关键变量需要满足两个条件\n出现在未被修补的脆弱函数中 在 CVE 或 git 日志中有所提及 SemFuzz 首先从未修补的脆弱函数中提取所有变量，构建一个包含变量和其类型信息的符号表。然后 SemFuzz 检查符号表中的任何变量是否存在在解析树的名词或形容词结点。\n提取系统调用 因为 CVE 和 git 日志中可能不会显式的提到可以触发漏洞的系统调用，所以作者建立了一个知识库 (系统调用及其参数之间的关系)，用于将 CVE 或 git 日志描述中的关键字与特定领域的概念关联起来。 作者基于 Linux 程序员手册 LPM 来构建知识库：\nLPM 的系统调用的 SYNOPSIS 字段进行了声明，若参数中有枚举类型，则 DESCRIPTION 字段列举了类型为枚举的参数的所有值，将这些枚举值与系统调用相关联。 系统调用的 see also 字段包含了其他相关信息，在 SEE ALSO 字段的其他 LPM 页面中也会存在相关的系统调用，识别 synopsis 字段的示例代码和 description 字段中的关键结构的特殊值，并将其与 LMP 名称关联 当一个系统调用的参数名等于另一个系统调用的返回变量名时，SemFuzz 桥接两个系统调用之间的关联。 在以这种方式分析了所有页面之后，SemFuzz 能够在使用 POS 标签 NN (即名词)在解析树的叶中识别关键字时检索系统调用及其参数。 使用这种方法，SemFuzz 自动分析1082个 LPM 页面，并将373个系统调用与2000多个关键字关联起来，这比仅使用系统调用名作为关键字的次数要多。从我们对112个 cve 的评估中，SemFuzz 可以成功检索其中96个 (86%)的系统调用，以进行进一步的模糊处理。\n语义引导的模糊测试 SemFuzz 从 CVE 和 Linux git 日志中的非代码文本中提取必要的信息或指南，以指导模糊处理过程。特别是，检索到的“受影响版本”帮助 SemFuzz 设置正确的测试环境。然后 SemFuzz 使用检索到的“系统调用”生成第一个输入 (即种子输入)。在模糊处理过程中，SemFuzz 对输入执行粗突变，以找到可以将执行移向“脆弱函数”的系统调用序列。在此之后，SemFuzz 通过监视“关键变量”继续对系统调用序列执行细粒度突变，直到根据“漏洞类型”指定的攻击结果的标志发现目标漏洞被触发。\n设置测试环境 加载一个易受攻击的 Linux 内核并进行一系列系统调用 在虚拟机内部构建 Linux 内核，并让 SemFuzz 从外部 (即在主机上)加载它 预先构建了103个 Linux 内核版本，以避免冗余构建以节省时间 当从 CVE 中检索到版本号时，SEMFUzz 的 out-box 加载器加载对应版本，然后 in-box 向内核发送一系列系统调用 观察内核的执行状态，包括执行的函数、关键变量的值和内核的异常事件 为了监控执行的函数，利用 KCOV（内核代码覆盖）来跟踪内核中执行的代码 为了跟踪关键变量，作者去观察内核函数的参数，而不是关键变量 原因 在源代码中对关键变量插桩不灵活，每次观察不同的变量都要重新编译 动态检测，在运行时定位关键变量，但是这样的变量可能会在编译的时候被优化掉 操作 对关键变量执行向后的过程内数据流和控制流做静态分析，找到关键变量依赖的参数 为了捕获内核的异常时间，semfuzz 在虚拟机之外监视内核 实现 基于最先进的 Linux 系统调用 fuzzer Syzkaller 构建 SemFuzz。对于 in-box observer, Syzkaller 可以直接调用 KCOV 的 API，获取内核的执行状态。除此之外，Syzkaller 可以通过随机添加、删除或改变系统调用及其序列中的参数来执行模糊。至于 out-box observer，Syzkaller 监视内核是否崩溃或挂起，还检查内部内核错误检测器的输出 (例如，KASAN 用于检测内存错误，UBSAN 用于检测未处理的行为，如整数超过 (ow))。\n生成种子输入 种子输入是通过以下两个步骤构建的。\n所有检索到的系统调用 (以及检索到的参数值)被放在一起作为不完整的种子输入。 如果参数是一个结构，则填充结构中的每个字段。对于枚举字段，用从 LPM 学到的相关枚举值填充。对于其他字段，使用与其类型兼容的随机值填充。 其次，SemFuzz 将其他系统调用与检索到的系统调用关联起来，并将它们放入种子输入中。如第4节所述。 为什么要这么做的，因为一个系统调用可能无法正确执行，比如漏洞函数相关的系统调用是 send，但是光有 send 不行，send 之前还得有 bind，所以输入的种子得是一个系统调用序列 作者进一步将这种相关性扩展到共享相同类型的系统资源 (例如，文件，套接字)的系统调用。通过这种方式，所有相关的系统调用都放在种子输入中。虽然这可能会带来一些无用的系统调用来触发漏洞，但它增加了命中脆弱函数的概率。 粗粒度变异 这一步的目标是生成一个可以让执行到达易受攻击函数的输入 把每次使用输入的运行都称为一个模糊实例。然后，对于每个实例，我们通过 in-box observer 观察 Linux 内核的执行情况，并测量脆弱函数与模糊实例的执行轨迹之间的距离。选择与最短距离对应的输入作为新的种子输入进行下一轮模糊，直到达到任何脆弱函数。\n将两个节点 dist (n1, n2)的距离定义为 n1到 n2之间最短路径上的节点数 基于距离，作者给出了优先级的计算公式 那么系统调用序列 s （输入）的优先级公式为： KCOV (s)是输入 s 在模糊实例中执行的函数集 RCG (f)为 f 的反向调用图中的函数集 那么公式的意思就是输入 s 的优先集是 s 在模糊实例中执行的函数优先级的最大值 细粒度变异 在找到允许内核运行易受攻击函数的输入 I 之后， SemFuzz 通过监视关键变量的反馈来进行细粒度的变异。 细粒度的变异不会添加或删除输入中的系统调用，而是去修改参数值。 在找到允许内核运行易受攻击函数的输入 I 之后，SemFuzz 继续使用来自监视“关键变量”的反馈来更改输入。 使用基本块之间的距离来测量输入质量，从 b1到 b2的最短路径上的基本块的数量来测量两个基本块 (b1和 b2)之间的距离，记为 distB (b1, b2)。 则输入的优先级由以下两个公式确定： KCOVB (s)为系统调用序列 s 中覆盖的基本块的集合 函数 f 的修补代码在基本块集合 PATCH = {p1, p2，…， pn} e 是 entry 评估 效率 exp 生成的有效性 此处作者分析了 semfuzz 为什么没有给出其余 94 例 cve 的原因：\n某些漏洞只有在输入 (特别是系统调用的参数)满足特定条件时才会触发，这是 SemFuzz 在有限的时间内难以生成的。 某些漏洞只有在出现竞态条件时才有可能出现。由于并发执行的不确定性，SemFuzz 仍然需要更多的时间来触发这些条件。 通过选择性符号执行和操纵线程调度来增强模糊的研究有助于进一步提高 SemFuzz 的性能。 信息取的有效性 精度高\n性能 性能好\nfind 这里作者分析了一下 cve 和 git 日志中的内容对生成 exp 的影响。这部分我感觉很好，详实了论文内容，属于是锦上添花。\n讨论 不能触发设备引起的漏洞，不能触发逻辑漏洞 可以将基于语义的 fuzz 推广到其他 fuzz 对象 除了 cve 和 git 日志还可以增加更多的信息来源 目的： 方法： 意义： 效果：\n可以对 semfuzz 进行拓展，它只支持 Linux 内核 semfuzz 的内容提取部分比较简单，不够复杂 提取的时候哪里用到 NLP 了？ 提取系统调用那里也有点简单？ 生成种子的时候系统调用序列的顺序没有很好的去处理，并且有点冗余，影响性能了 粗粒度变异那里是如何衡量距离的 后向可达性分析了解一下 Effective of exploit generation 中分析的 poc 没有生成的原因是下一步研究的方向\n",
  "wordCount" : "4321",
  "inLanguage": "en",
  "datePublished": "2023-06-22T00:00:00Z",
  "dateModified": "2023-06-22T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "JUHUA"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "JUHUA's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://juhuax.github.io/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://juhuax.github.io/" accesskey="h" title="JUHUA&#39;s Blog (Alt + H)">
                <img src="https://juhuax.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">JUHUA&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://juhuax.github.io/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/about" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://juhuax.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://juhuax.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://juhuax.github.io/posts/study/">学习</a></div>
    <h1 class="post-title">
      SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits
    </h1>
    <div class="post-meta"><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;4321 words&nbsp;·&nbsp;JUHUA










创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;更新:&nbsp;June 22, 2023&nbsp;|&nbsp;时长: 9分钟&nbsp;|&nbsp;JUHUA

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e6%91%98%e8%a6%81" aria-label="摘要">摘要</a></li>
                    <li>
                        <a href="#instruction" aria-label="Instruction">Instruction</a><ul>
                            
                    <li>
                        <a href="#%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90-exploit-%e7%9a%84%e6%8c%91%e6%88%98" aria-label="自动生成 exploit 的挑战">自动生成 exploit 的挑战</a></li>
                    <li>
                        <a href="#%e6%9c%ac%e6%96%87%e6%96%b9%e6%b3%95" aria-label="本文方法">本文方法</a></li></ul>
                    </li>
                    <li>
                        <a href="#design-overview" aria-label="DESIGN OVERVIEW">DESIGN OVERVIEW</a></li>
                    <li>
                        <a href="#%e8%af%ad%e4%b9%89%e4%bf%a1%e6%81%af%e7%9a%84%e6%8f%90%e5%8f%96" aria-label="语义信息的提取">语义信息的提取</a><ul>
                            
                    <li>
                        <a href="#%e7%94%9f%e6%88%90%e8%a7%a3%e6%9e%90%e6%a0%91" aria-label="生成解析树">生成解析树</a></li>
                    <li>
                        <a href="#%e6%8f%90%e5%8f%96%e5%8f%97%e5%bd%b1%e5%93%8d%e7%9a%84%e7%89%88%e6%9c%ac" aria-label="提取受影响的版本">提取受影响的版本</a></li>
                    <li>
                        <a href="#%e6%8f%90%e5%8f%96%e6%bc%8f%e6%b4%9e%e7%b1%bb%e5%9e%8b" aria-label="提取漏洞类型">提取漏洞类型</a></li>
                    <li>
                        <a href="#%e6%8f%90%e5%8f%96%e6%bc%8f%e6%b4%9e%e5%87%bd%e6%95%b0" aria-label="提取漏洞函数">提取漏洞函数</a></li>
                    <li>
                        <a href="#%e6%8f%90%e5%8f%96%e5%85%b3%e9%94%ae%e5%8f%98%e9%87%8f" aria-label="提取关键变量">提取关键变量</a></li>
                    <li>
                        <a href="#%e6%8f%90%e5%8f%96%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="提取系统调用">提取系统调用</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%af%ad%e4%b9%89%e5%bc%95%e5%af%bc%e7%9a%84%e6%a8%a1%e7%b3%8a%e6%b5%8b%e8%af%95" aria-label="语义引导的模糊测试">语义引导的模糊测试</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%be%e7%bd%ae%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83" aria-label="设置测试环境">设置测试环境</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a><ul>
                            
                    <li>
                        <a href="#%e7%94%9f%e6%88%90%e7%a7%8d%e5%ad%90%e8%be%93%e5%85%a5" aria-label="生成种子输入">生成种子输入</a></li>
                    <li>
                        <a href="#%e7%b2%97%e7%b2%92%e5%ba%a6%e5%8f%98%e5%bc%82" aria-label="粗粒度变异">粗粒度变异</a></li>
                    <li>
                        <a href="#%e7%bb%86%e7%b2%92%e5%ba%a6%e5%8f%98%e5%bc%82" aria-label="细粒度变异">细粒度变异</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%af%84%e4%bc%b0" aria-label="评估">评估</a><ul>
                            
                    <li>
                        <a href="#%e6%95%88%e7%8e%87" aria-label="效率">效率</a><ul>
                            
                    <li>
                        <a href="#exp-%e7%94%9f%e6%88%90%e7%9a%84%e6%9c%89%e6%95%88%e6%80%a7" aria-label="exp 生成的有效性">exp 生成的有效性</a></li>
                    <li>
                        <a href="#%e4%bf%a1%e6%81%af%e5%8f%96%e7%9a%84%e6%9c%89%e6%95%88%e6%80%a7" aria-label="信息取的有效性">信息取的有效性</a></li>
                    <li>
                        <a href="#%e6%80%a7%e8%83%bd" aria-label="性能">性能</a></li>
                    <li>
                        <a href="#find" aria-label="find">find</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e8%ae%a8%e8%ae%ba" aria-label="讨论">讨论</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>中文译名：SemFuzz:基于语义的概念验证漏洞自动生成
作者：wei you  btw 二作和三作是 IIE，三作是陈凯
单位：印第安纳大学伯明顿分校
国家： #美国
年份： #2017年
来源： #ccs<br>
关键字： #fuzzing #定向fuzzing #generate_poc
代码地址：
笔记建立时间： 2023-04-10  09:47</p>
<h2 id="摘要">摘要<a hidden class="anchor" aria-hidden="true" href="#摘要">#</a></h2>
<ul>
<li>提出 semfuzz，利用漏洞相关文本（例如，CVE 报告和 Linux git 日志）来指导 PoC 的自动生成</li>
<li>基于 NLP 来进行信息提取</li>
<li>基于语义的模糊处理来生成 PoC</li>
<li>SemFuzz 运行了过去五年报告的112个 Linux 内核缺陷，成功触发了其中的18个，并进一步发现了一个零日漏洞和一个未公开的漏洞。</li>
</ul>
<p>怎么感觉成功触发的有点少啊</p>
<h2 id="instruction">Instruction<a hidden class="anchor" aria-hidden="true" href="#instruction">#</a></h2>
<p>漏洞的 CVE 报告，Linux git 日志、论坛和博客上发布的错误描述都可以用来帮助自动生成 PoC</p>
<ul>
<li>从攻击方角度来说如何去利用这些信息</li>
<li>从防守方角度来说，如何控制这些信息的泄露</li>
</ul>
<h3 id="自动生成-exploit-的挑战">自动生成 exploit 的挑战<a hidden class="anchor" aria-hidden="true" href="#自动生成-exploit-的挑战">#</a></h3>
<ul>
<li>自动生成 exp 很困难，目前能够实现的都是针对一些简单的输入验证类的漏洞。其他类型的漏洞 (如不受控制的资源消耗、死锁、内存损坏等)的 exp 自动生成过于复杂，目前（2017 年前）还没人做。
<ul>
<li>目前的方法主要就是符号执行找到约束，求解约束</li>
</ul>
</li>
<li>但是就算是简单的输入验证类漏洞，符号执行和约束求解也是困难的。因为现实世界的程序的漏洞的路径约束往往是非线性的，增大了求解难度</li>
</ul>
<h3 id="本文方法">本文方法<a hidden class="anchor" aria-hidden="true" href="#本文方法">#</a></h3>
<ul>
<li>利用与漏洞相关的非代码文本，特别是 CVE 报告和 Linux git 日志，来提取指南，这些指南被认为是有助于发现和触发一组深层错误的信息。</li>
<li>本文的技术是基于语义的模糊测试，自动分析错误报告，以在 Linux 内核漏洞上创建端到端的 PoC
<ul>
<li>首先利用 NLP 来分析 CVE 和 git 日志，利用这些信息来创建一个到达漏洞函数的调用序列</li>
<li>利用模糊测试迭代的调整各个调用的参数，以移动到函数内部的修补代码，直到触发漏洞。（我的理解就是被测程序实际上是没有这个修补代码的，已修补的程序修补代码的位置就是未修补程序漏洞的位置）</li>
</ul>
</li>
<li>SemFuzz 能够处理内核代码中的各种漏洞</li>
</ul>
<h2 id="design-overview">DESIGN OVERVIEW<a hidden class="anchor" aria-hidden="true" href="#design-overview">#</a></h2>
<p><img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410205329.png" alt="image.png"  />

SemFUZZ 主要是两个步骤：</p>
<ul>
<li>语义信息提取</li>
<li>基于语义的 fuzzing
<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410215732.png" alt="image.png"  />

上图是个示例，左上方是 CVE 描述，左下方是漏洞的 git 日志。semfuzz 首先启动内核准备 fuzz 环境，使用从描述中发现的概念 (即“MSG MORE”，“loopback”，“UDP”)构建种子输入——就是右上的 system call。在 fuzzing 过程中根据从补丁中提取到的信息（cfg）和监控关键变量的反馈对输入进行变异，直到触发漏洞。
说明。</li>
</ul>
<h2 id="语义信息的提取">语义信息的提取<a hidden class="anchor" aria-hidden="true" href="#语义信息的提取">#</a></h2>
<ul>
<li>基于正则表达式的字符串匹配等语法手段直接提取信息的效果不好，没有考虑单词之间互相的依赖性，没有考虑语句的语义。</li>
<li>采用 NLP、词性标记 POS、短语解析和句法解析，SemFuzz 构建了一个解析树来识别每个单词的 POS 标记，并识别句子中的句法子句以进行语义分析。</li>
</ul>
<h3 id="生成解析树">生成解析树<a hidden class="anchor" aria-hidden="true" href="#生成解析树">#</a></h3>
<p>使用 NLP 工具 pyStatParser 从 Penn 树库学习概率上下文无关语法，并为 CVE 和 git 日志中的每个句子生成解析树。上图右下角展示的就是&quot;the whole skb len is dangerous&quot;的语法树，每个叶子的父节点是单词对应的 POS 标记。</p>
<h3 id="提取受影响的版本">提取受影响的版本<a hidden class="anchor" aria-hidden="true" href="#提取受影响的版本">#</a></h3>
<p>先利用正则表达式在 CVE 和 git 日志中识别版本号，然后在解析树中定位包含版本号的句子。定位句子主要是为了过滤信息，因为 SemFuzz 是对 Linux 内核的 fuzz，所以只找 Linux 的版本号，过滤其他应用程序的版本号。</p>
<h3 id="提取漏洞类型">提取漏洞类型<a hidden class="anchor" aria-hidden="true" href="#提取漏洞类型">#</a></h3>
<p>作者根据 CWE 为 SemFuzz 设置了 16 种漏洞候选类型，SemFuzz 在解析树中的 NP（名词短语）节点中寻找候选类型，如果没有找 到，就用 CVE 编号作为关键字去 NVD 中搜索 Technical Details 字段得到漏洞类型。</p>
<h3 id="提取漏洞函数">提取漏洞函数<a hidden class="anchor" aria-hidden="true" href="#提取漏洞函数">#</a></h3>
<p>SemFuzz 将未修补的 Linux 内核版本与修补过的 Linux 内核版本 (在 git 日志中表示)进行比较，并将修改过的函数定位为候选脆弱函数。
通过以下观察进一步定位真实的漏洞: (1)如果在 CVE 描述中还提到了一个修补过的函数，则该函数更有可能是漏洞函数;(2)如果 CVE 描述或补丁描述中提到的某个变量，则更有可能与该脆弱功能有关。
SemFuzz 首先在解析树中搜索修补函数的名称，并将发现的函数视为脆弱函数。如果没有发现，SemFuzz 将解析树中的名词与补丁函数中的变量进行比较。</p>
<h3 id="提取关键变量">提取关键变量<a hidden class="anchor" aria-hidden="true" href="#提取关键变量">#</a></h3>
<p>关键变量需要满足两个条件</p>
<ul>
<li>出现在未被修补的脆弱函数中</li>
<li>在 CVE 或 git 日志中有所提及</li>
</ul>
<p>SemFuzz 首先从未修补的脆弱函数中提取所有变量，构建一个包含变量和其类型信息的符号表。然后 SemFuzz 检查符号表中的任何变量是否存在在解析树的名词或形容词结点。</p>
<h3 id="提取系统调用">提取系统调用<a hidden class="anchor" aria-hidden="true" href="#提取系统调用">#</a></h3>
<p><img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411105740.png" alt="image.png"  />

因为 CVE 和 git 日志中可能不会显式的提到可以触发漏洞的系统调用，所以作者建立了一个知识库 (系统调用及其参数之间的关系)，用于将 CVE 或 git 日志描述中的关键字与特定领域的概念关联起来。
作者基于 Linux 程序员手册 LPM 来构建知识库：</p>
<ul>
<li>LPM 的系统调用的 SYNOPSIS 字段进行了声明，若参数中有枚举类型，则 DESCRIPTION 字段列举了类型为枚举的参数的所有值，将这些枚举值与系统调用相关联。</li>
<li>系统调用的 see also 字段包含了其他相关信息，在 SEE ALSO 字段的其他 LPM 页面中也会存在相关的系统调用，识别 synopsis 字段的示例代码和 description 字段中的关键结构的特殊值，并将其与 LMP 名称关联</li>
<li>当一个系统调用的参数名等于另一个系统调用的返回变量名时，SemFuzz 桥接两个系统调用之间的关联。</li>
</ul>
<p>在以这种方式分析了所有页面之后，SemFuzz 能够在使用 POS 标签 NN (即名词)在解析树的叶中识别关键字时检索系统调用及其参数。
使用这种方法，SemFuzz 自动分析1082个 LPM 页面，并将373个系统调用与2000多个关键字关联起来，这比仅使用系统调用名作为关键字的次数要多。从我们对112个 cve 的评估中，SemFuzz 可以成功检索其中96个 (86%)的系统调用，以进行进一步的模糊处理。</p>
<h2 id="语义引导的模糊测试">语义引导的模糊测试<a hidden class="anchor" aria-hidden="true" href="#语义引导的模糊测试">#</a></h2>
<p>SemFuzz 从 CVE 和 Linux git 日志中的非代码文本中提取必要的信息或指南，以指导模糊处理过程。特别是，检索到的“受影响版本”帮助 SemFuzz 设置正确的测试环境。然后 SemFuzz 使用检索到的“系统调用”生成第一个输入 (即种子输入)。在模糊处理过程中，SemFuzz 对输入执行粗突变，以找到可以将执行移向“脆弱函数”的系统调用序列。在此之后，SemFuzz 通过监视“关键变量”继续对系统调用序列执行细粒度突变，直到根据“漏洞类型”指定的攻击结果的标志发现目标漏洞被触发。</p>
<h3 id="设置测试环境">设置测试环境<a hidden class="anchor" aria-hidden="true" href="#设置测试环境">#</a></h3>
<ul>
<li>加载一个易受攻击的 Linux 内核并进行一系列系统调用
<ul>
<li>在虚拟机内部构建 Linux 内核，并让 SemFuzz 从外部 (即在主机上)加载它</li>
<li>预先构建了103个 Linux 内核版本，以避免冗余构建以节省时间</li>
<li>当从 CVE 中检索到版本号时，SEMFUzz 的 out-box 加载器加载对应版本，然后 in-box 向内核发送一系列系统调用</li>
</ul>
</li>
<li>观察内核的执行状态，包括执行的函数、关键变量的值和内核的异常事件
<ul>
<li>为了监控执行的函数，利用 KCOV（内核代码覆盖）来跟踪内核中执行的代码</li>
<li>为了跟踪关键变量，作者去观察内核函数的参数，而不是关键变量
<ul>
<li>原因
<ul>
<li>在源代码中对关键变量插桩不灵活，每次观察不同的变量都要重新编译</li>
<li>动态检测，在运行时定位关键变量，但是这样的变量可能会在编译的时候被优化掉</li>
</ul>
</li>
<li>操作
<ul>
<li>对关键变量执行向后的过程内数据流和控制流做静态分析，找到关键变量依赖的参数</li>
</ul>
</li>
</ul>
</li>
<li>为了捕获内核的异常时间，semfuzz 在虚拟机之外监视内核</li>
</ul>
</li>
</ul>
<h2 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h2>
<p>基于最先进的 Linux 系统调用 fuzzer Syzkaller 构建 SemFuzz。对于 in-box observer, Syzkaller 可以直接调用 KCOV 的 API，获取内核的执行状态。除此之外，Syzkaller 可以通过随机添加、删除或改变系统调用及其序列中的参数来执行模糊。至于 out-box observer，Syzkaller 监视内核是否崩溃或挂起，还检查内部内核错误检测器的输出 (例如，KASAN 用于检测内存错误，UBSAN 用于检测未处理的行为，如整数超过 (ow))。</p>
<h3 id="生成种子输入">生成种子输入<a hidden class="anchor" aria-hidden="true" href="#生成种子输入">#</a></h3>
<p>种子输入是通过以下两个步骤构建的。</p>
<ul>
<li>所有检索到的系统调用 (以及检索到的参数值)被放在一起作为不完整的种子输入。
<ul>
<li>如果参数是一个结构，则填充结构中的每个字段。对于枚举字段，用从 LPM 学到的相关枚举值填充。对于其他字段，使用与其类型兼容的随机值填充。</li>
</ul>
</li>
<li>其次，SemFuzz 将其他系统调用与检索到的系统调用关联起来，并将它们放入种子输入中。如第4节所述。
<ul>
<li>为什么要这么做的，因为一个系统调用可能无法正确执行，比如漏洞函数相关的系统调用是 send，但是光有 send 不行，send 之前还得有 bind，所以输入的种子得是一个系统调用序列</li>
<li>作者进一步将这种相关性扩展到共享相同类型的系统资源 (例如，文件，套接字)的系统调用。通过这种方式，所有相关的系统调用都放在种子输入中。虽然这可能会带来一些无用的系统调用来触发漏洞，但它增加了命中脆弱函数的概率。</li>
</ul>
</li>
</ul>
<h3 id="粗粒度变异">粗粒度变异<a hidden class="anchor" aria-hidden="true" href="#粗粒度变异">#</a></h3>
<p>这一步的目标是生成一个可以让执行到达易受攻击函数的输入
把每次使用输入的运行都称为一个模糊实例。然后，对于每个实例，我们通过 in-box observer 观察 Linux 内核的执行情况，并测量脆弱函数与模糊实例的执行轨迹之间的距离。选择与最短距离对应的输入作为新的种子输入进行下一轮模糊，直到达到任何脆弱函数。</p>
<ul>
<li>将两个节点 dist (n1, n2)的距离定义为 n1到 n2之间最短路径上的节点数</li>
<li>基于距离，作者给出了优先级的计算公式 <img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411161848.png" alt="image.png"  />
</li>
<li>那么系统调用序列 s （输入）的优先级公式为：<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411161951.png" alt="image.png"  />

<ul>
<li>KCOV (s)是输入 s 在模糊实例中执行的函数集</li>
<li>RCG (f)为 f 的反向调用图中的函数集</li>
<li>那么公式的意思就是输入 s 的优先集是 s 在模糊实例中执行的函数优先级的最大值</li>
</ul>
</li>
</ul>
<h3 id="细粒度变异">细粒度变异<a hidden class="anchor" aria-hidden="true" href="#细粒度变异">#</a></h3>
<p>在找到允许内核运行易受攻击函数的输入 I 之后， SemFuzz 通过监视关键变量的反馈来进行细粒度的变异。
细粒度的变异不会添加或删除输入中的系统调用，而是去修改参数值。
在找到允许内核运行易受攻击函数的输入 I 之后，SemFuzz 继续使用来自监视“关键变量”的反馈来更改输入。
使用基本块之间的距离来测量输入质量，从 b1到 b2的最短路径上的基本块的数量来测量两个基本块 (b1和 b2)之间的距离，记为 distB (b1, b2)。
则输入的优先级由以下两个公式确定：
<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411163305.png" alt="image.png"  />

<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411163333.png" alt="image.png"  />
</p>
<ul>
<li>KCOVB (s)为系统调用序列 s 中覆盖的基本块的集合</li>
<li>函数 f 的修补代码在基本块集合 PATCH = {p1, p2，…， pn}</li>
<li>e 是 entry</li>
</ul>
<h2 id="评估">评估<a hidden class="anchor" aria-hidden="true" href="#评估">#</a></h2>
<h3 id="效率">效率<a hidden class="anchor" aria-hidden="true" href="#效率">#</a></h3>
<h4 id="exp-生成的有效性">exp 生成的有效性<a hidden class="anchor" aria-hidden="true" href="#exp-生成的有效性">#</a></h4>
<p>此处作者分析了 semfuzz 为什么没有给出其余 94 例 cve 的原因：</p>
<ul>
<li>某些漏洞只有在输入 (特别是系统调用的参数)满足特定条件时才会触发，这是 SemFuzz 在有限的时间内难以生成的。</li>
<li>某些漏洞只有在出现竞态条件时才有可能出现。由于并发执行的不确定性，SemFuzz 仍然需要更多的时间来触发这些条件。</li>
<li>通过选择性符号执行和操纵线程调度来增强模糊的研究有助于进一步提高 SemFuzz 的性能。</li>
</ul>
<h4 id="信息取的有效性">信息取的有效性<a hidden class="anchor" aria-hidden="true" href="#信息取的有效性">#</a></h4>
<p>精度高</p>
<h4 id="性能">性能<a hidden class="anchor" aria-hidden="true" href="#性能">#</a></h4>
<p>性能好</p>
<h4 id="find">find<a hidden class="anchor" aria-hidden="true" href="#find">#</a></h4>
<p>这里作者分析了一下 cve 和 git 日志中的内容对生成 exp 的影响。这部分我感觉很好，详实了论文内容，属于是锦上添花。</p>
<h2 id="讨论">讨论<a hidden class="anchor" aria-hidden="true" href="#讨论">#</a></h2>
<ul>
<li>不能触发设备引起的漏洞，不能触发逻辑漏洞</li>
<li>可以将基于语义的 fuzz 推广到其他 fuzz 对象</li>
<li>除了 cve 和 git 日志还可以增加更多的信息来源</li>
</ul>
<p>目的：
方法：
意义：
效果：</p>
<p>可以对 semfuzz 进行拓展，它只支持 Linux 内核
semfuzz 的内容提取部分比较简单，不够复杂
提取的时候哪里用到 NLP 了？
提取系统调用那里也有点简单？
生成种子的时候系统调用序列的顺序没有很好的去处理，并且有点冗余，影响性能了
粗粒度变异那里是如何衡量距离的
后向可达性分析了解一下
Effective of exploit generation 中分析的 poc 没有生成的原因是下一步研究的方向</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://juhuax.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/semantic-informed-driver-fuzzing-without-both-the-hardware-devices-and-the-emulators/">
    <span class="title">« Prev</span>
    <br>
    <span>Semantic-Informed Driver Fuzzing Without Both the Hardware Devices and the Emulators</span>
  </a>
  <a class="next" href="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/semfuzz-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/">
    <span class="title">Next »</span>
    <br>
    <span>SemFuzz 总结笔记</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on twitter"
        href="https://twitter.com/intent/tweet/?text=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f&amp;title=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits&amp;summary=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits&amp;source=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f&title=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on whatsapp"
        href="https://api.whatsapp.com/send?text=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits%20-%20https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits on telegram"
        href="https://telegram.me/share/url?text=SemFuzz%20Semantics-based%20Automatic%20Generation%20of%20Proof-of-Concept%20Exploits&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fsemfuzz-semantics-based-automatic-generation-of-proof-of-concept-exploits%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>JUHUA</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
