<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices | JUHUA&#39;s Blog</title>
<meta name="keywords" content="论文阅读">
<meta name="description" content="你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字：">
<meta name="author" content="JUHUA">
<link rel="canonical" href="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4ab2947a83bffe949c0838eecd8aec6f58435be7a122bafeab2b538d1cdcf5ad.css" integrity="sha256-SrKUeoO//pScCDjuzYrsb1hDW&#43;ehIrr&#43;qytTjRzc9a0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://juhuax.github.io/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" />

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices" />
<meta property="og:description" content="你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/" /><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" /><meta property="og:site_name" content="JUHUA&#39;s Blog" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices"/>
<meta name="twitter:description" content="你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://juhuax.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "学习",
      "item": "https://juhuax.github.io/posts/study/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices",
      "item": "https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices",
  "name": "What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices",
  "description": "你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字：",
  "keywords": [
    "论文阅读"
  ],
  "articleBody": "你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战 作者：Marius Muench 单位：巴黎高等电信学院 国家： #法国 年份： #2018年 来源： #NDSS会议 关键字： #嵌入式 #综述 [[What You Corrupt Is Not What You Crash_ Challenges in Fuzzing Embedded Devices.pdf]]\nAbstract 传统的测试方法依赖于程序中看的见的崩溃, 而二进制插装技术是用来改善针对这些缺陷状态的检测方法 演示了 memory corruption 漏洞，展示 embedded devices 和 desktop systems 的不同 分析了几种 embedded devices 设备的差异 Introduction Memory corruption 导致的漏洞普遍存在，模糊测试是发现这些漏洞最流行的技术之一，适合大规模自动化 因为 embedded devices 的有限的 I/O 和计算能力，受限的成本，其上没有大部分 desktop systems 拥有的防御机制，所以发生内存损坏的概率更高 但是 embedded devices 存在缺少源码，识别 memory corruption 的传统方法不适用于的问题。 本文首次全面分析了内存损坏对不同类别的嵌入式系统的影响，并且提出的技术可以 100%检测到在模糊过程中触发的内存损坏状态 FUZZING EMBEDDED SYSTEMS 首先介绍将在本文其余部分使用的嵌入式系统的分类。然后，我们讨论了之前将模糊测试应用于不同嵌入式设备的实验，最后我们提出了在该领域应用模糊测试所遇到的挑战。\nClasses of Embedded Devices 将嵌入式设备分为以下三类\n基于 OS 的通用设备：此类设备搭载了被改装为嵌入式设备操作系统的桌面级系统。（例如，Linux 操作系统内核广泛用于嵌入式领域，通常与轻量级用户空间环境（例如 busybox 和 uClibc）结合使用。） 基于嵌入式操作系统的设备：此类设备搭载了为嵌入式设备定制的操作系统，内核和应用程序代码之间的逻辑分离仍然存在。（例如 uClinux、ZephyrOS 和 VxWorks） 没有操作系统抽象的设备：此类设备采用所谓的“单片固件”，其操作通常基于单个控制环路和从外围设备触发的中断，以处理来自外部世界的事件。固件将包含编译的系统和应用程序代码在一起，形成了一个单一的软件。（单体方法可以在各种硬件组件控制器中找到，例如 CD 读取器、WiFi 卡或 GPS 加密狗。在这些设备上运行的代码可以是完全自定义的，也可以基于操作系统库，如 Contiki、TinyOS 或 mbed OS 22。） Past Experiments 下表展示了近几年来针对嵌入式设备 fuzzing 的论文 ^eea5b5\nMain Challenges of Fuzzing Embedded Devices Fault detection 作者认为模糊测试可以通过检测程序是否崩溃来判断输入是否触发漏洞，而桌面系统存在各种防御机制来检测恶意输入从而产生崩溃，但是嵌入式设备的操作系统没有各种各样的防御机制，所以很有可能触发漏洞但是没有产生崩溃，这种情况 fuzzing 器检测不到。 对于嵌入式设备可以检测到的崩溃，可能因为缺少输出错误信息的 I/O 功能，而导致 fuzzing 器监测不到 作者给出的解决方案是部署复杂的活性探测 主动探测：将特殊请求插入到与设备或其环境的通信中 被动探测：旨在检索有关设备状态的信息而不改变它。 Performance and Scalability 嵌入式设备的 fuzzing 难以并行化 每轮 fuzzing （为了清空状态）重启设备拖慢测试过程 Instrumentation 嵌入式设备很难进行编译时检测和运行时检测来收集覆盖信息，或者通过别的一些什么技术来收集有关被测系统状态的信息。因为对于嵌入式设备而言，测试对象往往是固件映像，现有的工具不适用，不需要访问应用程序源代码的常见解决方案是求助于二进制动态检测框架。 但是作者最后指出上述所有静态和动态检测工具都与目标操作系统和 CPU 体系结构紧密相关，并且在撰写本文时，它们都不提供对 Type-II 和 Type-III 嵌入式设备的支持。 MEMORY CORRUPTIONS IN EMBEDDED SYSTEMS Bugs, Faults, Corruptions \u0026 Crashes Van der Veen 等人区分了空间记忆错误和时间记忆错误。第一种类型表示对内存对象的越界访问，第二种类型表示对不再存在的内存对象的访问 有的内存损坏不会立即引起系统崩溃，作者称之为静默崩溃。 静默内存损坏的重要后果是，实际故障可能只会在稍后请求特定功能或接收到特定事件序列时才会变得明显。 桌面系统因为有多种防御机制，所以更容易触发这种静默内存损坏，但是对于嵌入式设备缺乏防御机制，很难检测到静默内存损坏 Experimental Setup 在不同的系统上触发相同的内存损坏条件，以分析它们是否屈服于可观察到的崩溃或导致静默损坏。\n设备选择：选择了现有的商用现成 (COTS) 产品：代表 Type-I 系统的路由器和代表 Type-II 设备的 IP 摄像机。 漏洞程序部署：对于 I II 型设备，直接编译漏洞程序然后加载到设备上便可，对于 III 型设备需要将测试代码包含在固件中然后对其编译，然后将固件加载到设备上。 Atificial Vulnerabilities 使用基于堆栈的缓冲区溢出和基于堆的缓冲区溢出作为空间内存损坏的示例，并使用空指针取消引用和双重释放漏洞作为时间内存损坏的示例。 还插入了一个格式字符串漏洞，可以用于信息泄漏或任意内存损坏。 Observed Behavior 桌面系统每次都可以触发崩溃 嵌入式设备并不总是能够检测到故障，在某些情况下，它们甚至继续执行而没有明显的影响——尽管系统的底层内存已损坏。观测到以下六种状态 R1：可以观测到的崩溃 R2：设备重启 R1 和 R2 对于 fuzzing 器来说是可以检测到的，是最好的结果 R3：挂起：目标挂起并停止响应新请求，可能陷入死循环 R4：随后崩溃：目标系统继续执行一段不可忽视的时间后崩溃 挂起和后期崩溃（R3 和 R4）可能更难处理，特别是当崩溃延迟足够长以至于模糊器可能已经向目标系统发送了多个其他输入并且因此导致损坏的输入将是难以识别。 R5：故障：系统没有崩溃，但是报告了错误的数据和不正常的结果 为了检测这种情况，模糊器需要知道正确的输出是什么，一种可能的变通方法包括在两个连续的输入之间插入一些输出已知的功能测试请求。然而，即使这个解决方案足以检测到故障，它也会在模糊测试中引入相当大的延迟。 R6：无影响：尽管内存已损坏，目标仍然正常运行，没有明显的副作用。 这种最难检测 MITIGATIONS Static Instrumentation. 前提是需要源代码和编译工具链 典型的 instrumentation 包括多种技术的组合：收集执行轨迹以测量覆盖率以改变模糊输入，添加内存分配检查，或使用例如控制流完整性来强化程序。不幸的是，这些工具中的大多数还不能用于嵌入式系统。 Binary Rewriting 前提要有二进制固件镜像，设备 反汇编固件的二进制镜像，恢复内存语义、边界和数据结构具有挑战性，其次嵌入式设备的内存使用经常被优化来降低成本，几乎没有留给添加复杂 instrumentation 的空间。 Physical Re-Hosting 前提需要源代码，编译链，不同的设备 某些情况下，可以将 II 型设备的系统重新编译到更易于检测的 I 型设备上，或者 I 型设备编译到桌面系统上 除了先决条件难以实现外，在不同设备上重现原设备上的漏洞也具有挑战性，由于不同的体系结构或者重新编译引入的更改可能会让原有的漏洞不再出现。 Full Emulation 前提要有固件镜像，外设模拟器 在某些情况下，从 Type-I 固件中提取的应用程序可以虚拟地重新托管，即，它们可以在默认模拟器上运行的通用操作系统中执行。 扩展 Qemu 以模拟 STM32 芯片的 Qemu STM32 项目表明，当完整的硬件文档可用时，通过相当大的努力来实现硬件模拟，也可以完全模拟 Type-III 固件映像。 这个解决方案可以大大改善模糊。首先，测试实验可以在没有物理设备的情况下进行，因此可以实现更大的并行化。其次，动态检测技术可以很容易地应用，仿真器可以用来收集大量关于运行固件的信息。 这种解决方案的缺点是，它只适用于目标所访问的所有外设都是已知的并且可以成功模拟的情况，不幸的是，这种情况很少发生。总的来说，能够在模拟器中运行任意固件仍然是一个开放的研究问题。 Partial Emulation 前提需要固件映像、设备 这种方法首先由 Avatar[54]和 Surrogates[28]提出用于 Type-III 设备，然后在 PROSPECT[24]，[25]中扩展到 Type-I 系统。此解决方案背后的一般思想是使用经过修改的模拟器 (其中执行固件代码) 将外围交互转发到实际的物理设备。其结果提供了完全模拟解决方案的优点，而无需了解和模拟 I/O 操作。然而，此解决方案在灵活性方面所获得的好处是牺牲了性能 (由于与实际设备的额外交互) 和可伸缩性 (由于当前需要将每个模拟实例与物理设备配对)。 Hardware-Supported Instrumentation 前提需要设备，高级调试功能 (例如，跟踪调试端口和调试器) 如果测试人员可以访问具有先进硬件检测机制 (如实时跟踪) 的物理设备，则可能收集足够的信息来改进设备执行期间的故障检测。例如，芯片制造商通常嵌入硬件跟踪功能，如 ARM 的嵌入式跟踪 Macrocell (ETM) 和 Coresight 调试和跟踪，或英特尔的处理器跟踪 (PT) 技术。不幸的是，这种跟踪硬件的可用性是可变的。在低端设备 (通常是 iii 型设备) 中，制造商往往不包括任何跟踪功能，因为这种机制会对芯片表面产生相对较大的影响，因此对成本也会产生影响。开发设备可能有这样的设施 (有时在制造之前在 FPGA 上测试微控制器设计)，但这在商业生产设备中不太常见。最后，在某些情况下，调试访问可能存在，但不可用，以防止第三方分析。 在测试真实设备时，找到可用的硬件跟踪支持的可能性非常低。 总结 方案 ABC 要求测试人员修改固件镜像，但是因为种种困难，在执行第三方安全测试时，这很少是一个选项。 方案 DEF 不需要修改固件镜像，但是需要额外的技术 (软件模拟器或硬件跟踪支持) 来收集有关正在运行的固件的信息。 FAULT DETECTION HEURISTICS（故障检测启发式） 这些启发式算法是独立于实现的，这样不仅可以在实时分析设置中工作 (就像固件在模拟器中运行时那样)，而且还可以对以前收集的执行跟踪进行“事后分析”(就像在基于硬件的跟踪机制中那样)。\nSegment Tracking 段跟踪可能是旨在检测非法内存访问的最简单技术。核心思想是观察所有内存读写并验证它们是否发生在有效位置，从而以某种方式模仿 MMU 检测分段错误。这种技术只需要了解目标的内存访问和内存映射。两者都可以在模拟器中轻松访问，但是，当只有跟踪可用时，可以通过逆向工程获得内存映射。\nFormat Specifier Tracking 本质上，此保护验证格式字符串说明符在进入 printf () 系列函数时指向有效位置。在最简单的情况下，如果不存在动态生成的格式字符串说明符，那些有效位置必须位于只读段内。总而言之，这项技术不仅需要了解格式处理函数的位置，还需要了解输入其中一个函数时的寄存器状态和参数顺序。相应函数的位置及其参数顺序都可以通过逆向工程或固件的自动静态分析获得。\nHeap Object Tracking 该技术旨在检测与时间和空间堆相关的错误，并受到 [43] 中介绍的检测和运行时验证方法的影响。它通过评估分配和释放函数的参数和返回值以及记录堆对象的位置和大小来实现其目标。这允许轻松检测越界内存访问或对已释放对象的访问。然而，这种启发式方法取决于多种信息：已执行的指令、寄存器的状态、内存访问以及有关分配和释放函数的知识。后者可以通过逆向工程或通过使用高级方法来发现自定义分配器来检索，如 MemBrush 所展示的。\nCall Stack Tracking 调用堆栈跟踪正在复制传统的影子堆栈保护 [53]，因此旨在检测不返回被调用者的函数。这有助于识别覆盖函数返回地址的基于堆栈的内存损坏。它通过监视所有直接和间接函数调用和返回指令来实现。然而，由于嵌入式设备通常是中断驱动的，这种试探法可能会导致漏报。但是它需要最少的信息：只需要执行指令的知识。\nCall Frame Tracking 调用帧跟踪是调用堆栈跟踪技术的更高级版本，它可以在发生时检测粗粒度的基于堆栈的缓冲区溢出，而不会出现漏报。本质上，堆栈帧是通过跟踪函数调用来定位的，然后检查连续的内存访问是否跨越堆栈帧。因此，这需要识别执行的指令以及寄存器值，以在函数入口时提取堆栈指针值。然后，必须观察内存访问以检测实际损坏。\nStack Object Tracking 堆栈对象跟踪包括对堆栈变量越界访问的细粒度检测，这是受 Serebryany 等人提出的堆对象跟踪方法的启发。 [43]。因此，根据堆栈中的各个变量大小和位置检查执行期间观察到的内存读取和写入。显然，这需要跟踪执行的指令和内存访问，以及有关堆栈变量的详尽信息。为了简单起见，我们使用调试符号中存在的变量信息。然而，在一般情况下，可以从二进制代码中以自动方式检索此类信息，正如之前的几项研究 [22]、[47] 所提出的那样。 IMPLEMENTATION 作者基于 PANDA (动态分析平台) 和 Avatar (用于嵌入式设备动态分析的编排框架)，编写了程序，并将其开源 总之，我们使用 PANDA 来模拟固件，并依赖其插件系统来获得部分或完全模拟固件执行时的实时反馈。所有这一切都由 Avatar 编排执行，并有选择地将执行和内存访问重定向到物理设备。 Avatar 还提供了保存快照的功能。 EXPERIMENTS 目的：\n将启发式方法集成到工具中 测量方法带来的系统开销 目标设置 四种实验设置：\nNAT不添加任何启发式方法的模糊测试，作为基准 PE/MF带有内存转发的部分仿真：将 I/O 操作转发到实际设备 PE/PM具有外围建模的部分仿真：固件是模拟的，外围设备交互是通过使用 Avatar 内部的专用脚本模拟外围设备行为来处理的，这允许在没有物理设备存在的情况下进行实验。 FE完全仿真：固件及其外围设备都在 PANDA 中完全模拟。 Fuzzing Setup 基于 boofuzz 构建实验 使用 fuzzer 强制生成输入这些输入将以给定的概率触发插入的内存损坏漏洞之一。 添加了一个监视器（活性检查 liveness checks）：在每次模糊输入之后，模糊器接收设备的响应并评估它是否符合预期的行为。当收到的响应与预期的不同时，或者当连接超时时，模糊器报告崩溃并重新启动目标。 这个监视器是为了检测启发式方法没有检测到的崩溃，从而评估启发式方法的有效性 Result 目标处理的输入数量 (Itot)、损坏输入被发送到目标的次数 (IC)、活性检查 (DL) 检测到的故障数量以及故障数量由启发式 (DH) 检测到。此外，我们将未检测到的故障数表示为 (DU)。 $I_C =D_L+D_H+D_U\\approx I_{tot}*P_C$ Fault Detection 实验结果表明启发式方法确实产生了更多的崩溃，从而提高了 fuzz 的效率\n性能 具有内存转发 (PE/MF) 的部分仿真正在使模糊测试减慢一个数量级以上。这种开销是由固件和设备外围设备之间的通信引入的。这种开销的主要部分是由于 Avatar 和物理设备之间的低带宽连接，它依赖于通过 USB 连接的标准 JTAG 调试器。 Surrogates [28] 已经表明，这个问题可以通过使用专用硬件来解决，这将能够以接近实时的速度进行部分仿真。 观察单个启发式，我们可以观察到它们在 PE/MF 场景中的开销可以忽略不计，其中 MMIO 请求的转发瓶颈完全决定了模糊实验的速度。然而，在 PE/PM 和 FE 场景中，我们可以观察到 PC = 0 的启发式分析代码带来了相当大的放缓 (在 x1.5 到 x6 之间)。 另一个重要的观察结果是，只要检测到的损坏量较低，针对完全模拟目标的模糊处理速度明显快于针对物理设备的模糊处理。这主要是由于三个因素。首先，TCP 上的通信比串行端口上的通信允许更高的吞吐量。第二，即使固件是仿真的，仿真器通常比 (低资源) 嵌入式设备具有更高的时钟速度。第三，检测到的损坏与强制重新启动目标有关，这意味着高容量的 pc 会导致花费大量时间重新启动，而不是向目标发送新的输入。 然而，我们实验中最重要的结果是，在启用组合启发式的 PANDA (完全仿真) 中执行的固件在 PC 的实际值下可以比原始嵌入式设备更快地模糊化。虽然第一种方法可以检测到我们在其代码中插入的所有类型的漏洞，但第二种方法需要依赖于只能识别其中两种漏洞的活动检查。 DISCUSSION 仅仅依靠活性测试是一个糟糕的策略。仅依靠活跃度测试进行故障检测来模糊嵌入式系统是一种很可能遗漏许多漏洞的糟糕策略。同样，一次只使用一个启发式方法并不能保证检测到更多的漏洞。直观地说，通过结合几种启发式方法可以达到腐败检测的最高潜力。 完全仿真模拟器很少 部分仿真速度慢——一个数量级 这项工作也适用于嵌入式设备固件上的二进制符号执行。如果没有及时检测到损坏，符号执行可能会花费大量时间来计算无用状态。 ",
  "wordCount" : "5927",
  "inLanguage": "en",
  "datePublished": "2023-06-22T00:00:00Z",
  "dateModified": "2023-06-22T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "JUHUA"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "JUHUA's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://juhuax.github.io/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://juhuax.github.io/" accesskey="h" title="JUHUA&#39;s Blog (Alt + H)">
                <img src="https://juhuax.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">JUHUA&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://juhuax.github.io/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/about" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://juhuax.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://juhuax.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://juhuax.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://juhuax.github.io/posts/study/">学习</a></div>
    <h1 class="post-title">
      What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices
    </h1>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#abstract" aria-label="Abstract">Abstract</a></li>
                    <li>
                        <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                    <li>
                        <a href="#fuzzing-embedded-systems" aria-label="FUZZING EMBEDDED SYSTEMS">FUZZING EMBEDDED SYSTEMS</a><ul>
                            
                    <li>
                        <a href="#classes-of-embedded-devices" aria-label="Classes of Embedded Devices">Classes of Embedded Devices</a></li>
                    <li>
                        <a href="#past-experiments" aria-label="Past Experiments">Past Experiments</a></li>
                    <li>
                        <a href="#main-challenges-of-fuzzing-embedded-devices" aria-label="Main Challenges of Fuzzing Embedded Devices">Main Challenges of Fuzzing Embedded Devices</a><ul>
                            
                    <li>
                        <a href="#fault-detection" aria-label="Fault detection">Fault detection</a></li>
                    <li>
                        <a href="#performance-and-scalability" aria-label="Performance and Scalability">Performance and Scalability</a></li>
                    <li>
                        <a href="#instrumentation" aria-label="Instrumentation">Instrumentation</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#memory-corruptions-in-embedded-systems" aria-label="MEMORY CORRUPTIONS IN EMBEDDED SYSTEMS">MEMORY CORRUPTIONS IN EMBEDDED SYSTEMS</a><ul>
                            
                    <li>
                        <a href="#bugs-faults-corruptions--crashes" aria-label="Bugs, Faults, Corruptions &amp;amp; Crashes">Bugs, Faults, Corruptions &amp; Crashes</a></li>
                    <li>
                        <a href="#experimental-setup" aria-label="Experimental Setup">Experimental Setup</a></li>
                    <li>
                        <a href="#atificial-vulnerabilities" aria-label="Atificial Vulnerabilities">Atificial Vulnerabilities</a></li>
                    <li>
                        <a href="#observed-behavior" aria-label="Observed Behavior">Observed Behavior</a></li></ul>
                    </li>
                    <li>
                        <a href="#mitigations" aria-label="MITIGATIONS">MITIGATIONS</a><ul>
                            
                    <li>
                        <a href="#static-instrumentation" aria-label="Static Instrumentation.">Static Instrumentation.</a></li>
                    <li>
                        <a href="#binary-rewriting" aria-label="Binary Rewriting">Binary Rewriting</a></li>
                    <li>
                        <a href="#physical-re-hosting" aria-label="Physical Re-Hosting">Physical Re-Hosting</a></li>
                    <li>
                        <a href="#full-emulation" aria-label="Full Emulation">Full Emulation</a></li>
                    <li>
                        <a href="#partial-emulation" aria-label="Partial Emulation">Partial Emulation</a></li>
                    <li>
                        <a href="#hardware-supported-instrumentation" aria-label="Hardware-Supported Instrumentation">Hardware-Supported Instrumentation</a></li>
                    <li>
                        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                    </li>
                    <li>
                        <a href="#fault-detection-heuristics%e6%95%85%e9%9a%9c%e6%a3%80%e6%b5%8b%e5%90%af%e5%8f%91%e5%bc%8f" aria-label="FAULT DETECTION HEURISTICS（故障检测启发式）">FAULT DETECTION HEURISTICS（故障检测启发式）</a><ul>
                            
                    <li>
                        <a href="#segment-tracking" aria-label="Segment Tracking">Segment Tracking</a></li>
                    <li>
                        <a href="#format-specifier-tracking" aria-label="Format Specifier Tracking">Format Specifier Tracking</a></li>
                    <li>
                        <a href="#heap-object-tracking" aria-label="Heap Object Tracking">Heap Object Tracking</a></li>
                    <li>
                        <a href="#call-stack-tracking" aria-label="Call Stack Tracking">Call Stack Tracking</a></li>
                    <li>
                        <a href="#call-frame-tracking" aria-label="Call Frame Tracking">Call Frame Tracking</a></li>
                    <li>
                        <a href="#stack-object-tracking" aria-label="Stack Object Tracking">Stack Object Tracking</a></li></ul>
                    </li>
                    <li>
                        <a href="#implementation" aria-label="IMPLEMENTATION">IMPLEMENTATION</a></li>
                    <li>
                        <a href="#experiments" aria-label="EXPERIMENTS">EXPERIMENTS</a><ul>
                            
                    <li>
                        <a href="#%e7%9b%ae%e6%a0%87%e8%ae%be%e7%bd%ae" aria-label="目标设置">目标设置</a></li>
                    <li>
                        <a href="#fuzzing-setup" aria-label="Fuzzing Setup">Fuzzing Setup</a></li>
                    <li>
                        <a href="#result" aria-label="Result">Result</a><ul>
                            
                    <li>
                        <a href="#fault-detection-1" aria-label="Fault Detection">Fault Detection</a></li>
                    <li>
                        <a href="#%e6%80%a7%e8%83%bd" aria-label="性能">性能</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#discussion" aria-label="DISCUSSION">DISCUSSION</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>你破坏的不是你破坏的: Fuzzing 嵌入式设备的挑战
作者：Marius Muench
单位：巴黎高等电信学院
国家： #法国
年份： #2018年
来源： #NDSS会议
关键字： #嵌入式 #综述
[[What You Corrupt Is Not What You Crash_ Challenges in Fuzzing Embedded Devices.pdf]]</p>
<h1 id="abstract">Abstract<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h1>
<ul>
<li>传统的测试方法依赖于程序中看的见的崩溃, 而二进制插装技术是用来改善针对这些缺陷状态的检测方法</li>
<li>演示了 memory corruption 漏洞，展示 embedded devices 和 desktop systems 的不同</li>
<li>分析了几种 embedded devices 设备的差异</li>
</ul>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<ul>
<li>Memory corruption 导致的漏洞普遍存在，模糊测试是发现这些漏洞最流行的技术之一，适合<strong>大规模自动化</strong></li>
<li>因为 embedded devices 的有限的 I/O 和计算能力，受限的成本，其上没有大部分 desktop systems 拥有的防御机制，所以发生内存损坏的概率更高</li>
<li>但是 embedded devices 存在缺少源码，识别 memory corruption 的传统方法不适用于的问题。</li>
<li>本文首次全面分析了内存损坏对不同类别的嵌入式系统的影响，并且提出的技术可以 100%检测到在模糊过程中触发的内存损坏状态</li>
</ul>
<h1 id="fuzzing-embedded-systems">FUZZING EMBEDDED SYSTEMS<a hidden class="anchor" aria-hidden="true" href="#fuzzing-embedded-systems">#</a></h1>
<p>首先介绍将在本文其余部分使用的嵌入式系统的分类。然后，我们讨论了之前将模糊测试应用于不同嵌入式设备的实验，最后我们提出了在该领域应用模糊测试所遇到的挑战。</p>
<h2 id="classes-of-embedded-devices">Classes of Embedded Devices<a hidden class="anchor" aria-hidden="true" href="#classes-of-embedded-devices">#</a></h2>
<p>将嵌入式设备分为以下三类</p>
<ul>
<li>基于 OS 的通用设备：此类设备搭载了被改装为嵌入式设备操作系统的桌面级系统。（例如，Linux 操作系统内核广泛用于嵌入式领域，通常与轻量级用户空间环境（例如 busybox 和 uClibc）结合使用。）</li>
<li>基于嵌入式操作系统的设备：此类设备搭载了为嵌入式设备定制的操作系统，内核和应用程序代码之间的逻辑分离仍然存在。（例如 uClinux、ZephyrOS 和 VxWorks）</li>
<li>没有操作系统抽象的设备：此类设备采用所谓的“单片固件”，其操作通常基于单个控制环路和从外围设备触发的中断，以处理来自外部世界的事件。固件将包含编译的系统和应用程序代码在一起，形成了一个单一的软件。（单体方法可以在各种硬件组件控制器中找到，例如 CD 读取器、WiFi 卡或 GPS 加密狗。在这些设备上运行的代码可以是完全自定义的，也可以基于操作系统库，如 Contiki、TinyOS 或 mbed OS 22。）</li>
</ul>
<h2 id="past-experiments">Past Experiments<a hidden class="anchor" aria-hidden="true" href="#past-experiments">#</a></h2>
<p>下表展示了近几年来针对嵌入式设备 fuzzing 的论文
<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230119193610.png" alt="image.png"  />
 ^eea5b5</p>
<h2 id="main-challenges-of-fuzzing-embedded-devices">Main Challenges of Fuzzing Embedded Devices<a hidden class="anchor" aria-hidden="true" href="#main-challenges-of-fuzzing-embedded-devices">#</a></h2>
<h3 id="fault-detection">Fault detection<a hidden class="anchor" aria-hidden="true" href="#fault-detection">#</a></h3>
<ul>
<li>作者认为模糊测试可以通过检测程序是否崩溃来判断输入是否触发漏洞，而桌面系统存在各种防御机制来检测恶意输入从而产生崩溃，但是嵌入式设备的操作系统没有各种各样的防御机制，所以很有可能触发漏洞但是没有产生崩溃，这种情况 fuzzing 器检测不到。</li>
<li>对于嵌入式设备可以检测到的崩溃，可能因为缺少输出错误信息的 I/O 功能，而导致 fuzzing 器监测不到</li>
<li>作者给出的解决方案是部署复杂的活性探测
<ul>
<li>主动探测：将特殊请求插入到与设备或其环境的通信中</li>
<li>被动探测：旨在检索有关设备状态的信息而不改变它。</li>
</ul>
</li>
</ul>
<h3 id="performance-and-scalability">Performance and Scalability<a hidden class="anchor" aria-hidden="true" href="#performance-and-scalability">#</a></h3>
<ul>
<li>嵌入式设备的 fuzzing 难以并行化</li>
<li>每轮 fuzzing （为了清空状态）重启设备拖慢测试过程</li>
</ul>
<h3 id="instrumentation">Instrumentation<a hidden class="anchor" aria-hidden="true" href="#instrumentation">#</a></h3>
<ul>
<li>嵌入式设备很难进行编译时检测和运行时检测来收集覆盖信息，或者通过别的一些什么技术来收集有关被测系统状态的信息。因为对于嵌入式设备而言，测试对象往往是固件映像，现有的工具不适用，不需要访问应用程序源代码的常见解决方案是求助于二进制动态检测框架。</li>
<li>但是作者最后指出上述所有静态和动态检测工具都与目标操作系统和 CPU 体系结构紧密相关，并且在撰写本文时，它们都不提供对 Type-II 和 Type-III 嵌入式设备的支持。</li>
</ul>
<h1 id="memory-corruptions-in-embedded-systems">MEMORY CORRUPTIONS IN EMBEDDED SYSTEMS<a hidden class="anchor" aria-hidden="true" href="#memory-corruptions-in-embedded-systems">#</a></h1>
<h2 id="bugs-faults-corruptions--crashes">Bugs, Faults, Corruptions &amp; Crashes<a hidden class="anchor" aria-hidden="true" href="#bugs-faults-corruptions--crashes">#</a></h2>
<ul>
<li>Van der Veen 等人区分了空间记忆错误和时间记忆错误。第一种类型表示对内存对象的越界访问，第二种类型表示对不再存在的内存对象的访问</li>
<li>有的内存损坏不会立即引起系统崩溃，作者称之为静默崩溃。
<ul>
<li>静默内存损坏的重要后果是，实际故障可能只会在稍后请求特定功能或接收到特定事件序列时才会变得明显。</li>
</ul>
</li>
<li>桌面系统因为有多种防御机制，所以更容易触发这种静默内存损坏，但是对于嵌入式设备缺乏防御机制，很难检测到静默内存损坏</li>
</ul>
<h2 id="experimental-setup">Experimental Setup<a hidden class="anchor" aria-hidden="true" href="#experimental-setup">#</a></h2>
<p>在不同的系统上触发相同的内存损坏条件，以分析它们是否屈服于可观察到的崩溃或导致静默损坏。</p>
<ul>
<li>设备选择：选择了现有的商用现成 (COTS) 产品：代表 Type-I 系统的路由器和代表 Type-II 设备的 IP 摄像机。</li>
<li>漏洞程序部署：对于 I II 型设备，直接编译漏洞程序然后加载到设备上便可，对于 III 型设备需要将测试代码包含在固件中然后对其编译，然后将固件加载到设备上。</li>
</ul>
<h2 id="atificial-vulnerabilities">Atificial Vulnerabilities<a hidden class="anchor" aria-hidden="true" href="#atificial-vulnerabilities">#</a></h2>
<ul>
<li>使用基于堆栈的缓冲区溢出和基于堆的缓冲区溢出作为空间内存损坏的示例，并使用空指针取消引用和双重释放漏洞作为时间内存损坏的示例。</li>
<li>还插入了一个格式字符串漏洞，可以用于信息泄漏或任意内存损坏。</li>
</ul>
<h2 id="observed-behavior">Observed Behavior<a hidden class="anchor" aria-hidden="true" href="#observed-behavior">#</a></h2>
<ul>
<li>桌面系统每次都可以触发崩溃</li>
<li>嵌入式设备并不总是能够检测到故障，在某些情况下，它们甚至继续执行而没有明显的影响——尽管系统的底层内存已损坏。观测到以下六种状态
<ul>
<li>R1：可以观测到的崩溃</li>
<li>R2：设备重启
<ul>
<li>R1 和 R2 对于 fuzzing 器来说是可以检测到的，是最好的结果</li>
</ul>
</li>
<li>R3：挂起：目标挂起并停止响应新请求，可能陷入死循环</li>
<li>R4：随后崩溃：目标系统继续执行一段不可忽视的时间后崩溃
<ul>
<li>挂起和后期崩溃（R3 和 R4）可能更难处理，特别是当崩溃延迟足够长以至于模糊器可能已经向目标系统发送了多个其他输入并且因此导致损坏的输入将是难以识别。</li>
</ul>
</li>
<li>R5：故障：系统没有崩溃，但是报告了错误的数据和不正常的结果
<ul>
<li>为了检测这种情况，模糊器需要知道正确的输出是什么，一种可能的变通方法包括在两个连续的输入之间插入一些输出已知的功能测试请求。然而，即使这个解决方案足以检测到故障，它也会在模糊测试中引入相当大的延迟。</li>
</ul>
</li>
<li>R6：无影响：尽管内存已损坏，目标仍然正常运行，没有明显的副作用。
<ul>
<li>这种最难检测
<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230120113810.png" alt="image.png"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="mitigations">MITIGATIONS<a hidden class="anchor" aria-hidden="true" href="#mitigations">#</a></h1>
<h2 id="static-instrumentation">Static Instrumentation.<a hidden class="anchor" aria-hidden="true" href="#static-instrumentation">#</a></h2>
<ul>
<li>前提是需要源代码和编译工具链</li>
<li>典型的 instrumentation 包括多种技术的组合：收集执行轨迹以测量覆盖率以改变模糊输入，添加内存分配检查，或使用例如控制流完整性来强化程序。不幸的是，这些工具中的大多数还不能用于嵌入式系统。</li>
</ul>
<h2 id="binary-rewriting">Binary Rewriting<a hidden class="anchor" aria-hidden="true" href="#binary-rewriting">#</a></h2>
<ul>
<li>前提要有二进制固件镜像，设备</li>
<li>反汇编固件的二进制镜像，恢复内存语义、边界和数据结构具有挑战性，其次嵌入式设备的内存使用经常被优化来降低成本，几乎没有留给添加复杂 instrumentation 的空间。</li>
</ul>
<h2 id="physical-re-hosting">Physical Re-Hosting<a hidden class="anchor" aria-hidden="true" href="#physical-re-hosting">#</a></h2>
<ul>
<li>前提需要源代码，编译链，不同的设备</li>
<li>某些情况下，可以将 II 型设备的系统重新编译到更易于检测的 I 型设备上，或者 I 型设备编译到桌面系统上</li>
<li>除了先决条件难以实现外，在不同设备上重现原设备上的漏洞也具有挑战性，由于不同的体系结构或者重新编译引入的更改可能会让原有的漏洞不再出现。</li>
</ul>
<h2 id="full-emulation">Full Emulation<a hidden class="anchor" aria-hidden="true" href="#full-emulation">#</a></h2>
<ul>
<li>前提要有固件镜像，外设模拟器</li>
<li>在某些情况下，从 Type-I 固件中提取的应用程序可以虚拟地重新托管，即，它们可以在默认模拟器上运行的通用操作系统中执行。</li>
<li>扩展 Qemu 以模拟 STM32 芯片的 Qemu STM32 项目表明，当完整的硬件文档可用时，通过相当大的努力来实现硬件模拟，也可以完全模拟 Type-III 固件映像。</li>
<li>这个解决方案可以大大改善模糊。首先，测试实验可以在没有物理设备的情况下进行，因此可以实现更大的并行化。其次，动态检测技术可以很容易地应用，仿真器可以用来收集大量关于运行固件的信息。</li>
<li>这种解决方案的缺点是，它只适用于目标所访问的所有外设都是已知的并且可以成功模拟的情况，不幸的是，这种情况很少发生。总的来说，能够在模拟器中运行任意固件仍然是一个开放的研究问题。</li>
</ul>
<h2 id="partial-emulation">Partial Emulation<a hidden class="anchor" aria-hidden="true" href="#partial-emulation">#</a></h2>
<ul>
<li>前提需要固件映像、设备</li>
<li>这种方法首先由 Avatar[54]和 Surrogates[28]提出用于 Type-III 设备，然后在 PROSPECT[24]，[25]中扩展到 Type-I 系统。此解决方案背后的一般思想是<strong>使用经过修改的模拟器 (其中执行固件代码) 将外围交互转发到实际的物理设备</strong>。其结果提供了完全模拟解决方案的优点，而无需了解和模拟 I/O 操作。然而，此解决方案在灵活性方面所获得的好处是牺牲了性能 (由于与实际设备的额外交互) 和可伸缩性 (由于当前需要将每个模拟实例与物理设备配对)。</li>
</ul>
<h2 id="hardware-supported-instrumentation">Hardware-Supported Instrumentation<a hidden class="anchor" aria-hidden="true" href="#hardware-supported-instrumentation">#</a></h2>
<ul>
<li>前提需要设备，高级调试功能 (例如，跟踪调试端口和调试器)</li>
<li>如果测试人员可以访问具有先进硬件检测机制 (如实时跟踪) 的物理设备，则可能收集足够的信息来改进设备执行期间的故障检测。例如，芯片制造商通常嵌入硬件跟踪功能，如 ARM 的嵌入式跟踪 Macrocell (ETM) 和 Coresight 调试和跟踪，或英特尔的处理器跟踪 (PT) 技术。不幸的是，这种跟踪硬件的可用性是可变的。在低端设备 (通常是 iii 型设备) 中，制造商往往不包括任何跟踪功能，因为这种机制会对芯片表面产生相对较大的影响，因此对成本也会产生影响。开发设备可能有这样的设施 (有时在制造之前在 FPGA 上测试微控制器设计)，但这在商业生产设备中不太常见。最后，在某些情况下，调试访问可能存在，但不可用，以防止第三方分析。</li>
<li>在测试真实设备时，找到可用的硬件跟踪支持的可能性非常低。</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ul>
<li>方案 ABC 要求测试人员修改固件镜像，但是因为种种困难，在执行第三方安全测试时，这很少是一个选项。</li>
<li>方案 DEF 不需要修改固件镜像，但是需要额外的技术 (软件模拟器或硬件跟踪支持) 来收集有关正在运行的固件的信息。</li>
</ul>
<h1 id="fault-detection-heuristics故障检测启发式">FAULT DETECTION HEURISTICS（故障检测启发式）<a hidden class="anchor" aria-hidden="true" href="#fault-detection-heuristics故障检测启发式">#</a></h1>
<p>这些启发式算法是独立于实现的，这样不仅可以在实时分析设置中工作 (就像固件在模拟器中运行时那样)，而且还可以对以前收集的执行跟踪进行“事后分析”(就像在基于硬件的跟踪机制中那样)。</p>
<h2 id="segment-tracking">Segment Tracking<a hidden class="anchor" aria-hidden="true" href="#segment-tracking">#</a></h2>
<p>段跟踪可能是旨在检测非法内存访问的最简单技术。核心思想是观察所有内存读写并验证它们是否发生在有效位置，从而以某种方式模仿 MMU 检测分段错误。这种技术只需要了解目标的内存访问和内存映射。两者都可以在模拟器中轻松访问，但是，当只有跟踪可用时，可以通过逆向工程获得内存映射。</p>
<h2 id="format-specifier-tracking">Format Specifier Tracking<a hidden class="anchor" aria-hidden="true" href="#format-specifier-tracking">#</a></h2>
<p>本质上，此保护验证格式字符串说明符在进入 printf () 系列函数时指向有效位置。在最简单的情况下，如果不存在动态生成的格式字符串说明符，那些有效位置必须位于只读段内。总而言之，这项技术不仅需要了解格式处理函数的位置，还需要了解输入其中一个函数时的寄存器状态和参数顺序。相应函数的位置及其参数顺序都可以通过逆向工程或固件的自动静态分析获得。</p>
<h2 id="heap-object-tracking">Heap Object Tracking<a hidden class="anchor" aria-hidden="true" href="#heap-object-tracking">#</a></h2>
<p>该技术旨在检测与时间和空间堆相关的错误，并受到 [43] 中介绍的检测和运行时验证方法的影响。它通过评估分配和释放函数的参数和返回值以及记录堆对象的位置和大小来实现其目标。这允许轻松检测越界内存访问或对已释放对象的访问。然而，这种启发式方法取决于多种信息：已执行的指令、寄存器的状态、内存访问以及有关分配和释放函数的知识。后者可以通过逆向工程或通过使用高级方法来发现自定义分配器来检索，如 MemBrush 所展示的。</p>
<h2 id="call-stack-tracking">Call Stack Tracking<a hidden class="anchor" aria-hidden="true" href="#call-stack-tracking">#</a></h2>
<p>调用堆栈跟踪正在复制传统的影子堆栈保护 [53]，因此旨在检测不返回被调用者的函数。这有助于识别覆盖函数返回地址的基于堆栈的内存损坏。它通过监视所有直接和间接函数调用和返回指令来实现。然而，由于嵌入式设备通常是中断驱动的，这种试探法可能会导致漏报。但是它需要最少的信息：只需要执行指令的知识。</p>
<h2 id="call-frame-tracking">Call Frame Tracking<a hidden class="anchor" aria-hidden="true" href="#call-frame-tracking">#</a></h2>
<p>调用帧跟踪是调用堆栈跟踪技术的更高级版本，它可以在发生时检测粗粒度的基于堆栈的缓冲区溢出，而不会出现漏报。本质上，堆栈帧是通过跟踪函数调用来定位的，然后检查连续的内存访问是否跨越堆栈帧。因此，这需要识别执行的指令以及寄存器值，以在函数入口时提取堆栈指针值。然后，必须观察内存访问以检测实际损坏。</p>
<h2 id="stack-object-tracking">Stack Object Tracking<a hidden class="anchor" aria-hidden="true" href="#stack-object-tracking">#</a></h2>
<p>堆栈对象跟踪包括对堆栈变量越界访问的细粒度检测，这是受 Serebryany 等人提出的堆对象跟踪方法的启发。 [43]。因此，根据堆栈中的各个变量大小和位置检查执行期间观察到的内存读取和写入。显然，这需要跟踪执行的指令和内存访问，以及有关堆栈变量的详尽信息。为了简单起见，我们使用调试符号中存在的变量信息。然而，在一般情况下，可以从二进制代码中以自动方式检索此类信息，正如之前的几项研究 [22]、[47] 所提出的那样。
<img loading="lazy" src="https://gitee.com/juhuahua/chart-bed/raw/master/20230120161324.png" alt="image.png"  />
</p>
<h1 id="implementation">IMPLEMENTATION<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h1>
<ul>
<li>作者基于 PANDA (动态分析平台) 和 Avatar (用于嵌入式设备动态分析的编排框架)，编写了程序，并将其<a href="https://github.com/avatartwo/ndss18_wycinwyc">开源</a></li>
<li>总之，我们使用 PANDA 来模拟固件，并依赖其插件系统来获得部分或完全模拟固件执行时的实时反馈。所有这一切都由 Avatar 编排执行，并有选择地将执行和内存访问重定向到物理设备。</li>
<li>Avatar 还提供了保存快照的功能。</li>
</ul>
<h1 id="experiments">EXPERIMENTS<a hidden class="anchor" aria-hidden="true" href="#experiments">#</a></h1>
<p>目的：</p>
<ul>
<li>将启发式方法集成到工具中</li>
<li>测量方法带来的系统开销</li>
</ul>
<h2 id="目标设置">目标设置<a hidden class="anchor" aria-hidden="true" href="#目标设置">#</a></h2>
<p>四种实验设置：</p>
<ul>
<li>NAT不添加任何启发式方法的模糊测试，作为基准</li>
<li>PE/MF带有内存转发的部分仿真：将 I/O 操作转发到实际设备</li>
<li>PE/PM具有外围建模的部分仿真：固件是模拟的，外围设备交互是通过使用 Avatar 内部的专用脚本模拟外围设备行为来处理的，这允许在没有物理设备存在的情况下进行实验。</li>
<li>FE完全仿真：固件及其外围设备都在 PANDA 中完全模拟。</li>
</ul>
<h2 id="fuzzing-setup">Fuzzing Setup<a hidden class="anchor" aria-hidden="true" href="#fuzzing-setup">#</a></h2>
<ul>
<li>基于 boofuzz 构建实验</li>
<li>使用 fuzzer 强制生成输入这些输入将以给定的概率触发插入的内存损坏漏洞之一。</li>
<li>添加了一个监视器（活性检查 liveness checks）：在每次模糊输入之后，模糊器接收设备的响应并评估它是否符合预期的行为。当收到的响应与预期的不同时，或者当连接超时时，模糊器报告崩溃并重新启动目标。
<ul>
<li>这个监视器是为了检测启发式方法没有检测到的崩溃，从而评估启发式方法的有效性</li>
</ul>
</li>
</ul>
<h2 id="result">Result<a hidden class="anchor" aria-hidden="true" href="#result">#</a></h2>
<ul>
<li>目标处理的输入数量 (Itot)、损坏输入被发送到目标的次数 (IC)、活性检查 (DL) 检测到的故障数量以及故障数量由启发式 (DH) 检测到。此外，我们将未检测到的故障数表示为 (DU)。</li>
<li>$I_C =D_L+D_H+D_U\approx I_{tot}*P_C$</li>
</ul>
<h3 id="fault-detection-1">Fault Detection<a hidden class="anchor" aria-hidden="true" href="#fault-detection-1">#</a></h3>
<p>实验结果表明启发式方法确实产生了更多的崩溃，从而提高了 fuzz 的效率</p>
<h3 id="性能">性能<a hidden class="anchor" aria-hidden="true" href="#性能">#</a></h3>
<ul>
<li>具有内存转发 (PE/MF) 的部分仿真正在使模糊测试减慢一个数量级以上。这种开销是由固件和设备外围设备之间的通信引入的。这种开销的主要部分是由于 Avatar 和物理设备之间的低带宽连接，它依赖于通过 USB 连接的标准 JTAG 调试器。 Surrogates [28] 已经表明，这个问题可以通过使用专用硬件来解决，这将能够以接近实时的速度进行部分仿真。</li>
<li>观察单个启发式，我们可以观察到它们在 PE/MF 场景中的开销可以忽略不计，其中 MMIO 请求的转发瓶颈完全决定了模糊实验的速度。然而，在 PE/PM 和 FE 场景中，我们可以观察到 PC = 0 的启发式分析代码带来了相当大的放缓 (在 x1.5 到 x6 之间)。</li>
<li>另一个重要的观察结果是，只要检测到的损坏量较低，针对完全模拟目标的模糊处理速度明显快于针对物理设备的模糊处理。这主要是由于三个因素。首先，TCP 上的通信比串行端口上的通信允许更高的吞吐量。第二，即使固件是仿真的，仿真器通常比 (低资源) 嵌入式设备具有更高的时钟速度。第三，检测到的损坏与强制重新启动目标有关，这意味着高容量的 pc 会导致花费大量时间重新启动，而不是向目标发送新的输入。</li>
<li>然而，我们实验中最重要的结果是，在启用组合启发式的 PANDA (完全仿真) 中执行的固件在 PC 的实际值下可以比原始嵌入式设备更快地模糊化。虽然第一种方法可以检测到我们在其代码中插入的所有类型的漏洞，但第二种方法需要依赖于只能识别其中两种漏洞的活动检查。</li>
</ul>
<h1 id="discussion">DISCUSSION<a hidden class="anchor" aria-hidden="true" href="#discussion">#</a></h1>
<ul>
<li>仅仅依靠活性测试是一个糟糕的策略。仅依靠活跃度测试进行故障检测来模糊嵌入式系统是一种很可能遗漏许多漏洞的糟糕策略。同样，一次只使用一个启发式方法并不能保证检测到更多的漏洞。直观地说，通过结合几种启发式方法可以达到腐败检测的最高潜力。</li>
<li>完全仿真模拟器很少</li>
<li>部分仿真速度慢——一个数量级</li>
<li>这项工作也适用于嵌入式设备固件上的二进制符号执行。如果没有及时检测到损坏，符号执行可能会花费大量时间来计算无用状态。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://juhuax.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://juhuax.github.io/posts/study/2.%E5%88%B7%E9%A2%98/ctf/pwn/unsortedbin-attack/">
    <span class="title">« Prev</span>
    <br>
    <span>unsortedbin attack</span>
  </a>
  <a class="next" href="https://juhuax.github.io/posts/study/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/what-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/">
    <span class="title">Next »</span>
    <br>
    <span>What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices 总结笔记</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on twitter"
        href="https://twitter.com/intent/tweet/?text=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f&amp;title=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices&amp;summary=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices&amp;source=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f&title=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on whatsapp"
        href="https://api.whatsapp.com/send?text=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices%20-%20https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share What You Corrupt Is Not What You Crash Challenges in Fuzzing Embedded Devices on telegram"
        href="https://telegram.me/share/url?text=What%20You%20Corrupt%20Is%20Not%20What%20You%20Crash%20Challenges%20in%20Fuzzing%20Embedded%20Devices&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2fstudy%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fwhat-you-corrupt-is-not-what-you-crash-challenges-in-fuzzing-embedded-devices%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>JUHUA</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
