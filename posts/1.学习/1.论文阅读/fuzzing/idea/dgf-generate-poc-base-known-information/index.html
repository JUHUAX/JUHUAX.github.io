<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DGF generate POC base known information - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="论文 CCS 17 [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]（中国人民大学游伟老师，也是一直有在做 fuzz） 思考一下如何推广到任意的二进制程序 他是如何将提取的漏洞信息通知 fuzzer 的 ![[SemFuzz 总结笔记#what can i improve]] [[Extractor_ Extracting Attack Behavior from Threat Reports]] 威胁报告中提取攻击行为 这篇论文的工作看起来是做的相当完善了 开源 突然想起来师姐的论文也有 cve 提取，看看师姐论文 [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]这个不知道有没有用，也是游伟老师团队的，还没下载 利用 word2vec &#43; cnn 识别 log 中的目标信息，然后用这些目标信息来变异 没有开源代码，想知道它是怎么去指导变异的 [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]] 亮点在于对输入格式的探测 没有开源 [[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]] 会议没听说过，可能会有点水 利用Word2Vec&#43;LSTM构成的NRE模型实现对CVE description中每个单词的分类，分为software name和software version 使用作者总结的规则来判断SV和SN对 代码没开源 [[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]] 和上面那篇差不多，利用神经网络提取CVE报告中的software name和software version 但是使用的网络结构不同，这篇的网络结构比较复杂，使用了NER和RE模型 NER用于识别SN和SV，RE用于判断哪两个SN和SV是一对 代码开源 EVIL: Exploiting Software via Natural Language 可能相关一篇 B 类 用seq2seq和codeBert模型将自然语言翻译为代码 但是自然语言需要及其详细 Unleashing Coveraged-Based Fuzzing Through Comprehensive, Efficient, and Faithful Exploitable-Bug Exposing A 类期刊关于定向 fuzz Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction 增量混合 Chainsaw: Chained Automated Workflow-based Exploit Generation 自动生成 web 应用程序的漏洞利用，可能会有点启发 CRAXweb: Automatic Web Application Testing and Attack Generation 同上 Automatic Exploit Generation - 知乎 (zhihu." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="DGF generate POC base known information" />
<meta property="og:description" content="论文 CCS 17 [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]（中国人民大学游伟老师，也是一直有在做 fuzz） 思考一下如何推广到任意的二进制程序 他是如何将提取的漏洞信息通知 fuzzer 的 ![[SemFuzz 总结笔记#what can i improve]] [[Extractor_ Extracting Attack Behavior from Threat Reports]] 威胁报告中提取攻击行为 这篇论文的工作看起来是做的相当完善了 开源 突然想起来师姐的论文也有 cve 提取，看看师姐论文 [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]这个不知道有没有用，也是游伟老师团队的，还没下载 利用 word2vec &#43; cnn 识别 log 中的目标信息，然后用这些目标信息来变异 没有开源代码，想知道它是怎么去指导变异的 [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]] 亮点在于对输入格式的探测 没有开源 [[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]] 会议没听说过，可能会有点水 利用Word2Vec&#43;LSTM构成的NRE模型实现对CVE description中每个单词的分类，分为software name和software version 使用作者总结的规则来判断SV和SN对 代码没开源 [[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]] 和上面那篇差不多，利用神经网络提取CVE报告中的software name和software version 但是使用的网络结构不同，这篇的网络结构比较复杂，使用了NER和RE模型 NER用于识别SN和SV，RE用于判断哪两个SN和SV是一对 代码开源 EVIL: Exploiting Software via Natural Language 可能相关一篇 B 类 用seq2seq和codeBert模型将自然语言翻译为代码 但是自然语言需要及其详细 Unleashing Coveraged-Based Fuzzing Through Comprehensive, Efficient, and Faithful Exploitable-Bug Exposing A 类期刊关于定向 fuzz Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction 增量混合 Chainsaw: Chained Automated Workflow-based Exploit Generation 自动生成 web 应用程序的漏洞利用，可能会有点启发 CRAXweb: Automatic Web Application Testing and Attack Generation 同上 Automatic Exploit Generation - 知乎 (zhihu." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/idea/dgf-generate-poc-base-known-information/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DGF generate POC base known information"/>
<meta name="twitter:description" content="论文 CCS 17 [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]（中国人民大学游伟老师，也是一直有在做 fuzz） 思考一下如何推广到任意的二进制程序 他是如何将提取的漏洞信息通知 fuzzer 的 ![[SemFuzz 总结笔记#what can i improve]] [[Extractor_ Extracting Attack Behavior from Threat Reports]] 威胁报告中提取攻击行为 这篇论文的工作看起来是做的相当完善了 开源 突然想起来师姐的论文也有 cve 提取，看看师姐论文 [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]这个不知道有没有用，也是游伟老师团队的，还没下载 利用 word2vec &#43; cnn 识别 log 中的目标信息，然后用这些目标信息来变异 没有开源代码，想知道它是怎么去指导变异的 [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]] 亮点在于对输入格式的探测 没有开源 [[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]] 会议没听说过，可能会有点水 利用Word2Vec&#43;LSTM构成的NRE模型实现对CVE description中每个单词的分类，分为software name和software version 使用作者总结的规则来判断SV和SN对 代码没开源 [[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]] 和上面那篇差不多，利用神经网络提取CVE报告中的software name和software version 但是使用的网络结构不同，这篇的网络结构比较复杂，使用了NER和RE模型 NER用于识别SN和SV，RE用于判断哪两个SN和SV是一对 代码开源 EVIL: Exploiting Software via Natural Language 可能相关一篇 B 类 用seq2seq和codeBert模型将自然语言翻译为代码 但是自然语言需要及其详细 Unleashing Coveraged-Based Fuzzing Through Comprehensive, Efficient, and Faithful Exploitable-Bug Exposing A 类期刊关于定向 fuzz Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction 增量混合 Chainsaw: Chained Automated Workflow-based Exploit Generation 自动生成 web 应用程序的漏洞利用，可能会有点启发 CRAXweb: Automatic Web Application Testing and Attack Generation 同上 Automatic Exploit Generation - 知乎 (zhihu."/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">DGF generate POC base known information</h1>
			<div class="meta">Posted on Jun 22, 2023</div>
		</div>
		

		<section class="body">
			<h2 id="论文">论文</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> CCS 17 [[SemFuzz Semantics-based Automatic Generation of Proof-of-Concept Exploits]]（中国人民大学游伟老师，也是一直有在做 fuzz）
<ul>
<li>思考一下如何推广到任意的二进制程序</li>
<li>他是如何将提取的漏洞信息通知 fuzzer 的</li>
<li>![[SemFuzz 总结笔记#what can i improve]]</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> [[Extractor_ Extracting Attack Behavior from Threat Reports]] 威胁报告中提取攻击行为
<ul>
<li>这篇论文的工作看起来是做的相当完善了</li>
<li>开源</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 突然想起来师姐的论文也有 cve 提取，看看师姐论文</li>
<li><input checked="" disabled="" type="checkbox"> [[Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing]]<del>这个不知道有没有用，也是游伟老师团队的，还没下载</del>
<ul>
<li>利用 word2vec + cnn 识别 log 中的目标信息，然后用这些目标信息来变异</li>
<li>没有开源代码，想知道它是怎么去指导变异的</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> [[ProFuzzer On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery]]
<ul>
<li>亮点在于对输入格式的探测</li>
<li>没有开源</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> [[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]]
<ul>
<li>会议没听说过，可能会有点水</li>
<li>利用Word2Vec+LSTM构成的NRE模型实现对CVE description中每个单词的分类，分为software name和software version</li>
<li>使用作者总结的规则来判断SV和SN对</li>
<li>代码没开源</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> [[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]]
<ul>
<li>和上面那篇差不多，利用神经网络提取CVE报告中的software name和software version</li>
<li>但是使用的网络结构不同，这篇的网络结构比较复杂，使用了NER和RE模型</li>
<li>NER用于识别SN和SV，RE用于判断哪两个SN和SV是一对</li>
<li>代码开源</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> EVIL: Exploiting Software via Natural Language 可能相关一篇 B 类
<ul>
<li>用seq2seq和codeBert模型将自然语言翻译为代码</li>
<li>但是自然语言需要及其详细</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Unleashing Coveraged-Based Fuzzing Through Comprehensive, Efficient, and Faithful Exploitable-Bug Exposing A 类期刊关于定向 fuzz</li>
<li><input disabled="" type="checkbox"> Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction 增量混合</li>
<li><input disabled="" type="checkbox"> Chainsaw: Chained Automated Workflow-based Exploit Generation 自动生成 web 应用程序的漏洞利用，可能会有点启发</li>
<li><input disabled="" type="checkbox"> CRAXweb: Automatic Web Application Testing and Attack Generation 同上
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/400226950">Automatic Exploit Generation - 知乎 (zhihu.com)</a> 自动漏洞利用</li>
<li><a href="https://www.anquanke.com/post/id/240026">漏洞自动化利用（AEG）研究进展-安全客 - 安全资讯平台 (anquanke.com)</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Revery: From Proof-of-Concept to Exploitable fuzz 的 AEG 文章</li>
<li><input disabled="" type="checkbox"> FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vulnerabilities fuzz 的 AEG 文章</li>
<li><input disabled="" type="checkbox"> KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities fuzz 的 AEG 文章</li>
<li><input disabled="" type="checkbox"> <a href="https://blog.csdn.net/u013648063/article/details/125627454#:~:text=%E3%80%90%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E3%80%91Fuzzing%3A%20A%20Survey%20for%20Roadmap%201%201.%20Introduction,Selection%20%E6%9C%80%E5%B0%8F%E5%8C%96%E7%A7%8D%E5%AD%90%E9%9B%86%E5%90%88%20%E9%81%BF%E5%85%8D%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E5%9C%A8%E5%B7%B2%E7%BB%8F%E6%8E%A2%E7%B4%A2%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E5%8C%BA%E5%9F%9F%20%E7%9C%8B%E4%BD%9C%E6%98%AFMSCP%E9%97%AE%E9%A2%98%EF%BC%88minimal%20set%20cover%20problem%EF%BC%89%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%8C%96%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%90%E9%9B%86%E3%80%82%20">(68条消息) 【论文分享】Fuzzing: A Survey for Roadmap_破落之实的博客-CSDN博客</a></li>
<li><input disabled="" type="checkbox"> <a href="https://cn.bing.com/search?q=Fuzzing%3A+a+survey+for+roadmap&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;lq=0&amp;pq=fuzzing%3A+a+survey+for+roadmap&amp;sc=3-29&amp;sk=&amp;cvid=26FD577A524E40E9B3669621EEAF85FF&amp;ghsh=0&amp;ghacc=0&amp;ghpl=">Fuzzing: a survey for roadmap - 搜索 (bing.com)</a></li>
<li><input disabled="" type="checkbox"> FuzzGuard</li>
<li><input disabled="" type="checkbox"> Savior</li>
<li><input disabled="" type="checkbox"> [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing]] 周末回看一下</li>
<li><input disabled="" type="checkbox"> <a href="https://www.cnblogs.com/mantch/p/12261599.html">HanLP《自然语言处理入门》笔记&ndash;1.新手上路 - mantch - 博客园 (cnblogs.com)</a></li>
</ul>
<hr>
<h2 id="整理">整理</h2>
<h3 id="提取信息">提取信息</h3>
<ul>
<li>[[Extractor_ Extracting Attack Behavior from Threat Reports]]
<ul>
<li><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230415153215.png" alt="image.png"></li>
<li>非常完善的一个方法了，输入是随便的文本，不要求文本格式，三个步骤后输出“系统主体 (例如，进程)、对象 (例如，文件、套接字)和操作 (例如，执行)”</li>
<li>最后一个步骤（图生成）可以不用</li>
<li>构建了数据集</li>
</ul>
</li>
<li>[[Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System]]</li>
<li>[[Towards the Detection of Inconsistencies in Public Security Vulnerability Reports]]
<ul>
<li>这篇文章要比上面那篇完善，A还是A</li>
</ul>
</li>
</ul>
<h3 id="定向fuzz">定向fuzz</h3>
<ul>
<li>[[SemFuzz 总结笔记]]
<ul>
<li>提取信息的部分比较简单，并且只针对Linux内核漏洞，可以进一步扩展</li>
<li>fuzz部分没有特别大的改进，只是使用提取的信息（漏洞函数，系统调用顺序）作为种子进行粗粒度和细粒度的变异</li>
</ul>
</li>
<li>[[BEACON Directed Grey-Box Fuzzing with Provable Path Pruning]]
<ul>
<li>我觉得这篇论文提出了一个很好的定向fuzz的方法，就是尽早的去修剪无用路径，而不是计算输入实例和漏洞路径的距离</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<p>关于 fuzz 自动生成 poc，分为三个部分：</p>
<ul>
<li>提取漏洞信息
<ul>
<li>考虑不同的漏洞库之间的信息差异</li>
<li>生成的信息是 fuzzer 可以识别的</li>
</ul>
</li>
<li>定向 fuzz</li>
</ul>
<p>写论文可能会用到</p>
<ul>
<li>意义（作用）
<ul>
<li>用于评定漏洞的可利用难度，从而确定漏洞的修复优先级。比如说比较深的漏洞可能较难利用，所以修复的优先级相对较低</li>
<li>还可以加一个漏洞的效果，效果危险，优先级高</li>
</ul>
</li>
</ul>
<h2 id="资料">资料</h2>
<ul>
<li>信息数据库：NVD、VulnDB、 IBM X-Force、VulnCode-DB、Exploit DB、Security Focus</li>
<li>CVE 数据集：Towards the detection of inconsistencies in public security vulnerability reports（这篇论文里面有整理好的数据集）</li>
</ul>
<h2 id="idea">idea</h2>
<p>![[ideal#^407193]]</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93">论文总结</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
