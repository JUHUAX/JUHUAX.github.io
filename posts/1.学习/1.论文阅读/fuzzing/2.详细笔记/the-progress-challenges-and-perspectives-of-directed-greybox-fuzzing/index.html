<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="定向灰盒模糊技术的进展、挑战与展望 作者：王鹏飞 单位：国防科技大学 国家： #中国 年份： #2021年 来源： #arxiv 关键字： #定向fuzzing #综述 总结笔记：[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记]] [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing.pdf]]
PUT program under test DSE directed symbolic execution 定向符号执行 Abstract 定向灰盒相对于普通灰盒测试更高效 定向灰盒适用于补丁测试，bug再现，特殊bug检测等场景 本文从更广泛的角度研究DGF，它不仅考虑了针对特定代码部分的位置导向类型，而且还考虑了旨在暴露异常程序行为的行为导向类型。通过分析DGF研究的好处和局限性，我们试图找出当前研究中的差距，同时，揭示新的研究机会，并提出进一步调查的领域。 Introuction Greybox fuzzing is widely used to test application software and libraries [5, 6], as well as kernel code [7–9] and protocols[10-12]. testing software by blindly extending code coverage is less e fficient Originally, directed fuzzers were based on symbolic execution[14-17]." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing" />
<meta property="og:description" content="定向灰盒模糊技术的进展、挑战与展望 作者：王鹏飞 单位：国防科技大学 国家： #中国 年份： #2021年 来源： #arxiv 关键字： #定向fuzzing #综述 总结笔记：[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记]] [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing.pdf]]
PUT program under test DSE directed symbolic execution 定向符号执行 Abstract 定向灰盒相对于普通灰盒测试更高效 定向灰盒适用于补丁测试，bug再现，特殊bug检测等场景 本文从更广泛的角度研究DGF，它不仅考虑了针对特定代码部分的位置导向类型，而且还考虑了旨在暴露异常程序行为的行为导向类型。通过分析DGF研究的好处和局限性，我们试图找出当前研究中的差距，同时，揭示新的研究机会，并提出进一步调查的领域。 Introuction Greybox fuzzing is widely used to test application software and libraries [5, 6], as well as kernel code [7–9] and protocols[10-12]. testing software by blindly extending code coverage is less e fficient Originally, directed fuzzers were based on symbolic execution[14-17]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing"/>
<meta name="twitter:description" content="定向灰盒模糊技术的进展、挑战与展望 作者：王鹏飞 单位：国防科技大学 国家： #中国 年份： #2021年 来源： #arxiv 关键字： #定向fuzzing #综述 总结笔记：[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记]] [[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing.pdf]]
PUT program under test DSE directed symbolic execution 定向符号执行 Abstract 定向灰盒相对于普通灰盒测试更高效 定向灰盒适用于补丁测试，bug再现，特殊bug检测等场景 本文从更广泛的角度研究DGF，它不仅考虑了针对特定代码部分的位置导向类型，而且还考虑了旨在暴露异常程序行为的行为导向类型。通过分析DGF研究的好处和局限性，我们试图找出当前研究中的差距，同时，揭示新的研究机会，并提出进一步调查的领域。 Introuction Greybox fuzzing is widely used to test application software and libraries [5, 6], as well as kernel code [7–9] and protocols[10-12]. testing software by blindly extending code coverage is less e fficient Originally, directed fuzzers were based on symbolic execution[14-17]."/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h1>
			<div class="meta">Posted on Jun 22, 2023</div>
		</div>
		

		<section class="body">
			<p>定向灰盒模糊技术的进展、挑战与展望
作者：王鹏飞
单位：国防科技大学
国家： #中国
年份： #2021年
来源： #arxiv
关键字： #定向fuzzing #综述
总结笔记：[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 总结笔记]]
[[The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing.pdf]]</p>
<ul>
<li>PUT  program under test</li>
<li>DSE directed symbolic execution 定向符号执行</li>
</ul>
<h2 id="abstract">Abstract</h2>
<ul>
<li>定向灰盒相对于普通灰盒测试更高效</li>
<li>定向灰盒适用于补丁测试，bug再现，特殊bug检测等场景</li>
<li>本文从更广泛的角度研究DGF，它不仅考虑了针对特定代码部分的<strong>位置导向</strong>类型，而且还考虑了旨在暴露异常程序行为的<strong>行为导向</strong>类型。通过分析DGF研究的好处和局限性，我们试图找出当前研究中的差距，同时，揭示新的研究机会，并提出进一步调查的领域。</li>
</ul>
<h2 id="introuction">Introuction</h2>
<ul>
<li>Greybox fuzzing is widely used to test application software and libraries [5, 6], as well as kernel code [7–9] and protocols[10-12].</li>
<li>testing software by blindly extending code coverage is less e fficient</li>
<li>Originally, directed fuzzers were based on symbolic execution[14-17].</li>
<li>In 2017, B ̈ohme et al. introduced the concept of directed greybox fuzzing (DGF) [18].此时的定向模糊是需要手动标记targets，并且是基于种子和targets距离来进行能量分配</li>
<li>New fitness metrics, such as trace similarity and vulnerability prediction models（路径相似性和漏洞预测模型）</li>
</ul>
<h2 id="background">Background</h2>
<h3 id="cgf">CGF</h3>
<ul>
<li>旨在最大限度地提高代码覆盖率以发现隐藏的错误</li>
<li>AFL偏向于触发新路径的种子，并给予它们比非偏好路径的优先权。与其他仪器化的模糊器相比，AFL的性能开销不大。</li>
<li>CGF的效率偏低，因为努力被浪费在非bug区域</li>
<li>代表工具AFL</li>
</ul>
<h3 id="白盒定向fuzzing">白盒定向fuzzing</h3>
<ul>
<li>代表工具：KLEE、KATCH、BugRedux</li>
<li>大多基于符号执行引擎实现</li>
<li>定向符号执行（DSE）使用程序分析和约束解算来生成输入，系统地、有效地探索可行路径的状态空间[15]。一旦确定了目标路径，就通过创建测试案例来探索路径约束的潜在解决方案。由于大多数路径实际上是不可行的，搜索通常通过寻找通往中间目标的可行路径来反复进行。</li>
<li>DSE的有效性是以效率为代价的。DSE的重量级程序分析和约束条件的解决是相当耗时的。</li>
</ul>
<h3 id="基于搜索的软件测试">基于搜索的软件测试</h3>
<ul>
<li>基于搜索的软件测试(SBST)将软件测试问题转化为计算搜索问题，可以使用元启发式搜索技术进行优化，如爬坡、模拟退火和遗传算法[44]。</li>
</ul>
<h3 id="dgf">DGF</h3>
<ul>
<li>与盲目增加路径覆盖率的CGF不同，DGF的目标是到达代码中预先识别的一组位置（可能是有缺陷的部分），并将大部分时间预算用于到达目标位置</li>
<li>在编译时，除了仪器化，AFLGo还计算输入和预定义目标之间的距离。该距离被计算为执行轨迹到目标基本块的平均权重。执行跟踪权重由程序的调用图和控制流图中的边的数量决定。然后，在运行时，AFLGo根据距离而不是新的路径覆盖对种子进行优先排序，并优先考虑在基本块级距离上更接近目标的种子。</li>
</ul>
<h2 id="methodology">Methodology</h2>
<h3 id="inclusion-and-exclusion-crieria作者认为dgf的定义">Inclusion and Exclusion Crieria（作者认为DGF的定义）</h3>
<ul>
<li>核心机制应当是灰盒模糊测试，关键步骤是种子优先级，能量调度，mutator调度</li>
<li>定向性应当体现在在关键步骤中对fitness metric的优化</li>
<li>fitness的目标是达到一个特定位置或触发程序的buggy行为</li>
</ul>
<h3 id="data-collection">Data collection</h3>
<p>从每篇论文中提取的数据将是：</p>
<ul>
<li>出版来源（即会议、期刊或预印本）和年份</li>
<li>fitness goal。达到什么样的目标站点（例如，易受攻击的功能）或暴露哪些目标bug？</li>
<li>在模糊测试的进化过程中使用的fitness metric。例如，到目标的距离。</li>
<li>如何识别或标记目标？例如，由深度学习模型预测的。</li>
<li>实施信息。该模糊器是基于什么工具实现的？该模糊器是开源的吗？</li>
<li>该工具是否支持二进制代码分析？</li>
<li>该工具是否支持内核分析？</li>
<li>该工具是否支持多目标搜索？</li>
<li>该工具是否支持多目标优化？</li>
<li>模糊处理中的哪些关键步骤被优化以实现定向性？即输入优化、种子优先级、功率调度、突变器调度和突变操作。</li>
<li>在优化过程中采用了哪些技术？即控制流分析、静态分析、数据流分析、机器学习、语义分析和符号执行。</li>
</ul>
<h3 id="data-analysis">Data Analysis</h3>
<ul>
<li>在最新的DGF研究中，目标识别方法是如何变化的？</li>
<li>除了距离之外，在DGF的最新发展中，是否有任何新的fitness metric？</li>
<li>最近的DGF工具是如何在模糊测试的关键步骤上进行优化的？</li>
<li>What are the challenges of the DGF research? Are there any potential solution？</li>
<li>DGF的典型应用是什么？如何为一个特定的应用场景选择一个DGF工具？</li>
<li>未来DGF研究的趋势是什么？</li>
</ul>
<h2 id="research-progress-on-directed-greybox-fuzzing">Research Progress on Directed Greybox Fuzzing</h2>
<h3 id="overview">overview</h3>
<ul>
<li>设计新的fitness（UAFuzz, UAFL,LOLLY, Berry, CAFL.）或者实现mutil-dimensional fiteness（AFL-HR, HDRFuzz, AFLPro）</li>
<li>机器学习给targets自动打标签 SUZZER, V-Fuzz, De-Fuzz, SemFuzz；利用其他信息来给target打标签  DrillerGo, TortoiseFuzz, AFLChrun, GREYHOUND,DeltaFuzz, 1DVUL, SAVIOR, HDR-Fuzz.</li>
<li>借助数据流分析和语义分析来生成合法的输入，借助符号执行来通过复杂的限制，TOFU,TIFF, SemFuzz, KCFuzz, 1DVUL, SAVIOR.</li>
<li>利用启发式算法的AFLChrun, LOLLY, GREYHOUND</li>
<li>过滤无效输入  FuzzGuard, BEACON</li>
<li>检测具体的 bug 类型 MemLock, SlowFuzz, PERFFUZZ, MDPERFFUZZ.</li>
</ul>
<p>局限性：费用扣除、等权度量偏差、勘探开发协调不灵活、源代码依赖、缺乏多目标优化、缺乏多目标协调等</p>
<h3 id="target-identification">Target Identification</h3>
<h4 id="target-locations">target locations</h4>
<ul>
<li>手动标注target location需要源码行号或者虚拟内存地址
<ul>
<li>辅助的元数据：git提交日志[19]中的代码变更，从bug跟踪[25]中提取的信息，CVE漏洞描述的语义[12,23,24]，或深度学习模型[27-29]，以帮助识别代码中的漏洞函数[23,24,27-29]，关键站点[71]，syntaxtoken[72]，完整性检查[30,73]，以及补丁相关分支[20,22]</li>
</ul>
</li>
<li>静态分析工具可以自动的找到潜在的目标区域，一般这种工具只适用于特定的语言</li>
<li>编译sanitiser工具注释潜在的bugs</li>
<li>二进制级别的比较识别补丁相关分支</li>
<li>深度学习方法在二进制程序和抽象语法树级别预测潜在的脆弱代码</li>
<li>攻击面识别组件也被用来识别targets</li>
</ul>
<h4 id="target-bugs">target bugs</h4>
<ul>
<li>利用target行为序列来识别漏洞</li>
<li>对于DGF类型的目标是特定的bug，不需要在PUT中标记目标，这意味着fuzzer可以自动识别并以进化的方式触发这些bug。</li>
</ul>
<h3 id="fitness-metrics">Fitness Metrics</h3>
<h4 id="distance">distance</h4>
<ul>
<li>这里提到的几篇论文可以看看</li>
<li>基于距离的方法的一个缺点是它只关注最短的距离，因此当有多个路径到达同一个目标时，可能会忽略较长的选项，从而导致差异</li>
<li>在计算基本块级别的距离时，需要花费相当多的时间</li>
</ul>
<h4 id="similarity">similarity</h4>
<ul>
<li>执行轨迹
<ul>
<li>hawkeye中首次提出，将基本块迹距离与覆盖函数相似度相结合，用于种子优先级和功率调度</li>
<li>Berry[77]同样是以执行轨迹的相似性作为衡量指标</li>
<li>相似度是某个度量的当前状态和目标状态之间的重叠程度，其中度量包括bug跟踪的长度，覆盖的位置、覆盖的操作或覆盖的函数的数量。</li>
</ul>
</li>
<li>操作序列（程序行为？）
<ul>
<li>UAFL[32]使用操作序列覆盖来指导测试用例的生成，以逐步覆盖可能触发释放后使用漏洞的操作序列。</li>
<li>UAFuzz[25]还使用一个序列感知的目标相似性度量来度量种子执行和目标释放后使用的错误跟踪之间的相似性。</li>
<li>SAVIOR[73]根据UBSan预测的标签覆盖[78]，优先考虑具有更高触发漏洞潜力的种子。</li>
<li>TortoiseFuzz[23]区分与敏感内存操作密切相关的边，并根据它们执行路径中的敏感边命中计数优先排序种子。</li>
</ul>
</li>
<li>总的来说这部分的论文就是测量种子路径或者行为和能够达到targets的输入的路径或行为之间的相似度，相似度越高的种子得到更多的能量。</li>
<li>和distance相比
<ul>
<li>基于相似性的度量比基于距离的替代方法更能处理多目标拟合。 ^dfb282</li>
<li>基于距离的度量计算开销大，基于相似度的度量可以从相对较高的级别提取，以提高整体效率。</li>
</ul>
</li>
</ul>
<h4 id="vulnerability-prediction-models">Vulnerability Prediction Models</h4>
<ul>
<li>利用基于深度学习的模型，可以预测函数的脆弱概率，并为脆弱函数中的每个基本块给出一个静态脆弱评分来衡量函数的脆弱概率。然后，对于每个输入，执行路径上所有基本块的静态脆弱得分之和被用作适应度得分，以优先考虑得分较高的输入[27,28]。</li>
<li>TAFL[76]提取PUT的语义度量，并使用静态语义度量来标记区域，包括敏感、复杂、深度和难以到达的区域，这些区域包含漏洞的概率更高，并加强了对这些区域的模糊处理。</li>
<li>Joffe[6]使用神经网络生成的崩溃可能性来指导模糊处理容易崩溃的执行。基于概率的度量可以将种子优先级与目标识别结合起来，在不依赖源代码的情况下将模糊定位指向潜在的脆弱位置。</li>
<li>深度学习的方法目前的一个主要缺点是精度在一定程度上受到限制。</li>
</ul>
<h4 id="other">other</h4>
<ul>
<li>W ustholzet al[68]使用在线静态前瞻分析来确定一个路径前缀，该路径前缀的所有后缀路径都不能到达目标位置。然后，通过战略性地调度模糊的能量来强调可能到达目标位置的路径前缀来启用定向模糊。</li>
<li>KCFuzz[71]将目标路径中的父节点定义为关键点，并使用关键点覆盖来指导模糊处理。</li>
<li>CAFL[84]旨在满足一系列约束(即目标站点和数据条件的组合)，而不是达到一组目标站点。它将约束的距离定义为一个给定的种子满足约束的程度，并按顺序优先考虑更好地满足约束的种子。</li>
<li>AFL-HR[81]和HDR-Fuzz[85]采用了一种面向漏洞的适应度度量，称为净空(headroom)，它表明测试输入在给定漏洞位置暴露难以显示的漏洞(例如，缓冲区或整数溢出)的密切程度。</li>
<li>PERFFUZZ[34]使用所有程序位置的执行计数的新最大值作为反馈来生成病态输入。为了系统地度量适应度，定制的适应度度量还同时考虑多个维度，包括基本代码覆盖率、块权重、状态转换数量、执行时间、异常计数等等[12,86]。</li>
<li>此外，非功能性属性，如内存使用[31]和机器人车辆的控制不稳定性[33]也可以用来指导模糊。</li>
</ul>
<h3 id="fuzzing-optimization">Fuzzing Optimization</h3>
<ul>
<li>71%依靠<strong>控制流分析</strong>来评价种子和确定对目标的<strong>可达性</strong></li>
<li>60%利用静态分析自动<strong>识别目标</strong>[73]，并从PUT中提取信息[67,68]</li>
<li>21%的人使用<strong>数据流分析</strong>(主要污染分析)来识别输入和关键程序变量之间的关系[20,87,88]或优化仿真器调度[32]</li>
<li>12%的人使用机器学习来<strong>预测易受攻击的代码</strong>[27]并<strong>过滤掉不可达的输入</strong>[89]</li>
<li>12%的人集成<strong>符号(concolic)执行</strong>来解决复杂的路径约束[20,24,73,77];</li>
<li>14%采用<strong>语义分析</strong>自动**识别脆弱目标[<strong>19,24,76]，学习输入字段语义进行优化。</strong></li>
</ul>
<h4 id="input-optimization">input optimization</h4>
<ul>
<li>好的seed input应该可以促使fuzzing进程靠近targets，并且提升稍后的变异进程的性能</li>
<li>AFLGO有91.7%的输入不能到达buggy code
<ul>
<li>可以用动态污点分析和语义信息来构建合法的输入</li>
</ul>
</li>
<li>FuzzGuard利用深度学习方法来预测和过滤输入</li>
<li>BEACON[90]使用轻量级静态分析剔除不可行的路径(即在运行时无法到达目标代码的路径</li>
</ul>
<h4 id="seed-prioritization">seed prioritization</h4>
<ul>
<li>DGF的核心是对最接近targets的种子(用于突变)进行优先排序
<ul>
<li>种子优先级的排序主要基于控制流分析</li>
</ul>
</li>
<li>基于距离的方法[18,20,25,30,67,69,70]从PUT的调用和控制流图中的边数计算到目标基本块的距离。</li>
<li>基于相似性的方法[23,25,32,77,83]将种子覆盖控制流图上目标边的能力作为评估种子的度量。</li>
<li>基于预测模型的方法[27,28]也依赖于有属性的控制流图(即使用数值向量来描述控制流图中的基本块，其中向量的每个维度表示基本块的特定属性的值)来表示二进制程序并提取用于深度学习的特征。</li>
<li>定向混合模糊[20,24,71,73,77]结合了DSE的精度和DGF的可伸缩性，以减轻它们各自的弱点。DGF可以对输入突变进行优先排序和调度，从而快速接近目标，而DSE可以通过解决复杂的路径约束来实现更深入的代码。</li>
</ul>
<h4 id="power-scheduling">power scheduling</h4>
<ul>
<li>定向灰盒大多采取的都是模拟退火算法，模拟退火算法有一定概率会采用比当前种子效果差的种子，这样可以跳出局部最优解，得到全局最优解。</li>
<li>AFLGo[18]是第一个使用模拟退火为基础的功率计划，逐步将更多的能量分配给更接近目标位置的种子，同时减少距离较远的种子的能量。</li>
<li>Hawkeye[67]在模拟退火中增加了优先级，允许更接近目标的种子先突变。</li>
<li>AFLChurn[22]提出了一种基于蚁群优化的字节级功率调度，可以将更多的能量分配给产生更多“有趣”输入的字节。</li>
<li>LOLLY[83]和Berry[83]优化了基于模拟退火的功率计划，并设置了温度阈值，以协调勘探和开发阶段的冷却计划。在探索阶段，cooling schedule对提供的种子进行随机突变，生成较多的newinput，而在开发阶段，cooling schedule 从序列覆盖率较高的种子中生成较多的newinput，这与传统的梯度下降算法相似[83]。</li>
<li>除了模拟退火，GREYHOUND[12]还采用了自定义分代粒子群算法，更适合于协议模型的非线性和随机行为。</li>
</ul>
<h4 id="mutator-scheduling">mutator scheduling</h4>
<ul>
<li>优化突变策略是改进定向模糊的可行方法。合理调度突变子可以提高种子突变的精度和速度，提高输入的方向性。</li>
<li>可行的方法是首先将突变子划分为粗粒度和细粒度[19,27,67,76]，然后根据实际模糊状态动态调整。粗粒度突变器用于在突变期间改变大量字节，以将执行移向“易受攻击的函数”，而细粒度突变器只涉及一些字节级的修改、插入或删除，以监控“关键变量”[19]</li>
<li>在实践中，突变子的调度由经验值控制[27,67]。Situ等人[76]给出了两个经验观察结果:(1)粗粒突变子在路径生长上优于细粒突变子;(2)与单个突变相比，多个突变的使用提供了更好的性能。</li>
</ul>
<h4 id="mutation-operations">mutation operations</h4>
<ul>
<li>数据流分析，如污点分析，可以反映突变在生成的输入中的影响，因此，它有助于优化突变操作和输入生成。</li>
<li>RDFuzz[69]利用扰动-检查方法从输入中识别和保护“距离敏感内容”，即关键内容，以保持输入与目标之间的距离，一旦改变，距离就会变大。在突变期间保护这些内容可以帮助更有效地接近目标代码位置。</li>
<li>UAFL[32]采用信息流分析来识别条件语句中输入与程序变量之间的关系。它将对目标语句值改变可能性越大的输入字节视为“信息流强度”越高的输入字节，并赋予其更高的突变可能性。信息流强度越高，该字节对变量值的影响越强。</li>
<li>SemFuzz[19]通过反向数据流分析跟踪关键变量所依赖的内核函数参数。</li>
<li>TIFF[88]通过基于类型的突变来推断输入类型，以增加触发内存损坏漏洞的概率。它利用内存中的数据结构识别来识别应用程序使用的每个内存地址的类型，并使用动态污染分析来映射输入字节最终在哪些内存位置。然而，数据流分析通常会增加运行时开销。</li>
</ul>
<h2 id="challengesfaced-by-directed-greybox-fuzzing">ChallengesFaced by Directed Greybox Fuzzing</h2>
<h3 id="performance-deduction">Performance Deduction</h3>
<ul>
<li>额外的仪器和数据分析使得fuzzing的性能下降，优化效率是提高方向性的主要挑战。</li>
<li>解决方案：
<ul>
<li>将繁重的与执行无关的计算从运行时移到编译时。</li>
<li>在执行前过滤掉目标无法到达的输入。</li>
<li>使用更轻量级的算法。</li>
<li>利用并行计算。</li>
</ul>
</li>
</ul>
<h3 id="equal-weighted-metrics-bias-seed-prioritization-等加权指标偏差种子优先级">Equal-weighted Metrics Bias Seed Prioritization 等加权指标偏差种子优先级</h3>
<ul>
<li>在大多数最先进的定向灰盒模糊器中，种子优先级是基于等加权指标的，即，将控制流图中的每个分支跳视为具有等概率。，这样的测量忽略了不同的分支跳跃有不同的概率，因此，偏差了定向模糊的性能。</li>
<li>一种常见的情况是A→C表示错误处理代码的执行路径。错误处理代码通常简短，用于检索资源，例如释放分配的内存。因此，从错误处理代码到目标的执行路径通常距离很短(例如，一跳)。然而，由于很少执行错误处理代码，这样的执行路径的概率很低。如果我们只考虑距离，错误处理代码的路径就会被过分强调，我们就会忽略容易出现错误的常规代码，从而导致偏差。</li>
<li>一种解决方案是考虑分支跳转概率，构建加权适应度指标。在这种情况下，每个seed的优先级是根据将当前执行路径转换为经过目标的目标路径的概率来确定的。因为一个执行路径可以被看作是一个连续分支[1]的马尔可夫链，路径概率可以通过收集路径内所有分支的概率来计算。然后基于蒙特卡罗方法[23]，通过计算分支概率的比值，可以统计地估计分支概率。由于模糊处理的随机性和高通量，满足了蒙特卡罗方法对随机大采样的要求。因此，分布密度可以以轻量级的方式形式化地估计分支跳转概率。</li>
<li>基于概率评估目标可达性的一个可能的缺点是潜在的运行时开销。统计跳变计数和概率计算都引入了额外的计算量。缓解性能下降的一种方法是<strong>间隔抽样</strong>。通过适当的采样来压缩跳跃统计量，可以加快概率计算的速度，减轻存储空间的需求。另一种方法是<strong>加快跳跃统计数据的存储和访问方式</strong>。一方面，基于概率的方法经常更新跳跃统计数据，可达性判断也需要快速跟踪。另一方面，由于跳跃通常只有两个分支，数据分布(例如基于矩阵)将是相对稀疏的，这将极大地增加空间消耗。因此，需要一个自定义的数据结构来平衡时间和空间的复杂性。</li>
</ul>
<h3 id="global-optimum-discrepancy-in-the-distance-based-metric-基于距离的度量的全局最优差异">Global Optimum Discrepancy in the Distance-based Metric 基于距离的度量的全局最优差异</h3>
<ul>
<li>当使用基于距离的度量度量多个目标时，采取的策略是寻求所有目标的全局最短路径，然而这种全局最优可能会错过最接近特定目标的局部最优种子，从而导致差异。</li>
<li>举例的这个例子我没看懂，既然L不是目标，那第三个种子应该最开始就被排除，怎么还计算路径距离和别的种子比较呢？</li>
<li>造成这种差异的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，较长的路径可能被忽略，导致结果不一致。</li>
<li>在满足以下三个条件时，这种差异是现实的，并且经常发生:(1)多个目标按距离测量;(2)至少一个目标具有多条可行路径;(3)种子沿着较长的路径运动，用这个距离来衡量。多目标测试是应用DGF时经常使用的场景。例如，通过将代码更改设置为目标来测试补丁。因此，条件1)很容易满足。对于条件2)，我们也使用错误处理代码作为示例。错误处理代码可以是许多功能模块的目标，这意味着错误处理代码中的目标通常可以通过许多路径到达，因此条件2)也很容易满足。最后，条件3)的满足是不确定的，因为我们不能保证较长的路径被行使。只有当种子运动的路径较长时，才用这个距离来衡量，就会出现不一致。（没看懂）</li>
<li>为了避免这种差异，必须考虑到到达目标的所有可能路径。例如，在不同的上下文中，从调用函数到立即调用函数的距离可能不完全相同。为了解决这个问题，Hawkeye使用基于轻量级静态分析的“邻接函数距离增强”[67]，该方法基于生成的调用图考虑(即时)调用关系的模式，以增强由呼叫方和被呼叫方之间的即时调用关系定义的距离。协调多目标的另一个策略是分离目标。对于每个种子，只有所有目标的最小距离被选择为种子距离，并且种子的优先级基于这个最小距离[20]。这样做的结果是否定了偏向全局最优解的可能性，但代价是增加了达到给定目标所需的时间。</li>
</ul>
<h3 id="inflexible-coordination-of-exploration-phase-and-exploitation-phase--勘探阶段和开发阶段的不灵活协调">Inflexible Coordination of Exploration Phase and Exploitation Phase  勘探阶段和开发阶段的不灵活协调</h3>
<p>DGF的另一个挑战在于协调勘探与开发之间的权衡。一方面，要加大勘探力度，为开发提供充分的信息;另一方面，过度勘探会占用大量资源，延误开发。确定勘探阶段与开发阶段的界限以获得最佳开采效果是一项困难的工作。</p>
<ul>
<li>这块没什么人做，在调查的定向模糊器中，只有一项工作是优化勘探开发协调。</li>
<li>RDFuzz[69]结合距离和频率来评估输入。在探索阶段需要低频输入以提高覆盖范围，而在开发阶段则倾向于短距离输入以实现目标代码区域。最后采用相互缠绕的试验计划，进行勘探与开发交替进行。然而，对四种输入类型 (短/长、低频/高频) 的分类是初步的，其性能在很大程度上取决于经验阈值。
2020usenix 的 EcoFuzz 解决了该问题</li>
</ul>
<h3 id="dependence-on-the-put-source--code">Dependence on the PUT Source  Code</h3>
<ul>
<li>大多数已知的DGF工作需要源代码，它不适合测试源代码不可用的场景，例如商业现货(COTS)软件，或者部分依赖于第三方库的安全关键程序。</li>
<li>在二进制层次上阻碍dgf应用的原因有很多。
<ul>
<li>首先，沉重的运行时开销。二进制级测试的直接解决方案是通过全系统模拟器，例如QEMU[25]。然而，基于模拟器的工具通常效率较低。
<ul>
<li>减轻性能限制的可行解决方案是硬件辅助，例如英特尔处理器跟踪(PT)。Intel PT是Intel处理器中的轻量级硬件特性。它可以动态地跟踪程序执行，开销几乎可以忽略不计(平均比QEMU-AFL快4.3倍[94])，从而取代了对动态检测的需求。利用Intel PT捕获的数据包跟踪和相应的PUT二进制文件，可以完全重构PUT的执行路径。有人尝试用pt进行模糊[7,93 - 95]，但从未用于DGF。</li>
</ul>
</li>
<li>二是目标信息收集困难。开源PUT可用于从各种渠道获取目标信息，例如cvevulvulnerability描述[23,24]，gitcommit日志[19]中的更改，以及源代码中关键站点上的人类经验。然而，对于二进制代码，我们只能从bug跟踪[25]中提取目标信息。</li>
<li>三是目标定位困难。对于源代码检测方法，目标可以基于源代码进行标记(例如。， cxxfilt.c，第100行)。然而，对于二进制来说要困难得多。由于二进制代码很难读取，它必须使用IDA Pro[25]等工具进行分解，并使用虚拟地址标记目标，这既不方便又耗时。
<ul>
<li>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法[27,28]和启发式二进制差分方法[73]来自动识别脆弱代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="application-of-directedgreyboxfuzzing">Application of DirectedGreyboxFuzzing</h2>
<ul>
<li>patch testing</li>
<li>bug reproduction</li>
<li>knowledge integration</li>
<li>result validation</li>
<li>energy saving  dgf的另一个有趣的应用是在测试资源有限的情况下。例如，当模糊物联网设备。在这种情况下，识别关键代码区域来指导测试比以无导向的方式测试整个程序更有效，这可以节省时间和计算资源花在没有bug的代码区域上。GREYHOUND[12]和RVFUZZER[33]分别为Wi-Fi客户端和机器人车辆设计，均适用于此场景。</li>
<li>Special bug detection.</li>
</ul>
<h2 id="perspectives-on-future-trends">Perspectives on Future Trends</h2>
<h3 id="exploitation-of-relationship-between-targets">Exploitation of Relationship between Targets</h3>
<ul>
<li>当目标模糊化任务中存在多个目标时，如何协调这些目标是另一个挑战。对于要达到的多个目标，挖掘目标之间的关系对优化dgf具有重要意义。如果目标是不相关的，可以给它们分配权重，以区分重要性或概率。或者，可以提取和利用隐藏的关系来提高方向性。</li>
<li>在此，我们建议在dgf研究中可以考虑以下关系。
<ul>
<li>空间关系。即目标在执行树上的相对位置。考虑两个目标之间的关系，包括它们是否占用同一个分支、共享执行的级别以及它们的相对优先级(如果有的话)。</li>
<li>交错的关系。对于多线程程序，线程调度也会影响不同线程中事件的执行顺序。同一线程交错下可达到的目标在交错空间中应具有密切的关系。</li>
</ul>
</li>
</ul>
<h3 id="design-multi-dimensional-fitness-metric">Design Multi-dimensional Fitness Metric</h3>
<ul>
<li>目前的模糊方法主要集中在路径层面的覆盖，这忽略了即使执行脆弱的代码，一些bug也不会被触发或显示的事实。为了检测这种“难以显示”的漏洞，适应度度量必须扩展为多维度，例如状态空间。
<ul>
<li>例如，只有当缓冲区访问指针指向缓冲区之外时，缓冲区溢出漏洞才会在缓冲区访问位置显示。类似地，只有当被递增的变量具有足够大的值时，才会在编程位置观察到整数溢出漏洞。</li>
</ul>
</li>
<li>状态空间是一个值得与漏洞位置的可达性一起考虑作为适应度度量的维度。在实践中，大多数基于模糊的方法只在执行某些代码时取得进展，忽略了状态机的更新。然而，有些漏洞可能只有某些到达漏洞点且状态正确的执行才可能表现出脆弱行为。为了暴露这种漏洞，我们需要输入不仅能到达漏洞位置，而且还能匹配脆弱状态[81]。</li>
</ul>
<h3 id="multi-objective-optimization">Multi-objective Optimization</h3>
<ul>
<li>多目标优化比只能实现一个目标的传统策略更有优势。它制定了多个属性之间的权衡，如可用性和安全性[100]。例如，多目标优化可以生成覆盖特定目标的测试集，同时最大限度地提高总体覆盖率，或者优先考虑覆盖尽可能多的软件的测试，同时最大限度地减少测试运行[45]所需的时间。多目标搜索的结果是一组帕累托最优解，其中对于所有目标[45]，集合中的每个成员都不比其他任何成员更好。</li>
<li>优化多个目标的一般解决方案是协同进化，其中两个(或多个)测试输入群体使用它们自己的适应度函数以合作的方式同时进化[101]。</li>
</ul>
<h3 id="target-for-new-domains">Target for New Domains</h3>
<ul>
<li>内核测试
<ul>
<li>在评估的工具中，只有一个(SemFuzz[19])支持内核代码测试。因此，在内核代码中引入DGF，并在关键位置(如系统调用和错误处理代码)引导模糊处理来发现内核错误应该是一个有效的方向。</li>
</ul>
</li>
<li>协议测试
<ul>
<li>定向测试可以加强协议消息的关键字段，例如消息长度和控制信息。Zhuet等[103]利用dgf通过目标和执行间接跳转来构建更完整的控制流图。</li>
</ul>
</li>
<li>将DGF应用于具有特定特征的bug类型</li>
</ul>
<h2 id="感兴趣的">感兴趣的</h2>
<ul>
<li>机器学习fuzz “ such as by machine learning [27–29]”</li>
<li>hawkeye[67]</li>
<li>利用基于深度学习的模型，可以预测函数的脆弱概率，并为脆弱函数中的每个基本块给出一个静态脆弱评分来衡量函数的脆弱概率。然后，对于每个输入，执行路径上所有基本块的静态脆弱得分之和被用作适应度得分，以优先考虑得分较高的输入[27,28]。</li>
<li>metric那里的论文其实都可以看看</li>
<li>FuzzGuard [89]utilizes a deep-learning-based approach to predict and filterout unreachable inputs before exercising them</li>
<li>BEACON[90]使用轻量级静态分析剔除不可行的路径(即在运行时无法到达目标代码的路径)，可以拒绝在模糊处理期间执行的80%以上的路径</li>
<li>对于分支概率这方面好像没什么论文</li>
<li>dgf的另一个有趣的应用是在测试资源有限的情况下。例如，当模糊物联网设备。在这种情况下，识别关键代码区域来指导测试比以无导向的方式测试整个程序更有效，这可以节省时间和计算资源花在没有bug的代码区域上。GREYHOUND[12]和RVFUZZER[33]分别为Wi-Fi客户端和机器人车辆设计，均适用于此场景。</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB">论文阅读</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
