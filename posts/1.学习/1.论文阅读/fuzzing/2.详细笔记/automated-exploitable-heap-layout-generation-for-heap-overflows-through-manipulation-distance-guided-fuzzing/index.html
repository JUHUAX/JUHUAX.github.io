<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing" />
<meta property="og:description" content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing"/>
<meta name="twitter:description" content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner."/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing</h1>
			<div class="meta">Posted on Jun 22, 2023</div>
		</div>
		

		<section class="body">
			<p>中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局
作者：Bin Zhang
单位：国防科大
国家： #中国
年份： #2023年
来源： #USENIX会议
关键字： #fuzzing #AGE
代码地址：<a href="https://github.com/Epeius/Scatter">Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com)</a>  （代码没有上传，只有readme）
笔记建立时间： 2023-05-31  09:35
#TODO</p>
<h2 id="abstract">Abstract</h2>
<ul>
<li>heap primitives are leveraged to construnct exploitable states</li>
<li>prior efforts only focus on particular program types or programs with dispatcher-loop structures,  these are hard for general-purpose programs</li>
<li>this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner.</li>
</ul>
<h2 id="background">Background</h2>
<ul>
<li>A heap primitive is a code snippet that invokes one or more heap operations (such as malloc and free), and it is often invoked multiple times with a certain program input.</li>
<li>using heap overflows vulnerabilities to achieve control flow hijacking need strict control of heap allocations, which is challenging</li>
<li>Existing approaches to constructing exploitable heap layouts can be categorized into two types: modeling-based approaches and fuzzing-based approaches.
<ul>
<li>existing approaches rely on heap primitives that are easy to be utilized in specific programs</li>
</ul>
</li>
</ul>
<h2 id="关于-a-running-example-的解释">关于 A Running Example 的解释</h2>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230531142037.png" alt="image.png">
图中的f和m是指free和malloc，代码（listing 1）中有注释。
listing1的漏洞在于可以输入超过申请chunk大小的输入而造成堆溢出。
可利用的堆溢出是指可以从当前chunk溢出到下一个chunk的头，从而修改chunk的属性。
所以简单的poc（论文中给出的0x100个字节的poc）只能造成程序崩溃或者甚至都不会造成程序崩溃。
想要堆溢出就需要构造堆的布局，就是图中右边，也就是输入epoc。epoc精心构造的目的就是让最后代码的45行输入的puredata可以放入堆块A，这样溢出后就可以影响到堆块B的头，甚至C的头也可以。
如果不精细构造的话输入的puredata纵然产生了堆溢出，但是没有影响到其他堆块。</p>
<h2 id="methodology">Methodology</h2>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230531144835.png" alt="image.png">
input is the source code of target program and the PoC that triggers a heap overflow vulnerability
output are ePoCs that construct exploitable heap layouts</p>
<h3 id="identifying-victim-objects">Identifying Victim Objects</h3>
<ul>
<li>indentify the sensitive structures by static analysis
<ul>
<li>sensitive structures:
<ul>
<li>a structure that contains pointers</li>
<li>a structure that has no pointers but contains a member that can affect a buffer&rsquo;s access</li>
<li>a union structure that contains previous two types of structures and is accessed as its structure type</li>
</ul>
</li>
<li>这步骤是用来识别代码中对sensitive structures的定义（猜测）</li>
</ul>
</li>
<li>identify potential victim objects at runtime by dynamic instrumentation (为啥需要动态分析)</li>
<li>after recognizing, scatter locates all victim object allocation points by indentifying heap operations that allocate or free memory for the sensitive structures
<ul>
<li>这部分是识别代码中对sensitive structures的free和maclloc操作</li>
</ul>
</li>
<li>analyze the type for the return of allocation functions
<ul>
<li>通过分析LLVM IR</li>
</ul>
</li>
</ul>
<h3 id="pinpointing-critical-input-bytes">Pinpointing Critical Input Bytes</h3>
<p>这部分用于识别输入中可能影响堆操作的字节</p>
<h4 id="identifying-mutable-operations">Identifying Mutable Operations</h4>
<ul>
<li>这个可变操作应该指的是受输入影响的对操作，这影响可以是执行次数，也可以是执行参数</li>
<li>build LDG（Layout Dependence Graph）：SCATTER firstly utilizes a heap-operation-guided fuzzer to explore different execution paths, and then extracts heap operations and control flow information on each path.（这里咋实现的）</li>
<li>SCATTER identifies mutable heap operations by identifying whether the parameters or execution times of the operations change when giving different program inputs.
<ul>
<li>leverages dynamic taint analysis technique to check whether an operation’s parameters can be affected by the input bytes.</li>
</ul>
</li>
</ul>
<h4 id="mapping-to-input-bytes">Mapping to Input Bytes</h4>
<ul>
<li>leverages a lightweight “mutate-check” strategy to locate input bytes that can affect mutable heap operations.
<ul>
<li>先以输入a执行一次程序，收集参数和可变堆操作出现的次数。然后对a进行多次变异，执行程序，检查参数和可变堆操作的次数是否变化。</li>
</ul>
</li>
</ul>
<h3 id="modeling-fuzzing-based-manipulation">Modeling Fuzzing-Based Manipulation</h3>
<p>a. collect a set of victim objects, determine their locations in the heap</p>
<ul>
<li>through dynamic instrumentation,  obtain all victim  objects that are alive in heap</li>
</ul>
<p>b. adjust vulnerable object&rsquo;s location according to the victim objects&rsquo; locations through fuzzing, based on the manipulation distance metric</p>
<ul>
<li>for each victim object, we  traverse the trace of heap operations to locate all suitable free chunks for placing the vulnerable object and calculate the manipulation distances.</li>
<li>the suitable free chunks following requirements: (1) it is freed before allocating ov and has the same size with ov; (2) ov can overflow into os when ov is placed into this free chunk.</li>
</ul>
<h4 id="defining-basic-manipulation-distance">Defining Basic Manipulation Distance</h4>
<ul>
<li>distance is based on the heap operation</li>
</ul>
<p>a. the position of free chunk c in the free list
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230603105716.png" alt="image.png"></p>
<ul>
<li>nA and nF denote the number of allocation and the number of free operations with the same size of c in ⃗ Ro, respectively. (heap operations ⃗ Ro between c’s free and ov’s allocation)</li>
<li>ζ{0,1} = 0 if c’s free list is FIFO, otherwise, ζ{0,1} = 1 for FILO.</li>
<li>δ represents the position index (start from 1) of c in the free list according to the allocation order.</li>
</ul>
<p>b. basic manipulation distance (to corrupt a victim object os by placing the vulnerable object ov into a free chunk c)
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230603110617.png" alt="image.png">
(这把上面的式子代入不是0吗？啥意思)</p>
<h4 id="handling-early-occupation-problem">Handling Early Occupation Problem</h4>
<p>occupation problem  means our target chunk c will be not free when we allocate the vulnerable object
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230603155055.png" alt="image.png">
the smaller overload factor is, the less likely occupation problem is to occur
combine the overload factor and Basic Manipulation Distance, the extended manipulation  distance d is :
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230603155921.png" alt="image.png"></p>
<h4 id="handling-split-merge-mechanism">Handling Split-Merge Mechanism</h4>
<p>this part don&rsquo;t change the equation of distance, author build a model for the $n_A$ and $n_F$ based on the different situation of chunk split and merge.</p>
<h3 id="manipulation-distance-guided-fuzzing">Manipulation Distance-Guided Fuzzing</h3>
<ul>
<li>extract the heap operation trace, the vulnerable object, and all alive victim objects when the overflow occurs</li>
<li>For each SCATTER calculates the distance to corrupt it.</li>
<li>By iteratively reducing the distance to 0, SCATTER generates the final ePoCs.</li>
</ul>
<h4 id="two-challenge">two challenge</h4>
<ul>
<li>
<p>how to determine a mutated PoC triggers the same vulnerability as the initial PoC does</p>
<ul>
<li>For two PoCs, if their vulnerable objects’ allocation points and overwriting points from the ASAN’s reports are same, we regard them as triggering the same heap overflow.</li>
</ul>
</li>
<li>
<p>which PoCs deserve higher priorities to fuzz and how much mutation energy should be assigned?</p>
<ul>
<li>SCATTER is based on genetic algorithms and selects the seeds according to the following criteria:
<ul>
<li>Shorter distance</li>
<li>More victim objects</li>
<li>More free chunks</li>
<li>Diverse heap operation sequences</li>
<li>The priorities for the criteria are (from high to low): shorter distance, more victim objects, more free chunks and diverse heap operation sequences.</li>
</ul>
</li>
<li>base on these criteria, author set a expansion factor to adjust the mutation energy obtained by coverage-based fuzzing
<ul>
<li><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230607092759.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="evaluation">Evaluation</h2>
<h3 id="epoc-generation">ePOC Generation</h3>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230607095704.png" alt="image.png"></p>
<ul>
<li>总体上看起来这个sensitive struct的识别率不是很高</li>
<li>疑问：sensitive struct总数是哪里来的，和identify的有啥区别</li>
</ul>
<p>the author believe that the reasons of failed cases are</p>
<ul>
<li>Limited number of victim objects</li>
<li>Limited heap operations</li>
<li>Limited explored paths
<ul>
<li>the heap operations on the explored pathes are unable to adjust the location of the vulnerable object</li>
<li>complex path constraints.</li>
</ul>
</li>
<li>Running Failure</li>
</ul>
<h3 id="comparison-with-state-of-the-art">Comparison with State-of-the-Art</h3>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230607102637.png" alt="image.png"></p>
<ul>
<li>AFLcrash意识是AFL的崩溃测试模式</li>
<li>AFLcrit是给AFL喂SCATTER识别的关键字节</li>
<li>SCAg是用Gollum’s distance</li>
<li>SCA*是用AFL的能量分配策略</li>
</ul>
<h3 id="time-consumption">Time Consumption</h3>
<p>总之就是它快</p>
<h2 id="limitation">Limitation</h2>
<ul>
<li>Other General Heap Managers</li>
<li>Customized Heap Managers</li>
<li>Multi-threads.</li>
</ul>
<h2 id="summary-by-myself">Summary by myself</h2>
<p>explored path是啥
结合Case Study回顾一下</p>
<p>目的：
方法：
意义：
效果：</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB">论文阅读</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
