<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing | BLOG</title><meta name=keywords content="论文阅读"><meta name=description content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner."><meta name=author content="JUHUA"><link rel=canonical href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing"><meta property="og:description" content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner."><meta property="og:type" content="article"><meta property="og:url" content="https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/"><meta property="og:image" content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-22T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing"><meta name=twitter:description content="中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO
Abstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://examplesite.com/posts/"},{"@type":"ListItem","position":2,"name":"Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing","item":"https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing","name":"Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing","description":"中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO\nAbstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner.","keywords":["论文阅读"],"articleBody":"中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局 作者：Bin Zhang 单位：国防科大 国家： #中国 年份： #2023年 来源： #USENIX会议 关键字： #fuzzing #AGE 代码地址：Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com) （代码没有上传，只有readme） 笔记建立时间： 2023-05-31 09:35 #TODO\nAbstract heap primitives are leveraged to construnct exploitable states prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner. Background A heap primitive is a code snippet that invokes one or more heap operations (such as malloc and free), and it is often invoked multiple times with a certain program input. using heap overflows vulnerabilities to achieve control flow hijacking need strict control of heap allocations, which is challenging Existing approaches to constructing exploitable heap layouts can be categorized into two types: modeling-based approaches and fuzzing-based approaches. existing approaches rely on heap primitives that are easy to be utilized in specific programs 关于 A Running Example 的解释 图中的f和m是指free和malloc，代码（listing 1）中有注释。 listing1的漏洞在于可以输入超过申请chunk大小的输入而造成堆溢出。 可利用的堆溢出是指可以从当前chunk溢出到下一个chunk的头，从而修改chunk的属性。 所以简单的poc（论文中给出的0x100个字节的poc）只能造成程序崩溃或者甚至都不会造成程序崩溃。 想要堆溢出就需要构造堆的布局，就是图中右边，也就是输入epoc。epoc精心构造的目的就是让最后代码的45行输入的puredata可以放入堆块A，这样溢出后就可以影响到堆块B的头，甚至C的头也可以。 如果不精细构造的话输入的puredata纵然产生了堆溢出，但是没有影响到其他堆块。\nMethodology input is the source code of target program and the PoC that triggers a heap overflow vulnerability output are ePoCs that construct exploitable heap layouts\nIdentifying Victim Objects indentify the sensitive structures by static analysis sensitive structures: a structure that contains pointers a structure that has no pointers but contains a member that can affect a buffer’s access a union structure that contains previous two types of structures and is accessed as its structure type 这步骤是用来识别代码中对sensitive structures的定义（猜测） identify potential victim objects at runtime by dynamic instrumentation (为啥需要动态分析) after recognizing, scatter locates all victim object allocation points by indentifying heap operations that allocate or free memory for the sensitive structures 这部分是识别代码中对sensitive structures的free和maclloc操作 analyze the type for the return of allocation functions 通过分析LLVM IR Pinpointing Critical Input Bytes 这部分用于识别输入中可能影响堆操作的字节\nIdentifying Mutable Operations 这个可变操作应该指的是受输入影响的对操作，这影响可以是执行次数，也可以是执行参数 build LDG（Layout Dependence Graph）：SCATTER firstly utilizes a heap-operation-guided fuzzer to explore different execution paths, and then extracts heap operations and control flow information on each path.（这里咋实现的） SCATTER identifies mutable heap operations by identifying whether the parameters or execution times of the operations change when giving different program inputs. leverages dynamic taint analysis technique to check whether an operation’s parameters can be affected by the input bytes. Mapping to Input Bytes leverages a lightweight “mutate-check” strategy to locate input bytes that can affect mutable heap operations. 先以输入a执行一次程序，收集参数和可变堆操作出现的次数。然后对a进行多次变异，执行程序，检查参数和可变堆操作的次数是否变化。 Modeling Fuzzing-Based Manipulation a. collect a set of victim objects, determine their locations in the heap\nthrough dynamic instrumentation, obtain all victim objects that are alive in heap b. adjust vulnerable object’s location according to the victim objects’ locations through fuzzing, based on the manipulation distance metric\nfor each victim object, we traverse the trace of heap operations to locate all suitable free chunks for placing the vulnerable object and calculate the manipulation distances. the suitable free chunks following requirements: (1) it is freed before allocating ov and has the same size with ov; (2) ov can overflow into os when ov is placed into this free chunk. Defining Basic Manipulation Distance distance is based on the heap operation a. the position of free chunk c in the free list nA and nF denote the number of allocation and the number of free operations with the same size of c in ⃗ Ro, respectively. (heap operations ⃗ Ro between c’s free and ov’s allocation) ζ{0,1} = 0 if c’s free list is FIFO, otherwise, ζ{0,1} = 1 for FILO. δ represents the position index (start from 1) of c in the free list according to the allocation order. b. basic manipulation distance (to corrupt a victim object os by placing the vulnerable object ov into a free chunk c) (这把上面的式子代入不是0吗？啥意思)\nHandling Early Occupation Problem occupation problem means our target chunk c will be not free when we allocate the vulnerable object the smaller overload factor is, the less likely occupation problem is to occur combine the overload factor and Basic Manipulation Distance, the extended manipulation distance d is : Handling Split-Merge Mechanism this part don’t change the equation of distance, author build a model for the $n_A$ and $n_F$ based on the different situation of chunk split and merge.\nManipulation Distance-Guided Fuzzing extract the heap operation trace, the vulnerable object, and all alive victim objects when the overflow occurs For each SCATTER calculates the distance to corrupt it. By iteratively reducing the distance to 0, SCATTER generates the final ePoCs. two challenge how to determine a mutated PoC triggers the same vulnerability as the initial PoC does\nFor two PoCs, if their vulnerable objects’ allocation points and overwriting points from the ASAN’s reports are same, we regard them as triggering the same heap overflow. which PoCs deserve higher priorities to fuzz and how much mutation energy should be assigned?\nSCATTER is based on genetic algorithms and selects the seeds according to the following criteria: Shorter distance More victim objects More free chunks Diverse heap operation sequences The priorities for the criteria are (from high to low): shorter distance, more victim objects, more free chunks and diverse heap operation sequences. base on these criteria, author set a expansion factor to adjust the mutation energy obtained by coverage-based fuzzing Evaluation ePOC Generation 总体上看起来这个sensitive struct的识别率不是很高 疑问：sensitive struct总数是哪里来的，和identify的有啥区别 the author believe that the reasons of failed cases are\nLimited number of victim objects Limited heap operations Limited explored paths the heap operations on the explored pathes are unable to adjust the location of the vulnerable object complex path constraints. Running Failure Comparison with State-of-the-Art AFLcrash意识是AFL的崩溃测试模式 AFLcrit是给AFL喂SCATTER识别的关键字节 SCAg是用Gollum’s distance SCA*是用AFL的能量分配策略 Time Consumption 总之就是它快\nLimitation Other General Heap Managers Customized Heap Managers Multi-threads. Summary by myself explored path是啥 结合Case Study回顾一下\n目的： 方法： 意义： 效果：\n","wordCount":"941","inLanguage":"en","datePublished":"2023-06-22T00:00:00Z","dateModified":"2023-06-22T00:00:00Z","author":{"@type":"Person","name":"JUHUA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing/"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"https://examplesite.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://examplesite.com/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://examplesite.com/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://examplesite.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://examplesite.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://examplesite.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://examplesite.com/about/ title=about><span>about</span></a></li><li><a href=https://examplesite.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://examplesite.com/>Home</a>&nbsp;»&nbsp;<a href=https://examplesite.com/posts/>Posts</a></div><h1 class=post-title>Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing</h1><div class=post-meta><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;941 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;时长: 5分钟&nbsp;|&nbsp;JUHUA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/1.%e5%ad%a6%e4%b9%a0/1.%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb/fuzzing/2.%e8%af%a6%e7%bb%86%e7%ac%94%e8%ae%b0/Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#abstract aria-label=Abstract>Abstract</a></li><li><a href=#background aria-label=Background>Background</a></li><li><a href=#%e5%85%b3%e4%ba%8e-a-running-example-%e7%9a%84%e8%a7%a3%e9%87%8a aria-label="关于 A Running Example 的解释">关于 A Running Example 的解释</a></li><li><a href=#methodology aria-label=Methodology>Methodology</a><ul><li><a href=#identifying-victim-objects aria-label="Identifying Victim Objects">Identifying Victim Objects</a></li><li><a href=#pinpointing-critical-input-bytes aria-label="Pinpointing Critical Input Bytes">Pinpointing Critical Input Bytes</a><ul><li><a href=#identifying-mutable-operations aria-label="Identifying Mutable Operations">Identifying Mutable Operations</a></li><li><a href=#mapping-to-input-bytes aria-label="Mapping to Input Bytes">Mapping to Input Bytes</a></li></ul></li><li><a href=#modeling-fuzzing-based-manipulation aria-label="Modeling Fuzzing-Based Manipulation">Modeling Fuzzing-Based Manipulation</a><ul><li><a href=#defining-basic-manipulation-distance aria-label="Defining Basic Manipulation Distance">Defining Basic Manipulation Distance</a></li><li><a href=#handling-early-occupation-problem aria-label="Handling Early Occupation Problem">Handling Early Occupation Problem</a></li><li><a href=#handling-split-merge-mechanism aria-label="Handling Split-Merge Mechanism">Handling Split-Merge Mechanism</a></li></ul></li><li><a href=#manipulation-distance-guided-fuzzing aria-label="Manipulation Distance-Guided Fuzzing">Manipulation Distance-Guided Fuzzing</a><ul><li><a href=#two-challenge aria-label="two challenge">two challenge</a></li></ul></li></ul></li><li><a href=#evaluation aria-label=Evaluation>Evaluation</a><ul><li><a href=#epoc-generation aria-label="ePOC Generation">ePOC Generation</a></li><li><a href=#comparison-with-state-of-the-art aria-label="Comparison with State-of-the-Art">Comparison with State-of-the-Art</a></li><li><a href=#time-consumption aria-label="Time Consumption">Time Consumption</a></li></ul></li><li><a href=#limitation aria-label=Limitation>Limitation</a></li><li><a href=#summary-by-myself aria-label="Summary by myself">Summary by myself</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>中文译名：通过操纵距离引导的模糊测试自动生成堆溢出的可利用堆布局
作者：Bin Zhang
单位：国防科大
国家： #中国
年份： #2023年
来源： #USENIX会议
关键字： #fuzzing #AGE
代码地址：<a href=https://github.com/Epeius/Scatter>Epeius/Scatter: Automatically Generate Exploitable Memory Layout for HeapOOB-Write Vulnerabilities in Non-Interpreter Software (github.com)</a> （代码没有上传，只有readme）
笔记建立时间： 2023-05-31 09:35
#TODO</p><h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2><ul><li>heap primitives are leveraged to construnct exploitable states</li><li>prior efforts only focus on particular program types or programs with dispatcher-loop structures, these are hard for general-purpose programs</li><li>this paper present scatter, enabling the generation of exploitable heap layouts for heap overflows in generalpurpose programs in a primitive-free manner.</li></ul><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><ul><li>A heap primitive is a code snippet that invokes one or more heap operations (such as malloc and free), and it is often invoked multiple times with a certain program input.</li><li>using heap overflows vulnerabilities to achieve control flow hijacking need strict control of heap allocations, which is challenging</li><li>Existing approaches to constructing exploitable heap layouts can be categorized into two types: modeling-based approaches and fuzzing-based approaches.<ul><li>existing approaches rely on heap primitives that are easy to be utilized in specific programs</li></ul></li></ul><h2 id=关于-a-running-example-的解释>关于 A Running Example 的解释<a hidden class=anchor aria-hidden=true href=#关于-a-running-example-的解释>#</a></h2><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230531142037.png alt=image.png>
图中的f和m是指free和malloc，代码（listing 1）中有注释。
listing1的漏洞在于可以输入超过申请chunk大小的输入而造成堆溢出。
可利用的堆溢出是指可以从当前chunk溢出到下一个chunk的头，从而修改chunk的属性。
所以简单的poc（论文中给出的0x100个字节的poc）只能造成程序崩溃或者甚至都不会造成程序崩溃。
想要堆溢出就需要构造堆的布局，就是图中右边，也就是输入epoc。epoc精心构造的目的就是让最后代码的45行输入的puredata可以放入堆块A，这样溢出后就可以影响到堆块B的头，甚至C的头也可以。
如果不精细构造的话输入的puredata纵然产生了堆溢出，但是没有影响到其他堆块。</p><h2 id=methodology>Methodology<a hidden class=anchor aria-hidden=true href=#methodology>#</a></h2><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230531144835.png alt=image.png>
input is the source code of target program and the PoC that triggers a heap overflow vulnerability
output are ePoCs that construct exploitable heap layouts</p><h3 id=identifying-victim-objects>Identifying Victim Objects<a hidden class=anchor aria-hidden=true href=#identifying-victim-objects>#</a></h3><ul><li>indentify the sensitive structures by static analysis<ul><li>sensitive structures:<ul><li>a structure that contains pointers</li><li>a structure that has no pointers but contains a member that can affect a buffer&rsquo;s access</li><li>a union structure that contains previous two types of structures and is accessed as its structure type</li></ul></li><li>这步骤是用来识别代码中对sensitive structures的定义（猜测）</li></ul></li><li>identify potential victim objects at runtime by dynamic instrumentation (为啥需要动态分析)</li><li>after recognizing, scatter locates all victim object allocation points by indentifying heap operations that allocate or free memory for the sensitive structures<ul><li>这部分是识别代码中对sensitive structures的free和maclloc操作</li></ul></li><li>analyze the type for the return of allocation functions<ul><li>通过分析LLVM IR</li></ul></li></ul><h3 id=pinpointing-critical-input-bytes>Pinpointing Critical Input Bytes<a hidden class=anchor aria-hidden=true href=#pinpointing-critical-input-bytes>#</a></h3><p>这部分用于识别输入中可能影响堆操作的字节</p><h4 id=identifying-mutable-operations>Identifying Mutable Operations<a hidden class=anchor aria-hidden=true href=#identifying-mutable-operations>#</a></h4><ul><li>这个可变操作应该指的是受输入影响的对操作，这影响可以是执行次数，也可以是执行参数</li><li>build LDG（Layout Dependence Graph）：SCATTER firstly utilizes a heap-operation-guided fuzzer to explore different execution paths, and then extracts heap operations and control flow information on each path.（这里咋实现的）</li><li>SCATTER identifies mutable heap operations by identifying whether the parameters or execution times of the operations change when giving different program inputs.<ul><li>leverages dynamic taint analysis technique to check whether an operation’s parameters can be affected by the input bytes.</li></ul></li></ul><h4 id=mapping-to-input-bytes>Mapping to Input Bytes<a hidden class=anchor aria-hidden=true href=#mapping-to-input-bytes>#</a></h4><ul><li>leverages a lightweight “mutate-check” strategy to locate input bytes that can affect mutable heap operations.<ul><li>先以输入a执行一次程序，收集参数和可变堆操作出现的次数。然后对a进行多次变异，执行程序，检查参数和可变堆操作的次数是否变化。</li></ul></li></ul><h3 id=modeling-fuzzing-based-manipulation>Modeling Fuzzing-Based Manipulation<a hidden class=anchor aria-hidden=true href=#modeling-fuzzing-based-manipulation>#</a></h3><p>a. collect a set of victim objects, determine their locations in the heap</p><ul><li>through dynamic instrumentation, obtain all victim objects that are alive in heap</li></ul><p>b. adjust vulnerable object&rsquo;s location according to the victim objects&rsquo; locations through fuzzing, based on the manipulation distance metric</p><ul><li>for each victim object, we traverse the trace of heap operations to locate all suitable free chunks for placing the vulnerable object and calculate the manipulation distances.</li><li>the suitable free chunks following requirements: (1) it is freed before allocating ov and has the same size with ov; (2) ov can overflow into os when ov is placed into this free chunk.</li></ul><h4 id=defining-basic-manipulation-distance>Defining Basic Manipulation Distance<a hidden class=anchor aria-hidden=true href=#defining-basic-manipulation-distance>#</a></h4><ul><li>distance is based on the heap operation</li></ul><p>a. the position of free chunk c in the free list
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230603105716.png alt=image.png></p><ul><li>nA and nF denote the number of allocation and the number of free operations with the same size of c in ⃗ Ro, respectively. (heap operations ⃗ Ro between c’s free and ov’s allocation)</li><li>ζ{0,1} = 0 if c’s free list is FIFO, otherwise, ζ{0,1} = 1 for FILO.</li><li>δ represents the position index (start from 1) of c in the free list according to the allocation order.</li></ul><p>b. basic manipulation distance (to corrupt a victim object os by placing the vulnerable object ov into a free chunk c)
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230603110617.png alt=image.png>
(这把上面的式子代入不是0吗？啥意思)</p><h4 id=handling-early-occupation-problem>Handling Early Occupation Problem<a hidden class=anchor aria-hidden=true href=#handling-early-occupation-problem>#</a></h4><p>occupation problem means our target chunk c will be not free when we allocate the vulnerable object
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230603155055.png alt=image.png>
the smaller overload factor is, the less likely occupation problem is to occur
combine the overload factor and Basic Manipulation Distance, the extended manipulation distance d is :
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230603155921.png alt=image.png></p><h4 id=handling-split-merge-mechanism>Handling Split-Merge Mechanism<a hidden class=anchor aria-hidden=true href=#handling-split-merge-mechanism>#</a></h4><p>this part don&rsquo;t change the equation of distance, author build a model for the $n_A$ and $n_F$ based on the different situation of chunk split and merge.</p><h3 id=manipulation-distance-guided-fuzzing>Manipulation Distance-Guided Fuzzing<a hidden class=anchor aria-hidden=true href=#manipulation-distance-guided-fuzzing>#</a></h3><ul><li>extract the heap operation trace, the vulnerable object, and all alive victim objects when the overflow occurs</li><li>For each SCATTER calculates the distance to corrupt it.</li><li>By iteratively reducing the distance to 0, SCATTER generates the final ePoCs.</li></ul><h4 id=two-challenge>two challenge<a hidden class=anchor aria-hidden=true href=#two-challenge>#</a></h4><ul><li><p>how to determine a mutated PoC triggers the same vulnerability as the initial PoC does</p><ul><li>For two PoCs, if their vulnerable objects’ allocation points and overwriting points from the ASAN’s reports are same, we regard them as triggering the same heap overflow.</li></ul></li><li><p>which PoCs deserve higher priorities to fuzz and how much mutation energy should be assigned?</p><ul><li>SCATTER is based on genetic algorithms and selects the seeds according to the following criteria:<ul><li>Shorter distance</li><li>More victim objects</li><li>More free chunks</li><li>Diverse heap operation sequences</li><li>The priorities for the criteria are (from high to low): shorter distance, more victim objects, more free chunks and diverse heap operation sequences.</li></ul></li><li>base on these criteria, author set a expansion factor to adjust the mutation energy obtained by coverage-based fuzzing<ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230607092759.png alt=image.png></li></ul></li></ul></li></ul><h2 id=evaluation>Evaluation<a hidden class=anchor aria-hidden=true href=#evaluation>#</a></h2><h3 id=epoc-generation>ePOC Generation<a hidden class=anchor aria-hidden=true href=#epoc-generation>#</a></h3><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230607095704.png alt=image.png></p><ul><li>总体上看起来这个sensitive struct的识别率不是很高</li><li>疑问：sensitive struct总数是哪里来的，和identify的有啥区别</li></ul><p>the author believe that the reasons of failed cases are</p><ul><li>Limited number of victim objects</li><li>Limited heap operations</li><li>Limited explored paths<ul><li>the heap operations on the explored pathes are unable to adjust the location of the vulnerable object</li><li>complex path constraints.</li></ul></li><li>Running Failure</li></ul><h3 id=comparison-with-state-of-the-art>Comparison with State-of-the-Art<a hidden class=anchor aria-hidden=true href=#comparison-with-state-of-the-art>#</a></h3><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230607102637.png alt=image.png></p><ul><li>AFLcrash意识是AFL的崩溃测试模式</li><li>AFLcrit是给AFL喂SCATTER识别的关键字节</li><li>SCAg是用Gollum’s distance</li><li>SCA*是用AFL的能量分配策略</li></ul><h3 id=time-consumption>Time Consumption<a hidden class=anchor aria-hidden=true href=#time-consumption>#</a></h3><p>总之就是它快</p><h2 id=limitation>Limitation<a hidden class=anchor aria-hidden=true href=#limitation>#</a></h2><ul><li>Other General Heap Managers</li><li>Customized Heap Managers</li><li>Multi-threads.</li></ul><h2 id=summary-by-myself>Summary by myself<a hidden class=anchor aria-hidden=true href=#summary-by-myself>#</a></h2><p>explored path是啥
结合Case Study回顾一下</p><p>目的：
方法：
意义：
效果：</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://examplesite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></li></ul><nav class=paginav><a class=prev href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/android-smarttvs-vulnerability-discovery-via-log-guided-fuzzing/><span class=title>« Prev</span><br><span>Android SmartTVs Vulnerability Discovery via Log-Guided Fuzzing</span></a>
<a class=next href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/automated-extraction-of-software-names-from-vulnerability-reports-using-lstm-and-expert-system/><span class=title>Next »</span><br><span>Automated Extraction of Software Names from Vulnerability Reports using LSTM and Expert System</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on twitter" href="https://twitter.com/intent/tweet/?text=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f&amp;title=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing&amp;summary=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing&amp;source=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f&title=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on whatsapp" href="https://api.whatsapp.com/send?text=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing%20-%20https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Automated Exploitable Heap Layout Generation for Heap Overflows Through Manipulation Distance-Guided Fuzzing on telegram" href="https://telegram.me/share/url?text=Automated%20Exploitable%20Heap%20Layout%20Generation%20for%20Heap%20Overflows%20Through%20Manipulation%20Distance-Guided%20Fuzzing&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2ffuzzing%2f2.%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fautomated-exploitable-heap-layout-generation-for-heap-overflows-through-manipulation-distance-guided-fuzzing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://examplesite.com/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>