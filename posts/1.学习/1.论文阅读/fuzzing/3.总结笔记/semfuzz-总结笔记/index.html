<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>SemFuzz 总结笔记 - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="information source common vulnerabilities and exposures (CVE) systems CVE - CVE (mitre.org) Linux git logs CVE - CVE (mitre.org) bug descriptions posted on forums and blogs SEMANTIC INFORMATION RETRIEVING NLP tool process these information, output calling sequence. so, fuzzer utilizes the sequences to guidline the fuzz this part i want know how the fuzzer use these sequences, how two prune the unreachable path I noticed that the example both have cve report and git log Generating parse tree: the tool is pyStatParser，author use it to generate the syntax tree Retrieving affected version: basically, match through regular expressions Retrieving vulnerability type: from the 70 types of Linux kernel related CWEs, author choosed 16 types as the default type of semfuzz and semfuzz identified through the parse tree." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="SemFuzz 总结笔记" />
<meta property="og:description" content="information source common vulnerabilities and exposures (CVE) systems CVE - CVE (mitre.org) Linux git logs CVE - CVE (mitre.org) bug descriptions posted on forums and blogs SEMANTIC INFORMATION RETRIEVING NLP tool process these information, output calling sequence. so, fuzzer utilizes the sequences to guidline the fuzz this part i want know how the fuzzer use these sequences, how two prune the unreachable path I noticed that the example both have cve report and git log Generating parse tree: the tool is pyStatParser，author use it to generate the syntax tree Retrieving affected version: basically, match through regular expressions Retrieving vulnerability type: from the 70 types of Linux kernel related CWEs, author choosed 16 types as the default type of semfuzz and semfuzz identified through the parse tree." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/3.%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/semfuzz-%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SemFuzz 总结笔记"/>
<meta name="twitter:description" content="information source common vulnerabilities and exposures (CVE) systems CVE - CVE (mitre.org) Linux git logs CVE - CVE (mitre.org) bug descriptions posted on forums and blogs SEMANTIC INFORMATION RETRIEVING NLP tool process these information, output calling sequence. so, fuzzer utilizes the sequences to guidline the fuzz this part i want know how the fuzzer use these sequences, how two prune the unreachable path I noticed that the example both have cve report and git log Generating parse tree: the tool is pyStatParser，author use it to generate the syntax tree Retrieving affected version: basically, match through regular expressions Retrieving vulnerability type: from the 70 types of Linux kernel related CWEs, author choosed 16 types as the default type of semfuzz and semfuzz identified through the parse tree."/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">SemFuzz 总结笔记</h1>
			<div class="meta">Posted on Jun 22, 2023</div>
		</div>
		

		<section class="body">
			<ul>
<li>information source
<ul>
<li>common vulnerabilities and exposures (CVE) systems <a href="https://cve.mitre.org/">CVE - CVE (mitre.org)</a></li>
<li>Linux git logs <a href="https://cve.mitre.org/">CVE - CVE (mitre.org)</a></li>
<li>bug descriptions posted on forums and blogs</li>
</ul>
</li>
<li><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410205329.png" alt="image.png"></li>
<li>SEMANTIC INFORMATION RETRIEVING
<ul>
<li>NLP tool process these information, output calling sequence.</li>
<li>so, fuzzer utilizes the sequences to guidline the fuzz
<ul>
<li>this part i want know how the fuzzer use these sequences, how two prune the unreachable path</li>
</ul>
</li>
<li>I noticed that the example both have cve report and git log</li>
<li>Generating parse tree: the tool is pyStatParser，author use it to generate the syntax tree</li>
<li>Retrieving affected version: basically, match through regular expressions</li>
<li>Retrieving vulnerability type: from the 70 types of Linux kernel related CWEs, author choosed 16 types as the default type of semfuzz and semfuzz identified through the parse tree. If there it no vulnerability in the parse tree, semfuzz check out in the NVD.
<ul>
<li><!-- raw HTML omitted -->why choose the 16 kinds of types<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->How can semfuzz check out vulnerability type in NVD, artificial or automatic?<!-- raw HTML omitted --></li>
</ul>
</li>
<li>Retrieving vulnerable functions：by compare the patched program and the unpatched program
<ul>
<li>firstly, semfuzz search the patched function name in the parse tree</li>
<li>if can not find, secondly, search the patched function&rsquo;s variables in the parse tree</li>
</ul>
</li>
<li>Retrieving critical variables: follow two rules: a. variable appears in a unpatched vulnerable function; b. variable also mentioned in the description of information
<ul>
<li>firstly, semfuzz retrieve all variables in the unpatched functions and build a symbol table.</li>
<li>then, searche the parse tree</li>
<li>note that a variable must be a noun or an adjective in a phrase</li>
</ul>
</li>
<li>Retrieving system calls: author build a system calls database for reveal the relationship between variables and systemcalls and search the system call in the database useing the variables</li>
<li>semfuzz based on the kernel fuzzer Syzkaller</li>
<li>Generating Seed Input: use the retrieved system calls as a imcomplete seed and crrelates other relative systemcalls as the complete seed</li>
<li>Coarse-level Mutation: change the system calls sequences, compare the execution trace of fuzzing instance and target, calculate the distance</li>
<li>Fine-grained Mutation: change the parameter and compare the basic block number</li>
</ul>
</li>
</ul>
<h2 id="what-can-i-improve">what can i improve</h2>
<ul>
<li>the methd to generate syntax tree or we don&rsquo;t use syntax tree
<ul>
<li>before generate syntax tree, we can delete the irrelevant infromation firstly</li>
</ul>
</li>
<li>semfuzz need both git logs and cve report
<ul>
<li>maye can use less information</li>
</ul>
</li>
<li>the method of retrieving vulnerable functions maybe can improve</li>
<li>if i extend this approach to other software, maybe don&rsquo;t need retrieve system calls</li>
<li>the method of retrieving information too simple and rough and lack of semantics although it called semfuzz</li>
<li>the improve about the fuzz method is almost nothing, just use the result of retrive information as the fuzz seed</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93">论文总结</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
