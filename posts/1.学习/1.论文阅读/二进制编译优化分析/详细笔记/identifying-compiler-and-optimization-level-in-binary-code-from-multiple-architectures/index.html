<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures | BLOG</title><meta name=keywords content="论文阅读"><meta name=description content="中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44
摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点："><meta name=author content="JUHUA"><link rel=canonical href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures"><meta property="og:description" content="中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44
摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点："><meta property="og:type" content="article"><meta property="og:url" content="https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/"><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-11T02:01:58+05:30"><meta property="article:modified_time" content="2023-06-11T02:01:58+05:30"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures"><meta name=twitter:description content="中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44
摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juhuax.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures","item":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures","name":"Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures","description":"中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44\n摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点：","keywords":["论文阅读"],"articleBody":"中文译名：多体系结构二进制代码中编译器和优化级别的识别 作者：DAVIDE PIZZOLOTTO 单位：大阪大学 国家： #日本 年份： #2021年 来源： #IEEE_ACCESS 关键字： #编译 #二进制 #神经网络 代码地址：GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries 笔记建立时间： 2023-02-20 14:44\n摘要 在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。 要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。 在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。 我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。 1引言 编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。 虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。 在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。 作者指出本文的进步在于 测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。 提供了数据集和自动化生成数据集的脚本 神经网络结构的实现和调整 2动机 在一些应用场景中编译器信息和优化等级信息是必须的 二进制重写中，不了解优化等级可能会导致重写的编译失败 反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性 二进制文件比较中，编译器的优化会带来极大的误导 3前期工作 本文工作特点：\n不仅研究标志的检测，还研究编译器的检测 研究了七种不同架构的检测，而不是只有一种 分析目标不仅是最大限度地提高准确性，而且最小化所需的输入 数据集比[25]大 100 多倍，反驳了之前研究的一些说法 4方法 试图解决的问题是，当只有一部分二进制代码可用时，确定优化级别，具体来说，给定一个来自二进制文件的任意长度的字节 v 序列，我们希望训练一个分类函数 Mflags，它能够预测编译标志，以及一个分类函数 Mcompiler，它能够预测所使用的编译器。 Mflags 对输入的二进制文件的优化级别进行分类，以常用的优化水平{O0, O1, O2, O3, Os}为目标 同时针对不同的架构训练了不同的 mflags 并期望用户根据输入架构选择预测模型。二进制文件的体系结构很容易被文件等工具识别，因此这一事实并不是一个限制，并简化了训练。 同样针对编译器 gcc 和 clang，也训练了两个不同的 mcompiler 我们的目标不仅是最大化精度，而且要使字节 v 的序列尽可能小; 第 IV-B 节中解释如何将二进制代码转换为 v (或几个 v)，即我们的学习网络所期望的输入。 为了比较不同模型的性能，我们使用前馈卷积神经网络 MCNN 和长短期记忆网络 MLSTM 来训练所有上述配置，总共产生 7MCNN 标志，7 MLSTM 标志，2 MCNN 编译器和 2 MLSTM 编译器。这些网络在几个不同的数据集中进行训练，在第 IV-A 节中详细解释，并比较了它们的预测结果。 数据集 作者指出因为需要进行监督学习，所以我们需要知道数据集的编译器类型和优化级别，虽然我们在编译的时候可以掌握这些信息，但是在链接的时候，静态库文件被链接到二进制文件，这些库文件的编译器信息和优化等级我们并不知道，我们需要的二进制文件被这些库文件污染了。 为了避免上述的问题，作者采用创建一个只有共享库的系统，然后使用该系统构建数据集的方法。 本机编译 为了解决本机构建系统中的静态链接问题，作者执行了以下步骤:\n我们从主机上构建了一个没有特定编译器和优化级别的工具链。 我们确保在这个工具链中只构建共享库。2) 我们创建了一个只包含工具链的 chroot 环境，将其与原始构建系统隔离开来。 我们构建了实际的数据集，使用所需的编译器和优化级别。 交叉编译 使用 Ubuntu 现有的工具链 没有构建 clang 的数据集，值针对 GCC 进行分析 预处理 目标：将二进制文件转换为一个或多个输入向量 比较了两种方法：一种是字节流，一种是按照函数边界拆分 方法一：原始字节 为了生成这种表示，我们使用 readelf 转储可执行文件的. text 部分，并将其划分为固定大小的块。（大小是可变的） 缺点是我们不知道原始数据是表示指令还是堆栈数据。 方法二 Radare2 用于从可执行文件中提取每个函数 删除了表示指定要使用的寄存器的字节（红色字节） 删除了操作数（绿色） 保留命令（蓝色），只有这部分的字节进行了编码 在这两种表示中，我们将数据作为时间序列提供给网络，其中每个时间点实际上是二进制文件中的一个字节的数据。例如，图 2 的前两条指令将在原始字节方法中使用这个向量:[0x48, 0x89, 0x44, 0x24, 0x18, 0x31, 0xC0]。在编码的表示中，它们将是[0x89, 0x31]。 填充 因为函数的长度总是不同的，所以需要通过填充来使得输入向量长度相同。并且当使用无填充向量训练出来的模型不能很好的推测有填充的数据。\n为了解决这个问题，我们在区间[0，α]中截断一个随机字节数，其中 $α=len(v)-32$，v 是输入向量字节大小。 随机量是由指数分布定义的。我们的目的是使用一个分布，其中 99%的值落在上述区间内，同时将异常值限制在 32。在这种情况下，网络将主要接收低填充向量，而偶尔遇到填充最多的向量。利用指数累积分布函数 y = 1−e−λx，将 y 固定为 0.99, x 固定为α，得到 $λ=\\frac{2\\ln_{}{10} }{\\alpha }$ 在截断输入之后，我们通过加 0 来预扩展它。（如下图所示） 网络 事实上，我们将优化识别问题建模为模式识别问题: 一个特定的优化可以被网络识别为输入字节序列中的操作码模式。\n所以使用 CNN 和 LSTM 模型它们在 NLP 和图像处理领域表现的好 LSTM 第一个模型如图 4 所示。这个模型描述了一个简单的 LSTM，我们的核心思想是训练这种模型通过一长串属于二进制的字节来记忆特定的模式，表示编译器或优化级别。 嵌入层输入和输出维度分别是 256（输入是 8 位 2 个字节） 和 128，该层将二进制编码成输入向量 然后使用 256 个单元的 LSTM 层进行实际学习，使用双曲正切 (tanh) 作为激活函数 最后一部分是一个密集层，对于二进制情况有 1 个输出和 Sigmoid 激活，对于多类情况有 5 个输出和 Softmax 激活。 优化器是 adam，学习率为 0.003 CNN 其思想是使用一系列卷积从作为输入传递的原始字节序列中提取高维信息。 第一层和 LSTM 相同 然后使用卷积、卷积和池化三个块。在图中，卷积层的标签 k3n32s1 表示内核大小为 3，过滤器数量为 32，步幅为 1。在这些块中，卷积用于从字节序列中提取特征，池化用于使这些特征独立于它们在序列中的位置。 因为 ReLU 存在梯度消失的问题，所以使用了 leakyReLU 在输出之前，使用由 1024 个神经元组成的最终全连接层，然后使用 ReLU 激活和正则密集层和 sigmoid 进行二进制分类或使用密和 softmax 进行多类分类。 优化器是 Adam，学习率为 10−3。 所有模型均以二元交叉熵作为二元分类的损失函数，以范畴交叉熵作为多类分类[33]的损失函数。 使用超带算法[34]估计 LSTM 和 CNN 的超参数。我们在区间[32, 1024]中使用 2 的幂作为空间搜索，除了内核大小和 stride 之外。对于内核大小，空间搜索是集合{3, 5, 7}。相反，对于 stride，空间搜索是{1, 2}。\n评估 准确性 根据架构划分了数据集\n每个样本的特征数量是来自指定架构的 2048 个连续字节，按优化级别分类。\n我们为每个数据集训练了 CNN 和 LSTM 模型，得到了优化水平检测的结果如表 2 所示。（注意，除非另有说明，所有结果都是使用原始编码和填充数据获得的。）\n准确度的计算公式： 我们可以注意到\nLSTM 总是比 CNN 好 在两个网络中，x86_64、RISC-V 和 PowerPC 的精度都是最差的。 使用 LSTM 的缺点是它需要大量的训练时间，CNN 比 LSTM 快两到三倍 LSTM 大约需要 7 个 epoch 才能在第一个 epoch 结束时达到与 CNN 相同的精度。 为了进一步研究准确率，图 7 显示了使用 CNN 训练的每个模型的所有混淆矩阵。从图中可以看出，问题的部分是 O2 和 O3 之间的区别。事实上，O0 和 O1 在任何架构中都可以以 99%的准确率检测到，而 Os 永远不会低于 96%。然而，O3 在最坏的情况下，错误的分类比正确的分类更多，正如我们在 PowerPC 和 RISC-V 中看到的那样。当使用 LSTM 时，这种情况稍微好一些。结果如图 8 所示。在这张图中，我们可以看到 LSTM 在 AArch64、SPARC、MIPS、ARM 等架构下是如何达到较高精度的。CNN 的架构问题仍然存在于 LSTM 中，但程度要小得多。事实上，没有哪个优化级别报告的错误分类比正确分类更多，PowerPC O2 的最坏情况准确率为 70%。\n为了缓解这个问题，我们训练了两个额外的数据集: Dmerged 和 dsplit: 第一个包含所有优化标志，但将 O2 和 O3 合并在一起，第二个只包含 O2 和 O3。图 9 报告了这种数据集分裂的情况。我们可以注意到，从数据集的其余部分分离 O2 和 O3 后，CNN 网络的表现略好，而 LSTM 与未分离的结果相比，表现略差。\n关于编译器检测，结果如表 4 所示。该表显示了两种架构中的两个网络如何出色地执行。即使在带有 CNN 的 x86_64 案例中，优化检测表现很差，错误分类为 587 个，而正确分类为 1225822 个。考虑到 CNN 的高精度和与 LSTM 相比更快的速度，它应该是编译器检测的首选。\n最小的字节 本节将研究用函数粒度检测优化级别和编译器的可能性。 为此，我们对每个模型执行评估，同时输入逐渐增加的字节数。因此，我们执行初始评估时，每个样本只有 1 个字节; 然后，我们用 2 个字节执行第二次求值，以此类推，直到我们使用了 2048 字节的完整向量长度。 图 10 显示了使用 CNN 网络获得的结果。图 11 显示了相同的结果，但使用的是 LSTM 网络。 注意在 LSTM 网络中，每种架构都遵循相同的检测趋势。然而，与其他架构不同的是，在 CNN 架构中，x86_64、PowerPC 和 RISC-V 的准确性停止了增长。 这三个体系架构在 V-A 节的混淆矩阵中也是问题最严重的三个架构，但是 LSTM 不会发生这种情况，说明 CNN 不太能很好的识别这些架构中的 O2 和 O3 优化。 同时对于任意数量的字节，LSTM 的性能肯定要好于 CNN 为了突出显示这一点，图 12 显示了 LSTM 和 CNN 在单一体系结构 x86_64 中的直接比较。该图显示了 LSTM 的预测与 CNN 的预测相比，总是有大约 5%的准确性。 在分析了输入长度变化时整体精度如何变化之后，我们现在要检查平均函数长度是否足以达到良好的精度。\n其思想是计算每个优化级别的平均函数长度，并在特定长度处检查该特定级别的网络的准确性。我们分解了每个优化级别和编译器的每个二进制文件，并计算了组成每个函数的字节数。结果如图 13 所示。 但是平均值不太准确，会受到一些具有非常高的字节数 (大约 106 个字节) 的异常值的影响。 下图展示了选取的中位值和对应的准确度，同样在 O2 和 O3 上表现很垃 关于编译器检测，增加字节数的精度图可以在图 14 中看到。与用于优化级别检测的 CNN 和 LSTM 比较不同，在图 12 中，我们可以看到两个网络之间的差异非常小，即使输入更短。此外，即使在没有太多数据可用的情况下，准确性也很高; 例如，只有 100 个字节，就有可能有超过 90%的准确率。这意味着我们可以正确地预测编译器，即使是函数粒度。 总结：在执行函数粒度分析时，输入较短，通常可以检测 O0、O1 和 Os 优化级别。相反，考虑到 O2 和 O3 的细微差别，它们需要尽可能多的字节。相比之下，编译器检测就不会遇到这个问题，即使只有 102 个输入字节，也能达到很高的精度。\n编码 在本节中，我们将原始输入与第 IV-B 节中解释的编码变体进行比较。分析结果如图 15 所示，其中只描述了 x86_64 体系结构。 编码后的变体在输入长度约为 250 字节时达到了最大精度。相反，原始输入变量，随着更多的字节提供给它，精度稳步提高，超过了这个限制。 在分析编译器检测时也可以看到类似的情况，如图 16 所示。在这种情况下，我们可以看到编码的变体在没有进一步改进的情况下达到了大约 100 字节的最大精度。相比之下，原始数据的准确性继续提高，在 150 字节时优于编码变体，在 1000 字节时达到峰值。 然而，我们决定不将此分析扩展到所有 7 个架构。事实上，在第一节中，我们研究的动机之一是有一种自动检测优化标志的方法，这种方法不需要深入了解底层架构。然而，要生成编码的变体，有必要掌握目标体系结构的基本知识，这与我们最初的动机相矛盾。这一事实，除了性能差和需要精确的拆卸，促使我们放弃了编码变体的研究。 在结束本节之前，值得注意的是，Chen 等人的研究使用了一个小 100 倍的数据集，并确定编码变体明显更好[11]。在我们之前的研究中，我们使用了一个比当前数据集小 10 倍的数据集，并确定编码变量与原始变量[12]相同。我们可以很容易地假设，对于较小的数据集，网络学习原始数据中哪些信息有用，哪些信息没有用的能力较差。这就解释了为什么在以前的研究中，没有无用前缀的编码变体提供的数据更具竞争力。然而，对于一个足够大的数据集，编码的变体并不能提供任何优势。 总结：分解和编码数据并不能提供额外的好处，需要了解底层架构和函数分解才能获得较低的整体精度。\n填充 在第 IV-B 节中，我们断言，如果在训练期间从未填充原始字节序列，然后预测填充序列，那么我们的网络性能会更差。在本节中，我们将介绍 RQpad，并研究在训练期间填充和不填充之间的区别。有填充和无填充变体之间的差异如图 17 所示 从图中，我们可以看到，在计算小输入向量时，训练过程中填充的缺失是一个问题。 总结：如果在训练过程中从未填充输入，网络在预测较短序列时的准确性将显著降低。\n","wordCount":"522","inLanguage":"en","datePublished":"2023-06-11T02:01:58+05:30","dateModified":"2023-06-11T02:01:58+05:30","author":{"@type":"Person","name":"JUHUA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures/"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"https://juhuax.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juhuax.github.io/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://juhuax.github.io/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juhuax.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://juhuax.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juhuax.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juhuax.github.io/about/ title=about><span>about</span></a></li><li><a href=https://juhuax.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juhuax.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juhuax.github.io/posts/>Posts</a></div><h1 class=post-title>Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures</h1><div class=post-meta><span title='2023-06-11 02:01:58 +0530 +0530'>June 11, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;522 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-11 02:01:58 +0530 +0530'>June 11, 2023</span>&nbsp;|&nbsp;时长: 3分钟&nbsp;|&nbsp;JUHUA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/1.%e5%ad%a6%e4%b9%a0/1.%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb/%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e8%af%91%e4%bc%98%e5%8c%96%e5%88%86%e6%9e%90/%e8%af%a6%e7%bb%86%e7%ac%94%e8%ae%b0/Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%91%98%e8%a6%81 aria-label=摘要>摘要</a></li><li><a href=#1%e5%bc%95%e8%a8%80 aria-label=1引言>1引言</a></li><li><a href=#2%e5%8a%a8%e6%9c%ba aria-label=2动机>2动机</a></li><li><a href=#3%e5%89%8d%e6%9c%9f%e5%b7%a5%e4%bd%9c aria-label=3前期工作>3前期工作</a></li><li><a href=#4%e6%96%b9%e6%b3%95 aria-label=4方法>4方法</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e9%9b%86 aria-label=数据集>数据集</a><ul><li><a href=#%e6%9c%ac%e6%9c%ba%e7%bc%96%e8%af%91 aria-label=本机编译>本机编译</a></li><li><a href=#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91 aria-label=交叉编译>交叉编译</a></li></ul></li><li><a href=#%e9%a2%84%e5%a4%84%e7%90%86 aria-label=预处理>预处理</a></li><li><a href=#%e5%a1%ab%e5%85%85 aria-label=填充>填充</a></li><li><a href=#%e7%bd%91%e7%bb%9c aria-label=网络>网络</a><ul><li><a href=#lstm aria-label=LSTM>LSTM</a></li><li><a href=#cnn aria-label=CNN>CNN</a></li></ul></li></ul></li><li><a href=#%e8%af%84%e4%bc%b0 aria-label=评估>评估</a><ul><li><a href=#%e5%87%86%e7%a1%ae%e6%80%a7 aria-label=准确性>准确性</a></li><li><a href=#%e6%9c%80%e5%b0%8f%e7%9a%84%e5%ad%97%e8%8a%82 aria-label=最小的字节>最小的字节</a></li><li><a href=#%e7%bc%96%e7%a0%81 aria-label=编码>编码</a></li><li><a href=#%e5%a1%ab%e5%85%85-1 aria-label=填充>填充</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>中文译名：多体系结构二进制代码中编译器和优化级别的识别
作者：DAVIDE PIZZOLOTTO
单位：大阪大学
国家： #日本
年份： #2021年
来源： #IEEE_ACCESS
关键字： #编译 #二进制 #神经网络
代码地址：<a href=https://github.com/inoueke-n/optimization-detector>GitHub - inoueke-n/optimization-detector: Optimization detection over compiled binaries</a>
笔记建立时间： 2023-02-20 14:44</p><h1 id=摘要>摘要<a hidden class=anchor aria-hidden=true href=#摘要>#</a></h1><ul><li>在比较不同的二进制文件时，确保相同的编译器和编译标志尤其重要，以避免不准确或不可靠的分析。</li><li>要理解使用了哪些标志和优化，需要对目标体系结构和所使用的编译器有深入的了解。</li><li>在这项研究中，我们提出了两种深度学习模型，用于检测编译二进制文件中的编译器和优化级别。我们研究的优化级别是 x86_64、AArch64、RISC-V、SPARC、PowerPC、MIPS 和 ARM 架构中的 O0、O1、O2、O3 和 Os。此外，对于 x86_64 和 AArch64 体系结构，我们还确定编译器是 GCC 还是 Clang。</li><li>我们创建了一个超过 76000 个二进制数据集，并将其用于训练。我们的实验表明，在检测编译器时，准确率超过 99.95%，在检测优化级别时，根据架构的不同，准确率在 92%到 98%之间。此外，我们分析了当数据量极其有限时，准确性的变化。我们的研究表明，使用函数级粒度准确检测编译器标志设置和优化级别是可能的。</li></ul><h1 id=1引言>1引言<a hidden class=anchor aria-hidden=true href=#1引言>#</a></h1><ul><li>编译器信息和优化等级等信息对于各种应用程序都非常有价值，比如对旧版本进行分类，查找漏洞，查找二进制文件中的相似性，重写二进制文件，或者在编译环境无法控制的情况下提供准确的错误报告。</li><li>虽然有几篇关于检测编译器[5]和工具链[8]使用的论文，但这些方法不依赖于自动学习方法。使用基于机器学习的方法，提供新数据并重新运行训练以检测新的编译器或标志就足够了。使用我们工作中提供的自动数据集生成，对于我们想要分类的每个优化级别，生成这些数据所需的时间是几个小时。</li><li>在这项研究中，我们提出了在不同架构中使用长短期记忆网络 (LSTM)[9]和卷积神经网络 (CNN)[10]来识别编译器和优化级别的方法。</li><li>作者指出本文的进步在于<ul><li>测试的优化等级和测试数量的增加：优化等级测试次数由{O0, O2}增加到{O0, O1, O2, O3, Os}。•测试的架构数量从{x86_64}增加到{x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, ARM32}。</li><li>提供了数据集和自动化生成数据集的脚本</li><li>神经网络结构的实现和调整</li></ul></li></ul><h1 id=2动机>2动机<a hidden class=anchor aria-hidden=true href=#2动机>#</a></h1><ul><li>在一些应用场景中编译器信息和优化等级信息是必须的<ul><li>二进制重写中，不了解优化等级可能会导致重写的编译失败</li><li>反编译中，编译器信息和优化等级信息会帮助判断反编译后得到的源代码的正确性</li><li>二进制文件比较中，编译器的优化会带来极大的误导</li></ul></li></ul><h1 id=3前期工作>3前期工作<a hidden class=anchor aria-hidden=true href=#3前期工作>#</a></h1><p>本文工作特点：</p><ul><li>不仅研究标志的检测，还研究编译器的检测</li><li>研究了七种不同架构的检测，而不是只有一种</li><li>分析目标不仅是最大限度地提高准确性，而且最小化所需的输入</li><li>数据集比[25]大 100 多倍，反驳了之前研究的一些说法</li></ul><h1 id=4方法>4方法<a hidden class=anchor aria-hidden=true href=#4方法>#</a></h1><ul><li>试图解决的问题是，当只有一部分二进制代码可用时，确定优化级别，具体来说，给定一个来自二进制文件的任意长度的字节 v 序列，我们希望训练一个分类函数 Mflags，它能够预测编译标志，以及一个分类函数 Mcompiler，它能够预测所使用的编译器。<ul><li>Mflags 对输入的二进制文件的优化级别进行分类，以常用的优化水平{O0, O1, O2, O3, Os}为目标</li><li>同时针对不同的架构训练了不同的 mflags 并期望用户根据输入架构选择预测模型。二进制文件的体系结构很容易被文件等工具识别，因此这一事实并不是一个限制，并简化了训练。</li><li>同样针对编译器 gcc 和 clang，也训练了两个不同的 mcompiler</li></ul></li><li>我们的目标不仅是最大化精度，而且要使字节 v 的序列尽可能小;<ul><li>第 IV-B 节中解释如何将二进制代码转换为 v (或几个 v)，即我们的学习网络所期望的输入。</li><li>为了比较不同模型的性能，我们使用前馈卷积神经网络 MCNN 和长短期记忆网络 MLSTM 来训练所有上述配置，总共产生 7MCNN 标志，7 MLSTM 标志，2 MCNN 编译器和 2 MLSTM 编译器。这些网络在几个不同的数据集中进行训练，在第 IV-A 节中详细解释，并比较了它们的预测结果。</li></ul></li></ul><h2 id=数据集>数据集<a hidden class=anchor aria-hidden=true href=#数据集>#</a></h2><ul><li>作者指出因为需要进行监督学习，所以我们需要知道数据集的编译器类型和优化级别，虽然我们在编译的时候可以掌握这些信息，但是在链接的时候，静态库文件被链接到二进制文件，这些库文件的编译器信息和优化等级我们并不知道，我们需要的二进制文件被这些库文件污染了。</li><li>为了避免上述的问题，作者采用创建一个只有共享库的系统，然后使用该系统构建数据集的方法。</li></ul><h3 id=本机编译>本机编译<a hidden class=anchor aria-hidden=true href=#本机编译>#</a></h3><p>为了解决本机构建系统中的静态链接问题，作者执行了以下步骤:</p><ul><li>我们从主机上构建了一个没有特定编译器和优化级别的工具链。</li><li>我们确保在这个工具链中只构建共享库。2) 我们创建了一个只包含工具链的 chroot 环境，将其与原始构建系统隔离开来。</li><li>我们构建了实际的数据集，使用所需的编译器和优化级别。</li></ul><h3 id=交叉编译>交叉编译<a hidden class=anchor aria-hidden=true href=#交叉编译>#</a></h3><ul><li>使用 Ubuntu 现有的工具链</li><li>没有构建 clang 的数据集，值针对 GCC 进行分析</li></ul><h2 id=预处理>预处理<a hidden class=anchor aria-hidden=true href=#预处理>#</a></h2><ul><li>目标：将二进制文件转换为一个或多个输入向量<ul><li>比较了两种方法：一种是字节流，一种是按照函数边界拆分</li></ul></li><li>方法一：原始字节<ul><li>为了生成这种表示，我们使用 readelf 转储可执行文件的. text 部分，并将其划分为固定大小的块。（大小是可变的）</li><li>缺点是我们不知道原始数据是表示指令还是堆栈数据。</li></ul></li><li>方法二<ul><li>Radare2 用于从可执行文件中提取每个函数</li><li>删除了表示指定要使用的寄存器的字节（红色字节）</li><li>删除了操作数（绿色）</li><li>保留命令（蓝色），只有这部分的字节进行了编码</li></ul></li></ul><p>在这两种表示中，我们将数据作为时间序列提供给网络，其中每个时间点实际上是二进制文件中的一个字节的数据。例如，图 2 的前两条指令将在原始字节方法中使用这个向量:[0x48, 0x89, 0x44, 0x24, 0x18, 0x31, 0xC0]。在编码的表示中，它们将是[0x89, 0x31]。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230221225108.png alt=image.png></p><h2 id=填充>填充<a hidden class=anchor aria-hidden=true href=#填充>#</a></h2><p>因为函数的长度总是不同的，所以需要通过填充来使得输入向量长度相同。并且当使用无填充向量训练出来的模型不能很好的推测有填充的数据。</p><ul><li>为了解决这个问题，我们在区间[0，α]中截断一个随机字节数，其中 $α=len(v)-32$，v 是输入向量字节大小。</li><li>随机量是由指数分布定义的。我们的目的是使用一个分布，其中 99%的值落在上述区间内，同时将异常值限制在 32。在这种情况下，网络将主要接收低填充向量，而偶尔遇到填充最多的向量。利用指数累积分布函数 y = 1−e−λx，将 y 固定为 0.99, x 固定为α，得到 $λ=\frac{2\ln_{}{10} }{\alpha }$</li><li>在截断输入之后，我们通过加 0 来预扩展它。（如下图所示）
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230221232235.png alt=image.png></li></ul><h2 id=网络>网络<a hidden class=anchor aria-hidden=true href=#网络>#</a></h2><p>事实上，我们将优化识别问题建模为模式识别问题: 一个特定的优化可以被网络识别为输入字节序列中的操作码模式。</p><ul><li>所以使用 CNN 和 LSTM 模型它们在 NLP 和图像处理领域表现的好</li></ul><h3 id=lstm>LSTM<a hidden class=anchor aria-hidden=true href=#lstm>#</a></h3><p>第一个模型如图 4 所示。这个模型描述了一个简单的 LSTM，我们的核心思想是训练这种模型通过一长串属于二进制的字节来记忆特定的模式，表示编译器或优化级别。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230221232525.png alt=image.png></p><ul><li>嵌入层输入和输出维度分别是 256（输入是 8 位 2 个字节） 和 128，该层将二进制编码成输入向量</li><li>然后使用 256 个单元的 LSTM 层进行实际学习，使用双曲正切 (tanh) 作为激活函数</li><li>最后一部分是一个密集层，对于二进制情况有 1 个输出和 Sigmoid 激活，对于多类情况有 5 个输出和 Softmax 激活。</li><li>优化器是 adam，学习率为 0.003</li></ul><h3 id=cnn>CNN<a hidden class=anchor aria-hidden=true href=#cnn>#</a></h3><p>其思想是使用一系列卷积从作为输入传递的原始字节序列中提取高维信息。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230221233438.png alt=image.png></p><ul><li>第一层和 LSTM 相同</li><li>然后使用卷积、卷积和池化三个块。在图中，卷积层的标签 k3n32s1 表示内核大小为 3，过滤器数量为 32，步幅为 1。在这些块中，卷积用于从字节序列中提取特征，池化用于使这些特征独立于它们在序列中的位置。</li><li>因为 ReLU 存在梯度消失的问题，所以使用了 leakyReLU</li><li>在输出之前，使用由 1024 个神经元组成的最终全连接层，然后使用 ReLU 激活和正则密集层和 sigmoid 进行二进制分类或使用密和 softmax 进行多类分类。</li><li>优化器是 Adam，学习率为 10−3。</li></ul><p>所有模型均以二元交叉熵作为二元分类的损失函数，以范畴交叉熵作为多类分类[33]的损失函数。
使用超带算法[34]估计 LSTM 和 CNN 的超参数。我们在区间[32, 1024]中使用 2 的幂作为空间搜索，除了内核大小和 stride 之外。对于内核大小，空间搜索是集合{3, 5, 7}。相反，对于 stride，空间搜索是{1, 2}。</p><h1 id=评估>评估<a hidden class=anchor aria-hidden=true href=#评估>#</a></h1><h2 id=准确性>准确性<a hidden class=anchor aria-hidden=true href=#准确性>#</a></h2><ul><li><p>根据架构划分了数据集</p><ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222135044.png alt=image.png></li></ul></li><li><p>每个样本的特征数量是来自指定架构的 2048 个连续字节，按优化级别分类。</p></li><li><p>我们为每个数据集训练了 CNN 和 LSTM 模型，得到了优化水平检测的结果如表 2 所示。（注意，除非另有说明，所有结果都是使用原始编码和填充数据获得的。）</p><ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222135155.png alt=image.png></li><li>准确度的计算公式：<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222135315.png alt=image.png></li></ul></li><li><p>我们可以注意到</p><ul><li>LSTM 总是比 CNN 好</li><li>在两个网络中，x86_64、RISC-V 和 PowerPC 的精度都是最差的。</li><li>使用 LSTM 的缺点是它需要大量的训练时间，CNN 比 LSTM 快两到三倍<ul><li>LSTM 大约需要 7 个 epoch 才能在第一个 epoch 结束时达到与 CNN 相同的精度。</li></ul></li></ul></li><li><p>为了进一步研究准确率，图 7 显示了使用 CNN 训练的每个模型的所有混淆矩阵。从图中可以看出，问题的部分是 O2 和 O3 之间的区别。事实上，O0 和 O1 在任何架构中都可以以 99%的准确率检测到，而 Os 永远不会低于 96%。然而，O3 在最坏的情况下，错误的分类比正确的分类更多，正如我们在 PowerPC 和 RISC-V 中看到的那样。当使用 LSTM 时，这种情况稍微好一些。结果如图 8 所示。在这张图中，我们可以看到 LSTM 在 AArch64、SPARC、MIPS、ARM 等架构下是如何达到较高精度的。CNN 的架构问题仍然存在于 LSTM 中，但程度要小得多。事实上，没有哪个优化级别报告的错误分类比正确分类更多，PowerPC O2 的最坏情况准确率为 70%。</p></li><li><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222145745.png alt=image.png>
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222145802.png alt=image.png></p></li><li><p>为了缓解这个问题，我们训练了两个额外的数据集: Dmerged 和 dsplit: 第一个包含所有优化标志，但将 O2 和 O3 合并在一起，第二个只包含 O2 和 O3。图 9 报告了这种数据集分裂的情况。我们可以注意到，从数据集的其余部分分离 O2 和 O3 后，CNN 网络的表现略好，而 LSTM 与未分离的结果相比，表现略差。</p><ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222150148.png alt=image.png></li></ul></li><li><p>关于编译器检测，结果如表 4 所示。该表显示了两种架构中的两个网络如何出色地执行。即使在带有 CNN 的 x86_64 案例中，优化检测表现很差，错误分类为 587 个，而正确分类为 1225822 个。考虑到 CNN 的高精度和与 LSTM 相比更快的速度，它应该是编译器检测的首选。</p><ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222150202.png alt=image.png></li></ul></li></ul><h2 id=最小的字节>最小的字节<a hidden class=anchor aria-hidden=true href=#最小的字节>#</a></h2><p>本节将研究用函数粒度检测优化级别和编译器的可能性。
为此，我们对每个模型执行评估，同时输入逐渐增加的字节数。因此，我们执行初始评估时，每个样本只有 1 个字节; 然后，我们用 2 个字节执行第二次求值，以此类推，直到我们使用了 2048 字节的完整向量长度。
图 10 显示了使用 CNN 网络获得的结果。图 11 显示了相同的结果，但使用的是 LSTM 网络。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222150350.png alt=image.png>
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222150429.png alt=image.png></p><ul><li>注意在 LSTM 网络中，每种架构都遵循相同的检测趋势。然而，与其他架构不同的是，在 CNN 架构中，x86_64、PowerPC 和 RISC-V 的准确性停止了增长。<ul><li>这三个体系架构在 V-A 节的混淆矩阵中也是问题最严重的三个架构，但是 LSTM 不会发生这种情况，说明 CNN 不太能很好的识别这些架构中的 O2 和 O3 优化。</li><li>同时对于任意数量的字节，LSTM 的性能肯定要好于 CNN</li></ul></li></ul><p>为了突出显示这一点，图 12 显示了 LSTM 和 CNN 在单一体系结构 x86_64 中的直接比较。该图显示了 LSTM 的预测与 CNN 的预测相比，总是有大约 5%的准确性。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222151032.png alt=image.png></p><p>在分析了输入长度变化时整体精度如何变化之后，我们现在要检查平均函数长度是否足以达到良好的精度。</p><ul><li>其思想是计算每个优化级别的平均函数长度，并在特定长度处检查该特定级别的网络的准确性。我们分解了每个优化级别和编译器的每个二进制文件，并计算了组成每个函数的字节数。结果如图 13 所示。</li><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222152118.png alt=image.png></li><li>但是平均值不太准确，会受到一些具有非常高的字节数 (大约 106 个字节) 的异常值的影响。<ul><li>下图展示了选取的中位值和对应的准确度，同样在 O2 和 O3 上表现很垃</li><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222152453.png alt=image.png></li></ul></li></ul><p>关于编译器检测，增加字节数的精度图可以在图 14 中看到。与用于优化级别检测的 CNN 和 LSTM 比较不同，在图 12 中，我们可以看到两个网络之间的差异非常小，即使输入更短。此外，即使在没有太多数据可用的情况下，准确性也很高; 例如，只有 100 个字节，就有可能有超过 90%的准确率。这意味着我们可以正确地预测编译器，即使是函数粒度。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222153712.png alt=image.png>
总结：在执行函数粒度分析时，输入较短，通常可以检测 O0、O1 和 Os 优化级别。相反，考虑到 O2 和 O3 的细微差别，它们需要尽可能多的字节。相比之下，编译器检测就不会遇到这个问题，即使只有 102 个输入字节，也能达到很高的精度。</p><h2 id=编码>编码<a hidden class=anchor aria-hidden=true href=#编码>#</a></h2><p>在本节中，我们将原始输入与第 IV-B 节中解释的编码变体进行比较。分析结果如图 15 所示，其中只描述了 x86_64 体系结构。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222154017.png alt=image.png>
编码后的变体在输入长度约为 250 字节时达到了最大精度。相反，原始输入变量，随着更多的字节提供给它，精度稳步提高，超过了这个限制。
在分析编译器检测时也可以看到类似的情况，如图 16 所示。在这种情况下，我们可以看到编码的变体在没有进一步改进的情况下达到了大约 100 字节的最大精度。相比之下，原始数据的准确性继续提高，在 150 字节时优于编码变体，在 1000 字节时达到峰值。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222154426.png alt=image.png>
然而，我们决定不将此分析扩展到所有 7 个架构。事实上，在第一节中，我们研究的动机之一是有一种自动检测优化标志的方法，这种方法不需要深入了解底层架构。然而，要生成编码的变体，有必要掌握目标体系结构的基本知识，这与我们最初的动机相矛盾。这一事实，除了性能差和需要精确的拆卸，促使我们放弃了编码变体的研究。
在结束本节之前，值得注意的是，Chen 等人的研究使用了一个小 100 倍的数据集，并确定编码变体明显更好[11]。在我们之前的研究中，我们使用了一个比当前数据集小 10 倍的数据集，并确定编码变量与原始变量[12]相同。我们可以很容易地假设，对于较小的数据集，网络学习原始数据中哪些信息有用，哪些信息没有用的能力较差。这就解释了为什么在以前的研究中，没有无用前缀的编码变体提供的数据更具竞争力。然而，对于一个足够大的数据集，编码的变体并不能提供任何优势。
总结：分解和编码数据并不能提供额外的好处，需要了解底层架构和函数分解才能获得较低的整体精度。</p><h2 id=填充-1>填充<a hidden class=anchor aria-hidden=true href=#填充-1>#</a></h2><p>在第 IV-B 节中，我们断言，如果在训练期间从未填充原始字节序列，然后预测填充序列，那么我们的网络性能会更差。在本节中，我们将介绍 RQpad，并研究在训练期间填充和不填充之间的区别。有填充和无填充变体之间的差异如图 17 所示
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230222155225.png alt=image.png>
从图中，我们可以看到，在计算小输入向量时，训练过程中填充的缺失是一个问题。
总结：如果在训练过程中从未填充输入，网络在预测较短序列时的准确性将显著降低。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juhuax.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></li></ul><nav class=paginav><a class=prev href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/fine-grained-compiler-identification-with-sequence-oriented-neural-modeling/><span class=title>« Prev</span><br><span>Fine-Grained Compiler Identification With Sequence-Oriented Neural Modeling</span></a>
<a class=next href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/identifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%E5%A4%8D%E7%8E%B0/><span class=title>Next »</span><br><span>Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures复现</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on twitter" href="https://twitter.com/intent/tweet/?text=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f&amp;title=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures&amp;summary=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures&amp;source=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f&title=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on whatsapp" href="https://api.whatsapp.com/send?text=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures%20-%20https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures on telegram" href="https://telegram.me/share/url?text=Identifying%20Compiler%20and%20Optimization%20Level%20in%20Binary%20Code%20From%20Multiple%20Architectures&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fidentifying-compiler-and-optimization-level-in-binary-code-from-multiple-architectures%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://juhuax.github.io/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>