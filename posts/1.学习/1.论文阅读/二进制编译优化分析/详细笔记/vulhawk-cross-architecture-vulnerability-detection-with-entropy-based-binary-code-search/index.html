<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search | BLOG</title><meta name=keywords content="论文阅读"><meta name=description content="中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59
摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：
提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。
引言 现状：
二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk"><meta name=author content="JUHUA"><link rel=canonical href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search"><meta property="og:description" content="中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59
摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：
提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。
引言 现状：
二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk"><meta property="og:type" content="article"><meta property="og:url" content="https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/"><meta property="og:image" content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-11T02:01:58+05:30"><meta property="article:modified_time" content="2023-06-11T02:01:58+05:30"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search"><meta name=twitter:description content="中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59
摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：
提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。
引言 现状：
二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://examplesite.com/posts/"},{"@type":"ListItem","position":2,"name":"VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search","item":"https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search","name":"VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search","description":"中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59\n摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：\n提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。\n引言 现状：\n二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk","keywords":["论文阅读"],"articleBody":"中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测 作者：Zhenhao Luo 单位：国防科大 国家： #中国 年份： #2023年 来源： #NDSS会议 关键字： #二进制代码搜索 代码地址： https://github.com/RazorMegrez/VulHawk 笔记建立时间： 2023-03-20 13:59\n摘要 目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用 方法：\n提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型 将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言 使用 NLP 和卷积生成函数嵌入 将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。 提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异 提出了一种渐进搜索策略 用细粒度特征补充函数嵌入，以减少修补函数造成的误报 意义：提高检测代码重用带来的漏洞的效率 效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。\n引言 现状：\n二进制代码搜索方法不够健壮，不能跨平台 Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台） InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa） 将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。 相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同 在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。 本文提出了一种新的跨架构二进制代码搜索方法 VulHawk\n新的中间表示函数模型 (IRFM)——来生成健壮的函数嵌入——解决跨架构和指令简化 部署了一个基于熵的适配器——对不同编译器、体系结构和优化级别的二进制文件进行处理，缓解不同环境造成的差异 渐进搜索策略来搜索候选函数 提出一种相似度标定方法——减少误报 背景 问题定义 一个有效的跨架构的二进制代码搜索需要实现：\n支持跨架构 支持跨编译器 支持跨优化 高精度和效率 熵理论 香农的熵理论可以用来衡量系统中的随机性和平均信息量 通过熵分析，我们可以在深入研究系统之前预先了解系统中的平均信息量。在二进制代码搜索任务中，我们通过二进制文件熵得到二进制文件的信息分布，它可以推断出二进制文件的编译器和优化级别等信息。这有助于我们的模型为不同的输入二进制选择合适的参数。\n设计 IR 函数模型（IRFM） 将二进制代码的 IR 作为中间表示函数模型 (IRFM)（基于 RoBERTa 模型）的输入，输出是 IR 的词嵌入。 IRFM 将 IR 函数嵌入到高维嵌入空间中，使得语义相似函数的嵌入在数值空间中更加紧密。\nTokenization 将一条指令分割为一个操作码和三个操作数 用特殊标记 addr 来规范地址 对于 OOV （Out-Of-Vocabulary)）问题，作者引入 16 个根操作数，表内的操作数就使用自己的 token，非表内操作数就使用对应的根 token 在预训练阶段，我们将频率小于 100 次的令牌替换为其根操作数令牌，以构建根操作数令牌嵌入。 语言模型 IRFM 基于 RoBERTa 模型，但是 IR 和自然语言有所不同，所以作者进行了部分改动\nToken 类型层 使用令牌类型层来帮助 IRFM 区分操作码和操作数。将令牌分为三种类型: 操作码、操作数和其他。其他类型包括没有实际语义的特殊标记。 指令简化 二进制代码包含 EFLAGS (即标志寄存器) 作为隐式操作数。不考虑 EFLAGS，重要的语义会丢失，考虑所有的 EFLAGS，冗余的 eflag 不仅会引入额外的开销，而且可能会模糊二进制代码的主要语义。 所以只考虑使用过的 eflags，通过 IR 将每个隐式操作数指令的赋值转换为实赋值指令，并将其使用的 EFLAGS 保存为指令序列 如下图所示 a 到 b 删除了没有使用到的寄存器和标志寄存器，b 到 c 又对值传递进行了优化（化简） 提出了一种基于 def-use 关系的指令简化方法 标记重要指令（使用松散规则，以确保不会错误地删除主语义）： 目标操作数为内存地址的赋值指令（因为全局变量和局部变量存储在内存中而不是寄存器中） 在所有路径的返回指令附近根据调用约定标记特定的寄存器（因为返回值通常存储在特定的寄存器） 修剪未使用的指令 将其定义的寄存器或 EFLAGS 未在后续指令中使用的指令视为未使用的指令 优化冗余指令（值传递指令） 预训练任务 在训练阶段，我们使用 Masked Language Model (MLM)、根操作数预测 (ROP) 和相邻块预测 (ABP) 进行预训练。\nMasked Language Model 我们引入了 MLM 模型来理解之间的关系，并建立合适的词嵌入。 根操作数预测 用于解决 OOV 问题，为 OOV 操作数匹配根操作数 token 邻块预测 因为数据流的存在，所以基本块数顺序敏感的，ABP 预训练是为了让模型捕获这种数据流关系 具体来说，给定两个基本区块 A 和 B，其中 B 是 A 的后继区块，变量 x 定义在区块 A 中，变量 x 使用在区块 B 中，我们将 A-B 的顺序标记为正，B-A 的顺序标记为负。注意，A 和 B 不是同一个块，A 也不是 B 的后继块。另外，我们不认为这些情况下 A 和 B 只有控制流关系而没有数据流关系。因为如果不支持数据流关系，块的顺序也可能颠倒。我们将 IRFM 中令牌[cls]的最终隐藏状态输入到 ABP 头中，这是一个线性变换，以识别输入的两个微码序列是否正序。 函数嵌入生成 首先生成基本块嵌入\n对于输入的 IR 块，IRFM 转化编码器输出隐藏状态序列，然后在倒数第二层的隐藏状态上使用均值池来生成基本块嵌入。（因为研究表明倒数第二层的隐藏状态比最后一层的隐藏状态具有更强的泛化能力。） 集成基本块嵌入和 cfg 来生成函数嵌入\n使用 GCNs 捕获 CFG 结构，将二进制函数视为属性图，其中它们的基本块是图中的节点，它们的嵌入是节点的属性。我们将属性控制流图 (acfg) 输入到 GCN 层。 基于熵的适配器 Divide-and-conquer 图 5 显示了在嵌入空间中匹配相似函数的示例。可以看到混合文件环境的文件经过适配器后进行了统一。（可以理解为一个翻译器） 首先，我们将混合文件环境的嵌入空间拆分为多个嵌入子空间。 其次，选择其中一个文件环境 V 作为中间文件环境，将 N 个具有 C2 N 个场景的文件环境中的函数相似度问题划分为 N−1 个子函数嵌入传递问题。 最后，我们使用经过训练的适配器将不同文件环境的函数嵌入传递到同一个文件环境 V 中进行相似度计算，可以缓解不同文件环境造成的差异。\nEntropy-based Binary Analysis 用于识别文件环境 因为二进制文件中没有直接指示编译器和优化级别的信息，所以从信息理论的角度来理解二进制文件，并引入熵来识别二进制文件的编译器和优化级别 图 6 显示了来自 3 个文件环境的 12 个不同二进制文件的熵流。可以观察到，来自相同文件环境的熵流似乎是相似的，而来自不同文件环境的熵流却不同。使用熵流和熵理论，我们可以识别不同的编译器和优化。 使用残差神经网络 (ResNet) 作为分类器，并使用上述特征作为识别文件环境的输入。基本残块结构如图 7 所示。它由批量归一化和线性变换组成，激活函数为 ReLU。使用来自输入的标识映射的跳过连接被添加到基本剩余块输出中，这保留了函数语义，并有助于解决梯度消失问题。我们使用卷积层对输入进行采样，该层将 258 维输入转换为 64 维特征。在 16 层剩余基本块之后，我们使用线性预测和 softmax 函数进行多类分类。由于 Os 和 Ofast 分别是对 O2 和 O3 的增量优化，因此我们将 Os 和 Ofast 分别包含在 O2 和 O3 中。这里，softmax 的目标是 8 个类 (2 个编译器× 4 个优化)。熵分析帮助我们识别文件环境 (编译器和优化级别)，为后续的函数嵌入传输做准备。\nEntropy-based Adapter layer 为了计算来自不同文件环境的二进制函数的相似性，我们在 IRFM 之后提出了一个基于熵的适配器层。基于熵的适配器层作为映射 F，将不同文件环境中的函数嵌入传递到相同的中间文件环境 V 中，以缓解不同文件环境造成的差异。映射 F 既应保留函数语义，又应减轻因不同文件环境而产生的偏差。\n渐进搜索策略 现状 使用函数嵌入来搜索相似函数，这种属于粗粒度检测方法，导致较高的假阳性 使用匹配网络等方法在细粒度上计算每个函数对的相似性，结果好，但是计算成本高 方法： 提出了一种新的搜索策略，称为渐进式搜索策略，该策略包含两个子策略。首先，使用函数嵌入作为粗粒度搜索的全局摘要。其次，设计了候选函数的成对相似度校准，用细粒度信息补充函数嵌入，以保持漏洞检测的高精度\n函数嵌入搜索：为了在大型函数库中高效地检测相似函数，采用函数嵌入的欧式距离相似度对候选函数进行粗粒度检索，大大减小了细粒度检测的范围，减轻了计算负担。（算法 2 行） 相似度校准：它结合基本块、字符串常量和导入函数的信息，计算成对相似度得分，从中提取向量，并与函数级信息相结合，提高漏洞检测性能。 基本块级特征：如块嵌入分布和函数大小，可能会在函数级嵌入中丢失。（算法第 6 行）计算查询函数与其候选函数之间的基本块相似度，以补充块级信息 字符串常量特征：由于字符串常量和导入的函数在相似的函数对中是相同或相似的，它们的相似度也起到指示函数相似度的作用。（算法第 7 行） 导入函数：（算法第 8 行）使用 jaccard 指数计算两个导入函数集的相似度 在计算完上述三个向量后，我们将这些向量和函数嵌入搜索中的相似度 s 连接到向量 V 中。然后，我们将向量 V 输入前馈网络学习权重并预测最终函数相似度 s ‘。我们使用交叉熵损失函数来优化网络权值。最后，我们使用默认阈值 h 来过滤出与结果相似的函数。 评估 一对一比较 我们用一对一的函数相似度检测对 VulHawk 和基线的性能进行基准测试，这在之前的方法[27]，[34]，[41]，[55]中广泛执行。与他们的实验设置一样，我们为每个任务构建了一个由 50k 个正函数对和 50k 个负函数对组成的平衡评估集，以及一个由 1400 个正函数对和 140k 个负函数对组成的非平衡评估集。我们使用 (AUC) 作为测量值。AUC 是一个综合了所有可能分类阈值的模型的综合性能度量。表三显示了 VulHawk 与其他基线的比较结果。 如图所示，在所有实验设置中，VulHawk 在平衡集和非平衡集上的 AUC 得分均优于 SAFE、Asteria、GMN、PalmTree、Asm2Vec 和 Trex。\n一对多搜索 在本节中，我们将评估一对多搜索的性能。在研究[34]中，我们使用排名测量来评估模型在搜索应用程序中的性能，例如，漏洞搜索，它从一个大型数据库中检索候选函数。我们使用不同 K 阈值的召回率 ( Recall@K ) 作为指标，这是一个广泛使用的排名指标。我们使用不平衡集 (在第 IV-B 节中) 作为评价集。在评估中，模型计算每个查询函数与其正/负样本之间的相似性并进行排序。 我们收集了不同 top-K 结果下的召回率，并在图 9 中绘制了召回率与 k 的关系。结果表明，VulHawk 优于最先进的方法，在 XO 任务中获得了最好的 recall@1 ，为 0.935，在 XC+XO+XA 任务中获得了 0.879。在 XC+XO+XA 任务中，当检索到的结果数量超过 30 个时，每种方法的召回率趋于稳定，其中 VulHawk 在 0.994 左右达到 recall@30 , VulHawk- es 在 0.968 左右达到 recall@30 , VulHawk- s 在 0.988 左右达到 recall@30 , Trex 在 0.888 左右达到 recall@30 , SAFE 在 0.310 左右达到 recall@30 。XC+XO+XA 任务中 SAFE 的 recall@K 接近于随机概率 (K 100)，因为 SAFE 在跨架构任务中由于严重的 OOV 问题而不健壮，这在一对一的比较中已经得到了证明。在对大型函数库进行一对多搜索时，SAFE 的弱点被放大，只能得到 0.007 的 recall@1 。回答 r 问题 2: VulHawk 可以在大型函数库中准确地检索最佳候选函数。\n多对多匹配 多对多匹配用于在函数级测量两个给定二进制文件的相似性。作为他们的实验设置，我们为每个任务构造一个二进制对的评估集，并为每个二进制对生成最佳函数相似度匹配工具。我们在表 IV 中报告了每种工具在不同任务下的平均召回率和精度结果。 其中，基线在 XO 实验的 O0O3 中结果最低。在本实验中，VulHawk 的召回率为 0.876，比 SAFE、Asteria、Asm2Vec、BinDiff、PalmTree、GMN 和 Trex 的召回率分别提高了 385.9%、292.9%、208.6%、240.0%、211.6%、621.3%和 202.8%。有趣的是，VulHawk 最差的结果 (0.805) 是在 XC 实验中，而不是在 O0-O3 实验中。尽管如此，在 XC 实验中，VulHawk 仍然优于最先进的方法。O3 选项中，为了减小二进制函数的大小，提高效率，将 O0 选项中的冗余指令压缩为简洁的指令，强化了主要语义，去掉了函数的冗余语义，导致语义差异。VulHawk 使用简化指令提取二进制函数，并保留了主要语义，这有助于减轻优化级别的影响，使其能够适应交叉优化级别的实验。 图 10 用小提琴图展示了 XC、XA 和 XO 任务的查全率和查准率分布，我们在图上方标注了每种方法的平均结果。与 SAFE、BinDiff、Asteria、Asm2vec、PalmTree、GMN、Trex 相比，VulHawk 的召回率和精度概率分布更接近于 1 且更集中，而其他方法在不同场景下的结果分布分散且不稳定。这表明，VulHawk 的性能比其他基线更好，更稳定。 与一对一比较相比，多对多匹配的查全率和准确率较低，这是因为多对多匹配的负样本较多，错误匹配对会影响匹配算法的后续结果 (如匈牙利算法[25])。回答 RQ.3: VulHawk 可以用于在两个二进制文件之间匹配相似的函数，并且它在多对多匹配方面优于最先进的方法。\n运行时效率 我们评估了 VulHawk 在不同设置下的运行效率。给定一个函数，我们使用被评估模型提取特征并生成其函数嵌入，然后从存储库中检索前 10 个候选函数。记录时间是从提取特征到返回候选函数的相似度，每次测试测量十次，尽量减少意外因素。存储库大小设置为 103、104、105 和 106。 表 V 显示了在不同大小的存储库中搜索函数的时间成本及其吞吐量。吞吐量表示一秒钟内可以检索到的存储库函数的数量，它没有考虑嵌入生成的开销。结果表明，VulHawk 比 VulHawk- es 和 VulHawk- s 慢，这是因为 VulHawk 在嵌入生成过程中使用了基于熵的适配器，在搜索过程中使用了相似度校准。用较小的开销换取更高的精度和召回率是可以接受的。通过 GPU 加速，VulHawk 可以在大约 2 秒内从 106 个函数中搜索一个函数。回答 RQ.4: VulHawk 可以在大型函数库中保持高效率 (106)。\nAblation Study 基于熵的适配器：从表 III 可以看出，在 7 个一对一的功能比较任务中，VulHawkS 的 AUC 高于 VulHawk-ES。在图 9 中，VulHawk-S 在一对多搜索中获得了比 VulHawk-ES 更高的 recalls@K 。这些结果表明，VulHawk-S 的性能优于 VulHawkES，这表明性能的提升来自于基于熵的适配器的贡献，而不是额外的神经网络。基于熵的适配器将不同文件环境中的函数嵌入转移到相同的文件环境中，减轻了编译器和优化级别带来的差异。例如，在多对多匹配场景下，O0-O3 实验中，VulHawk-ES 的召回率为 0.793，而 VulHawk-S 通过基于熵的适配器缓解了不同文件环境造成的差异，召回率为 0.873。 相似度校准：从表 III 和图 9 可以看出，在一对一功能对比和一对多搜索场景下，VulHawk 的搜索结果优于 VulHawk- s。表四还显示，在多对多匹配场景中，VulHawk 比 VulHawkS 更精确。在 O0-O3 多对多匹配任务中，VulHawk 的精度从 0.593 提高到 0.818，这是因为 VulHawk 使用相似度校准从块级特征、字符串特征和导入函数中补充了函数相似度，使得相似度计算中考虑的信息更加全面，提高了检测精度。 文件环境识别 我们还评估了基于熵的文件环境识别的准确性。在这里，我们使用 10 倍交叉验证来分割所有二进制文件进行训练和评估，就像在传统的机器学习设置中一样。这些二进制文件来自不同的体系结构 (x86、arm 和 mips) 和不同的编译器 (GCC 和 Clang)。Pizzolotto 等人在函数字节上使用 CNN 模型和 LSTM 模型来识别文件环境。为了更好地演示我们的方法的性能，我们下载了他们预先训练好的模型，并将它们 (CNN 和 LSTM) 设置为比较。请注意，给定二进制文件的编译器和优化级别是未知的，并且在实践中是不同的，因此在评估一个参数 (例如编译器) 时，我们不会固定其他参数 (例如架构和优化级别) 以确保实用性。 图 11 显示了 VulHawk 等方法精度随时间的变化趋势。结果表明: (1) VulHawk 在编译识别和优化级别上均优于 CNN 和 LSTM。(2) VulHawk 的识别速度比 CNN 和 LSTM 的识别速度快。(3) VulHawk 的精度曲线稳定，而 CNN 和 LSTM 的精度曲线波动较大。这说明 VulHawk 在各种场景下更加泛化，而 CNN 和 LSTM 在某些情况下受到打击。我们深入分析如下。与 CNN 和 LSTM 相比，VulHawk 采用了包含二进制全局信息的熵流，而不是单个函数的原始字节，这使得函数的意外偏差对 VulHawk 影响不大。熵在不同的文件环境中保持明显的区别，而在原始字节上差异不明显。这使得 VulHawk 保持了较高的泛化性能，优于 CNN 和 LSTM。此外，VulHawk 在精度和效率上都优于 CNN 和 LSTM。由于 VulHawk 使用了一个强大的特征 (熵)，而且我们的模型比 CNN 和 LSTM 轻得多，例如，我们模型中的参数大小仅为 CNN 的 1.3%。 为了全面评估我们基于熵的文件环境识别，我们在不同架构 (x86、mips 和 arm)、文件大小 (小尺寸和大尺寸) 和文件类型 (库和可执行文件) 的各种场景中进行了实验。在这里，考虑到文件大小的分布，我们将小于 1024 KB 的文件视为小文件，反之则视为大文件。结果如图 12 所示，每个块都标注了分类比例。例如，在 O3 组预测中，95.4%被正确划分为 O3, 4.6%被划分为 O2，其中总体准确率为 96.2%。O0 选项实现了很高的精度，因为 O0 使用默认优化来减少编译时间，这与其他选项有很大不同。在 mips 和库文件中对 O2 和 O3 的识别达到了最差的结果，其中大多数错误识别集中在 O2 和 O3 的区别上。与 O0 相比，O3 选项增加了 285 个以上的优化，而 O3 只比 O2 多 3 个优化。因此，O2 和 O3 的双星具有高度相似的结构。由于来自 O2 和 O3 的二进制是高度相似的，这些错误识别是可以接受的，对二进制函数搜索的影响很小。当我们同时考虑 O2 和 O3 时，在所有情况下，区分它们与 O0 和 O1 的准确性都超过 90%。结果表明，我们的基于熵的文件环境识别在不同架构、文件大小和文件类型的各种场景下都是强大的。\n漏洞识别 。。。懒得看了，反正效果很好吧\n","wordCount":"752","inLanguage":"en","datePublished":"2023-06-11T02:01:58+05:30","dateModified":"2023-06-11T02:01:58+05:30","author":{"@type":"Person","name":"JUHUA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/vulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search/"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"https://examplesite.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://examplesite.com/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://examplesite.com/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://examplesite.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://examplesite.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://examplesite.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://examplesite.com/about/ title=about><span>about</span></a></li><li><a href=https://examplesite.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://examplesite.com/>Home</a>&nbsp;»&nbsp;<a href=https://examplesite.com/posts/>Posts</a></div><h1 class=post-title>VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search</h1><div class=post-meta><span title='2023-06-11 02:01:58 +0530 +0530'>June 11, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;752 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-11 02:01:58 +0530 +0530'>June 11, 2023</span>&nbsp;|&nbsp;时长: 4分钟&nbsp;|&nbsp;JUHUA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/1.%e5%ad%a6%e4%b9%a0/1.%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb/%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e8%af%91%e4%bc%98%e5%8c%96%e5%88%86%e6%9e%90/%e8%af%a6%e7%bb%86%e7%ac%94%e8%ae%b0/VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%91%98%e8%a6%81 aria-label=摘要>摘要</a></li><li><a href=#%e5%bc%95%e8%a8%80 aria-label=引言>引言</a></li><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89 aria-label=问题定义>问题定义</a></li><li><a href=#%e7%86%b5%e7%90%86%e8%ae%ba aria-label=熵理论>熵理论</a></li></ul></li><li><a href=#%e8%ae%be%e8%ae%a1 aria-label=设计>设计</a><ul><li><a href=#ir-%e5%87%bd%e6%95%b0%e6%a8%a1%e5%9e%8birfm aria-label="IR 函数模型（IRFM）">IR 函数模型（IRFM）</a><ul><li><a href=#tokenization aria-label=Tokenization>Tokenization</a></li><li><a href=#%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b aria-label=语言模型>语言模型</a></li><li><a href=#%e9%a2%84%e8%ae%ad%e7%bb%83%e4%bb%bb%e5%8a%a1 aria-label=预训练任务>预训练任务</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%b5%8c%e5%85%a5%e7%94%9f%e6%88%90 aria-label=函数嵌入生成>函数嵌入生成</a></li></ul></li><li><a href=#%e5%9f%ba%e4%ba%8e%e7%86%b5%e7%9a%84%e9%80%82%e9%85%8d%e5%99%a8 aria-label=基于熵的适配器>基于熵的适配器</a><ul><li><a href=#divide-and-conquer aria-label=Divide-and-conquer>Divide-and-conquer</a><ul><li><a href=#entropy-based-binary-analysis aria-label="Entropy-based Binary Analysis">Entropy-based Binary Analysis</a></li><li><a href=#entropy-based-adapter-layer aria-label="Entropy-based Adapter layer">Entropy-based Adapter layer</a></li></ul></li></ul></li><li><a href=#%e6%b8%90%e8%bf%9b%e6%90%9c%e7%b4%a2%e7%ad%96%e7%95%a5 aria-label=渐进搜索策略>渐进搜索策略</a></li></ul></li><li><a href=#%e8%af%84%e4%bc%b0 aria-label=评估>评估</a><ul><li><a href=#%e4%b8%80%e5%af%b9%e4%b8%80%e6%af%94%e8%be%83 aria-label=一对一比较>一对一比较</a></li><li><a href=#%e4%b8%80%e5%af%b9%e5%a4%9a%e6%90%9c%e7%b4%a2 aria-label=一对多搜索>一对多搜索</a></li><li><a href=#%e5%a4%9a%e5%af%b9%e5%a4%9a%e5%8c%b9%e9%85%8d aria-label=多对多匹配>多对多匹配</a></li><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%88%e7%8e%87 aria-label=运行时效率>运行时效率</a></li><li><a href=#ablation-study aria-label="Ablation Study">Ablation Study</a></li><li><a href=#%e6%96%87%e4%bb%b6%e7%8e%af%e5%a2%83%e8%af%86%e5%88%ab aria-label=文件环境识别>文件环境识别</a></li><li><a href=#%e6%bc%8f%e6%b4%9e%e8%af%86%e5%88%ab aria-label=漏洞识别>漏洞识别</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>中文译名：VulHawk：基于熵的二进制代码搜索的跨架构漏洞检测
作者：Zhenhao Luo
单位：国防科大
国家： #中国
年份： #2023年
来源： #NDSS会议
关键字： #二进制代码搜索
代码地址： <a href=https://github.com/RazorMegrez/VulHawk>https://github.com/RazorMegrez/VulHawk</a>
笔记建立时间： 2023-03-20 13:59</p><h1 id=摘要>摘要<a hidden class=anchor aria-hidden=true href=#摘要>#</a></h1><p>目的：对不同架构、不同编译器、不同优化级别编译的 IoT 固件映像进行二进制代码搜索来识别代码重用
方法：</p><ul><li>提出了一种新的中间表示函数模型，是一种用于跨体系结构二进制代码搜索的体系结构不确定模型<ul><li>将二进制代码提升为 IR，通过补充隐式操作数和删除冗余指令来保留二进制函数的主要语言</li><li>使用 NLP 和卷积生成函数嵌入</li><li>将编译器、架构和优化级别的组合称为一个文件环境，采用 divide-and-conquer 策略将 $C_N^2$ 个跨文件环境场景的相似性问题转化为 $N-1$ 个嵌入转化子问题。</li></ul></li><li>提出了一种基于熵的适配器，将不同文件环境中的函数嵌入传输到同一文件环境中，以缓解不同文件环境造成的差异</li><li>提出了一种渐进搜索策略<ul><li>用细粒度特征补充函数嵌入，以减少修补函数造成的误报</li></ul></li></ul><p>意义：提高检测代码重用带来的漏洞的效率
效果：VulHawk 的性能优于 Asm2Vec、Asteria、BinDiff、GMN、PalmTree、SAFE 和 Trex。</p><h1 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h1><p>现状：</p><ul><li>二进制代码搜索方法不够健壮，不能跨平台<ul><li>Asm2Vec[10]、DeepBinDiff[11]和 PalmTree[27]使用自然语言处理 (NLP) 技术取得了令人鼓舞的结果（不能跨平台）</li><li>InnerEye[60]将来自不同 isa 的二进制作为不同的自然语言，并使用神经机器翻译来计算二进制代码的相似度。SAFE[35]使用来自多个 isa 的二进制来训练其语言模型，以跨体系结构搜索二进制代码。（严重依赖于训练数据，很难实现多个 isa）</li><li>将特定于体系结构的二进制代码提升为与体系结构无关的中间表示 (IR) 是解决物联网固件中跨体系结构挑战的有效方法。但是 IR 和自然语言有本质区别。</li></ul></li><li>相同源码经过不同优化级别的编译器编译后得到的二进制文件语义相似但结构不同<ul><li>在本文中，我们考虑了 3 种架构 (x86、arm 和 mips)、2 种字大小 (32 位和 64 位)、2 个编译器 (Clang 和 GCC) 和 6 个优化级别 (O0、O1、O2、O3、Os 和 Ofast)，总共 72 种组合 (3 × 2 × 2 × 6)。</li></ul></li></ul><p>本文提出了一种新的跨架构二进制代码搜索方法 VulHawk</p><ul><li>新的中间表示函数模型 (IRFM)——来生成健壮的函数嵌入——解决跨架构和指令简化</li><li>部署了一个基于熵的适配器——对不同编译器、体系结构和优化级别的二进制文件进行处理，缓解不同环境造成的差异</li><li>渐进搜索策略来搜索候选函数</li><li>提出一种相似度标定方法——减少误报</li></ul><h1 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h1><h2 id=问题定义>问题定义<a hidden class=anchor aria-hidden=true href=#问题定义>#</a></h2><p>一个有效的跨架构的二进制代码搜索需要实现：</p><ul><li>支持跨架构</li><li>支持跨编译器</li><li>支持跨优化</li><li>高精度和效率</li></ul><h2 id=熵理论>熵理论<a hidden class=anchor aria-hidden=true href=#熵理论>#</a></h2><p>香农的熵理论可以用来衡量系统中的随机性和平均信息量
通过熵分析，我们可以在深入研究系统之前预先了解系统中的平均信息量。在二进制代码搜索任务中，我们通过二进制文件熵得到二进制文件的信息分布，它可以推断出二进制文件的编译器和优化级别等信息。这有助于我们的模型为不同的输入二进制选择合适的参数。</p><h1 id=设计>设计<a hidden class=anchor aria-hidden=true href=#设计>#</a></h1><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230320155928.png alt=image.png></p><h2 id=ir-函数模型irfm>IR 函数模型（IRFM）<a hidden class=anchor aria-hidden=true href=#ir-函数模型irfm>#</a></h2><p>将二进制代码的 IR 作为中间表示函数模型 (IRFM)（基于 RoBERTa 模型）的输入，输出是 IR 的词嵌入。
IRFM 将 IR 函数嵌入到高维嵌入空间中，使得语义相似函数的嵌入在数值空间中更加紧密。</p><h3 id=tokenization>Tokenization<a hidden class=anchor aria-hidden=true href=#tokenization>#</a></h3><ul><li>将一条指令分割为一个操作码和三个操作数</li><li>用特殊标记 addr 来规范地址</li><li>对于 OOV （Out-Of-Vocabulary)）问题，作者引入 16 个根操作数，表内的操作数就使用自己的 token，非表内操作数就使用对应的根 token<ul><li>在预训练阶段，我们将频率小于 100 次的令牌替换为其根操作数令牌，以构建根操作数令牌嵌入。</li></ul></li></ul><h3 id=语言模型>语言模型<a hidden class=anchor aria-hidden=true href=#语言模型>#</a></h3><p>IRFM 基于 RoBERTa 模型，但是 IR 和自然语言有所不同，所以作者进行了部分改动</p><ul><li>Token 类型层<ul><li>使用令牌类型层来帮助 IRFM 区分操作码和操作数。将令牌分为三种类型: 操作码、操作数和其他。其他类型包括没有实际语义的特殊标记。</li></ul></li><li>指令简化<ul><li>二进制代码包含 EFLAGS (即标志寄存器) 作为隐式操作数。不考虑 EFLAGS，重要的语义会丢失，考虑所有的 EFLAGS，冗余的 eflag 不仅会引入额外的开销，而且可能会模糊二进制代码的主要语义。</li><li>所以只考虑使用过的 eflags，通过 IR 将每个隐式操作数指令的赋值转换为实赋值指令，并将其使用的 EFLAGS 保存为指令序列</li><li>如下图所示 a 到 b 删除了没有使用到的寄存器和标志寄存器，b 到 c 又对值传递进行了优化（化简）</li><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230320163538.png alt=image.png></li><li>提出了一种基于 def-use 关系的指令简化方法<ul><li>标记重要指令（使用松散规则，以确保不会错误地删除主语义）：<ul><li>目标操作数为内存地址的赋值指令（因为全局变量和局部变量存储在内存中而不是寄存器中）</li><li>在所有路径的返回指令附近根据调用约定标记特定的寄存器（因为返回值通常存储在特定的寄存器）</li></ul></li><li>修剪未使用的指令<ul><li>将其定义的寄存器或 EFLAGS 未在后续指令中使用的指令视为未使用的指令</li></ul></li><li>优化冗余指令（值传递指令）</li></ul></li></ul></li></ul><h3 id=预训练任务>预训练任务<a hidden class=anchor aria-hidden=true href=#预训练任务>#</a></h3><p>在训练阶段，我们使用 Masked Language Model (MLM)、根操作数预测 (ROP) 和相邻块预测 (ABP) 进行预训练。</p><ul><li>Masked Language Model<ul><li>我们引入了 MLM 模型来理解之间的关系，并建立合适的词嵌入。</li></ul></li><li>根操作数预测<ul><li>用于解决 OOV 问题，为 OOV 操作数匹配根操作数 token</li></ul></li><li>邻块预测<ul><li>因为数据流的存在，所以基本块数顺序敏感的，ABP 预训练是为了让模型捕获这种数据流关系</li><li>具体来说，给定两个基本区块 A 和 B，其中 B 是 A 的后继区块，变量 x 定义在区块 A 中，变量 x 使用在区块 B 中，我们将 A-B 的顺序标记为正，B-A 的顺序标记为负。注意，A 和 B 不是同一个块，A 也不是 B 的后继块。另外，我们不认为这些情况下 A 和 B 只有控制流关系而没有数据流关系。因为如果不支持数据流关系，块的顺序也可能颠倒。我们将 IRFM 中令牌[cls]的最终隐藏状态输入到 ABP 头中，这是一个线性变换，以识别输入的两个微码序列是否正序。</li></ul></li></ul><h3 id=函数嵌入生成>函数嵌入生成<a hidden class=anchor aria-hidden=true href=#函数嵌入生成>#</a></h3><p>首先生成基本块嵌入</p><ul><li>对于输入的 IR 块，IRFM 转化编码器输出隐藏状态序列，然后在倒数第二层的隐藏状态上使用均值池来生成基本块嵌入。（因为研究表明倒数第二层的隐藏状态比最后一层的隐藏状态具有更强的泛化能力。）</li></ul><p>集成基本块嵌入和 cfg 来生成函数嵌入</p><ul><li>使用 GCNs 捕获 CFG 结构，将二进制函数视为属性图，其中它们的基本块是图中的节点，它们的嵌入是节点的属性。我们将属性控制流图 (acfg) 输入到 GCN 层。</li></ul><h2 id=基于熵的适配器>基于熵的适配器<a hidden class=anchor aria-hidden=true href=#基于熵的适配器>#</a></h2><h3 id=divide-and-conquer>Divide-and-conquer<a hidden class=anchor aria-hidden=true href=#divide-and-conquer>#</a></h3><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230320172612.png alt=image.png>
图 5 显示了在嵌入空间中匹配相似函数的示例。可以看到混合文件环境的文件经过适配器后进行了统一。（可以理解为一个翻译器）
首先，我们将混合文件环境的嵌入空间拆分为多个嵌入子空间。
其次，选择其中一个文件环境 V 作为中间文件环境，将 N 个具有 C2 N 个场景的文件环境中的函数相似度问题划分为 N−1 个子函数嵌入传递问题。
最后，我们使用经过训练的适配器将不同文件环境的函数嵌入传递到同一个文件环境 V 中进行相似度计算，可以缓解不同文件环境造成的差异。</p><h4 id=entropy-based-binary-analysis>Entropy-based Binary Analysis<a hidden class=anchor aria-hidden=true href=#entropy-based-binary-analysis>#</a></h4><p>用于识别文件环境
因为二进制文件中没有直接指示编译器和优化级别的信息，所以从信息理论的角度来理解二进制文件，并引入熵来识别二进制文件的编译器和优化级别
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230320173843.png alt=image.png>
图 6 显示了来自 3 个文件环境的 12 个不同二进制文件的熵流。可以观察到，来自相同文件环境的熵流似乎是相似的，而来自不同文件环境的熵流却不同。使用熵流和熵理论，我们可以识别不同的编译器和优化。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230320174104.png alt=image.png>
使用残差神经网络 (ResNet) 作为分类器，并使用上述特征作为识别文件环境的输入。基本残块结构如图 7 所示。它由批量归一化和线性变换组成，激活函数为 ReLU。使用来自输入的标识映射的跳过连接被添加到基本剩余块输出中，这保留了函数语义，并有助于解决梯度消失问题。我们使用卷积层对输入进行采样，该层将 258 维输入转换为 64 维特征。在 16 层剩余基本块之后，我们使用线性预测和 softmax 函数进行多类分类。由于 Os 和 Ofast 分别是对 O2 和 O3 的增量优化，因此我们将 Os 和 Ofast 分别包含在 O2 和 O3 中。这里，softmax 的目标是 8 个类 (2 个编译器× 4 个优化)。熵分析帮助我们识别文件环境 (编译器和优化级别)，为后续的函数嵌入传输做准备。</p><h4 id=entropy-based-adapter-layer>Entropy-based Adapter layer<a hidden class=anchor aria-hidden=true href=#entropy-based-adapter-layer>#</a></h4><p>为了计算来自不同文件环境的二进制函数的相似性，我们在 IRFM 之后提出了一个基于熵的适配器层。基于熵的适配器层作为映射 F，将不同文件环境中的函数嵌入传递到相同的中间文件环境 V 中，以缓解不同文件环境造成的差异。映射 F 既应保留函数语义，又应减轻因不同文件环境而产生的偏差。</p><h2 id=渐进搜索策略>渐进搜索策略<a hidden class=anchor aria-hidden=true href=#渐进搜索策略>#</a></h2><p>现状
使用函数嵌入来搜索相似函数，这种属于粗粒度检测方法，导致较高的假阳性
使用匹配网络等方法在细粒度上计算每个函数对的相似性，结果好，但是计算成本高
方法：
提出了一种新的搜索策略，称为渐进式搜索策略，该策略包含两个子策略。首先，使用函数嵌入作为粗粒度搜索的全局摘要。其次，设计了候选函数的成对相似度校准，用细粒度信息补充函数嵌入，以保持漏洞检测的高精度</p><ul><li>函数嵌入搜索：为了在大型函数库中高效地检测相似函数，采用函数嵌入的欧式距离相似度对候选函数进行粗粒度检索，大大减小了细粒度检测的范围，减轻了计算负担。（算法 2 行）</li><li>相似度校准：它结合基本块、字符串常量和导入函数的信息，计算成对相似度得分，从中提取向量，并与函数级信息相结合，提高漏洞检测性能。<ul><li>基本块级特征：如块嵌入分布和函数大小，可能会在函数级嵌入中丢失。（算法第 6 行）计算查询函数与其候选函数之间的基本块相似度，以补充块级信息</li><li>字符串常量特征：由于字符串常量和导入的函数在相似的函数对中是相同或相似的，它们的相似度也起到指示函数相似度的作用。（算法第 7 行）</li><li>导入函数：（算法第 8 行）使用 jaccard 指数计算两个导入函数集的相似度
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321103552.png alt=image.png>
在计算完上述三个向量后，我们将这些向量和函数嵌入搜索中的相似度 s 连接到向量 V 中。然后，我们将向量 V 输入前馈网络学习权重并预测最终函数相似度 s &lsquo;。我们使用交叉熵损失函数来优化网络权值。最后，我们使用默认阈值 h 来过滤出与结果相似的函数。</li></ul></li></ul><h1 id=评估>评估<a hidden class=anchor aria-hidden=true href=#评估>#</a></h1><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321110209.png alt=image.png></p><h2 id=一对一比较>一对一比较<a hidden class=anchor aria-hidden=true href=#一对一比较>#</a></h2><p>我们用一对一的函数相似度检测对 VulHawk 和基线的性能进行基准测试，这在之前的方法[27]，[34]，[41]，[55]中广泛执行。与他们的实验设置一样，我们为每个任务构建了一个由 50k 个正函数对和 50k 个负函数对组成的平衡评估集，以及一个由 1400 个正函数对和 140k 个负函数对组成的非平衡评估集。我们使用 (AUC) 作为测量值。AUC 是一个综合了所有可能分类阈值的模型的综合性能度量。表三显示了 VulHawk 与其他基线的比较结果。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321105952.png alt=image.png>
如图所示，在所有实验设置中，VulHawk 在平衡集和非平衡集上的 AUC 得分均优于 SAFE、Asteria、GMN、PalmTree、Asm2Vec 和 Trex。</p><h2 id=一对多搜索>一对多搜索<a hidden class=anchor aria-hidden=true href=#一对多搜索>#</a></h2><p>在本节中，我们将评估一对多搜索的性能。在研究[34]中，我们使用排名测量来评估模型在搜索应用程序中的性能，例如，漏洞搜索，它从一个大型数据库中检索候选函数。我们使用不同 K 阈值的召回率 ( Recall@K ) 作为指标，这是一个广泛使用的排名指标。我们使用不平衡集 (在第 IV-B 节中) 作为评价集。在评估中，模型计算每个查询函数与其正/负样本之间的相似性并进行排序。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321110909.png alt=image.png>
我们收集了不同 top-K 结果下的召回率，并在图 9 中绘制了召回率与 k 的关系。结果表明，VulHawk 优于最先进的方法，在 XO 任务中获得了最好的 recall@1 ，为 0.935，在 XC+XO+XA 任务中获得了 0.879。在 XC+XO+XA 任务中，当检索到的结果数量超过 30 个时，每种方法的召回率趋于稳定，其中 VulHawk 在 0.994 左右达到 recall@30 , VulHawk- es 在 0.968 左右达到 recall@30 , VulHawk- s 在 0.988 左右达到 recall@30 , Trex 在 0.888 左右达到 recall@30 , SAFE 在 0.310 左右达到 recall@30 。XC+XO+XA 任务中 SAFE 的 recall@K 接近于随机概率 (K 100)，因为 SAFE 在跨架构任务中由于严重的 OOV 问题而不健壮，这在一对一的比较中已经得到了证明。在对大型函数库进行一对多搜索时，SAFE 的弱点被放大，只能得到 0.007 的 recall@1 。回答 r 问题 2: VulHawk 可以在大型函数库中准确地检索最佳候选函数。</p><h2 id=多对多匹配>多对多匹配<a hidden class=anchor aria-hidden=true href=#多对多匹配>#</a></h2><p>多对多匹配用于在函数级测量两个给定二进制文件的相似性。作为他们的实验设置，我们为每个任务构造一个二进制对的评估集，并为每个二进制对生成最佳函数相似度匹配工具。我们在表 IV 中报告了每种工具在不同任务下的平均召回率和精度结果。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321111855.png alt=image.png>
其中，基线在 XO 实验的 O0O3 中结果最低。在本实验中，VulHawk 的召回率为 0.876，比 SAFE、Asteria、Asm2Vec、BinDiff、PalmTree、GMN 和 Trex 的召回率分别提高了 385.9%、292.9%、208.6%、240.0%、211.6%、621.3%和 202.8%。有趣的是，VulHawk 最差的结果 (0.805) 是在 XC 实验中，而不是在 O0-O3 实验中。尽管如此，在 XC 实验中，VulHawk 仍然优于最先进的方法。O3 选项中，为了减小二进制函数的大小，提高效率，将 O0 选项中的冗余指令压缩为简洁的指令，强化了主要语义，去掉了函数的冗余语义，导致语义差异。VulHawk 使用简化指令提取二进制函数，并保留了主要语义，这有助于减轻优化级别的影响，使其能够适应交叉优化级别的实验。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321112306.png alt=image.png>
图 10 用小提琴图展示了 XC、XA 和 XO 任务的查全率和查准率分布，我们在图上方标注了每种方法的平均结果。与 SAFE、BinDiff、Asteria、Asm2vec、PalmTree、GMN、Trex 相比，VulHawk 的召回率和精度概率分布更接近于 1 且更集中，而其他方法在不同场景下的结果分布分散且不稳定。这表明，VulHawk 的性能比其他基线更好，更稳定。
与一对一比较相比，多对多匹配的查全率和准确率较低，这是因为多对多匹配的负样本较多，错误匹配对会影响匹配算法的后续结果 (如匈牙利算法[25])。回答 RQ.3: VulHawk 可以用于在两个二进制文件之间匹配相似的函数，并且它在多对多匹配方面优于最先进的方法。</p><h2 id=运行时效率>运行时效率<a hidden class=anchor aria-hidden=true href=#运行时效率>#</a></h2><p>我们评估了 VulHawk 在不同设置下的运行效率。给定一个函数，我们使用被评估模型提取特征并生成其函数嵌入，然后从存储库中检索前 10 个候选函数。记录时间是从提取特征到返回候选函数的相似度，每次测试测量十次，尽量减少意外因素。存储库大小设置为 103、104、105 和 106。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321112441.png alt=image.png>
表 V 显示了在不同大小的存储库中搜索函数的时间成本及其吞吐量。吞吐量表示一秒钟内可以检索到的存储库函数的数量，它没有考虑嵌入生成的开销。结果表明，VulHawk 比 VulHawk- es 和 VulHawk- s 慢，这是因为 VulHawk 在嵌入生成过程中使用了基于熵的适配器，在搜索过程中使用了相似度校准。用较小的开销换取更高的精度和召回率是可以接受的。通过 GPU 加速，VulHawk 可以在大约 2 秒内从 106 个函数中搜索一个函数。回答 RQ.4: VulHawk 可以在大型函数库中保持高效率 (106)。</p><h2 id=ablation-study>Ablation Study<a hidden class=anchor aria-hidden=true href=#ablation-study>#</a></h2><ul><li>基于熵的适配器：从表 III 可以看出，在 7 个一对一的功能比较任务中，VulHawkS 的 AUC 高于 VulHawk-ES。在图 9 中，VulHawk-S 在一对多搜索中获得了比 VulHawk-ES 更高的 recalls@K 。这些结果表明，VulHawk-S 的性能优于 VulHawkES，这表明性能的提升来自于基于熵的适配器的贡献，而不是额外的神经网络。基于熵的适配器将不同文件环境中的函数嵌入转移到相同的文件环境中，减轻了编译器和优化级别带来的差异。例如，在多对多匹配场景下，O0-O3 实验中，VulHawk-ES 的召回率为 0.793，而 VulHawk-S 通过基于熵的适配器缓解了不同文件环境造成的差异，召回率为 0.873。</li><li>相似度校准：从表 III 和图 9 可以看出，在一对一功能对比和一对多搜索场景下，VulHawk 的搜索结果优于 VulHawk- s。表四还显示，在多对多匹配场景中，VulHawk 比 VulHawkS 更精确。在 O0-O3 多对多匹配任务中，VulHawk 的精度从 0.593 提高到 0.818，这是因为 VulHawk 使用相似度校准从块级特征、字符串特征和导入函数中补充了函数相似度，使得相似度计算中考虑的信息更加全面，提高了检测精度。</li></ul><h2 id=文件环境识别>文件环境识别<a hidden class=anchor aria-hidden=true href=#文件环境识别>#</a></h2><p>我们还评估了基于熵的文件环境识别的准确性。在这里，我们使用 10 倍交叉验证来分割所有二进制文件进行训练和评估，就像在传统的机器学习设置中一样。这些二进制文件来自不同的体系结构 (x86、arm 和 mips) 和不同的编译器 (GCC 和 Clang)。Pizzolotto 等人在函数字节上使用 CNN 模型和 LSTM 模型来识别文件环境。为了更好地演示我们的方法的性能，我们下载了他们预先训练好的模型，并将它们 (CNN 和 LSTM) 设置为比较。请注意，给定二进制文件的编译器和优化级别是未知的，并且在实践中是不同的，因此在评估一个参数 (例如编译器) 时，我们不会固定其他参数 (例如架构和优化级别) 以确保实用性。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321113140.png alt=image.png>
图 11 显示了 VulHawk 等方法精度随时间的变化趋势。结果表明: (1) VulHawk 在编译识别和优化级别上均优于 CNN 和 LSTM。(2) VulHawk 的识别速度比 CNN 和 LSTM 的识别速度快。(3) VulHawk 的精度曲线稳定，而 CNN 和 LSTM 的精度曲线波动较大。这说明 VulHawk 在各种场景下更加泛化，而 CNN 和 LSTM 在某些情况下受到打击。我们深入分析如下。与 CNN 和 LSTM 相比，VulHawk 采用了包含二进制全局信息的熵流，而不是单个函数的原始字节，这使得函数的意外偏差对 VulHawk 影响不大。熵在不同的文件环境中保持明显的区别，而在原始字节上差异不明显。这使得 VulHawk 保持了较高的泛化性能，优于 CNN 和 LSTM。此外，VulHawk 在精度和效率上都优于 CNN 和 LSTM。由于 VulHawk 使用了一个强大的特征 (熵)，而且我们的模型比 CNN 和 LSTM 轻得多，例如，我们模型中的参数大小仅为 CNN 的 1.3%。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230321113508.png alt=image.png>
为了全面评估我们基于熵的文件环境识别，我们在不同架构 (x86、mips 和 arm)、文件大小 (小尺寸和大尺寸) 和文件类型 (库和可执行文件) 的各种场景中进行了实验。在这里，考虑到文件大小的分布，我们将小于 1024 KB 的文件视为小文件，反之则视为大文件。结果如图 12 所示，每个块都标注了分类比例。例如，在 O3 组预测中，95.4%被正确划分为 O3, 4.6%被划分为 O2，其中总体准确率为 96.2%。O0 选项实现了很高的精度，因为 O0 使用默认优化来减少编译时间，这与其他选项有很大不同。在 mips 和库文件中对 O2 和 O3 的识别达到了最差的结果，其中大多数错误识别集中在 O2 和 O3 的区别上。与 O0 相比，O3 选项增加了 285 个以上的优化，而 O3 只比 O2 多 3 个优化。因此，O2 和 O3 的双星具有高度相似的结构。由于来自 O2 和 O3 的二进制是高度相似的，这些错误识别是可以接受的，对二进制函数搜索的影响很小。当我们同时考虑 O2 和 O3 时，在所有情况下，区分它们与 O0 和 O1 的准确性都超过 90%。结果表明，我们的基于熵的文件环境识别在不同架构、文件大小和文件类型的各种场景下都是强大的。</p><h2 id=漏洞识别>漏洞识别<a hidden class=anchor aria-hidden=true href=#漏洞识别>#</a></h2><p>。。。懒得看了，反正效果很好吧</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://examplesite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></li></ul><nav class=paginav><a class=prev href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/neuralci-%E5%A4%8D%E7%8E%B0/><span class=title>« Prev</span><br><span>NeuralCI 复现</span></a>
<a class=next href=https://examplesite.com/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/%E5%A4%8D%E7%8E%B0/vulhawk-%E5%A4%8D%E7%8E%B0/><span class=title>Next »</span><br><span>VulHawk 复现</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on twitter" href="https://twitter.com/intent/tweet/?text=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f&amp;title=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search&amp;summary=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search&amp;source=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f&title=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on whatsapp" href="https://api.whatsapp.com/send?text=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search%20-%20https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share VulHawk Cross-architecture Vulnerability Detection with Entropy-based Binary Code Search on telegram" href="https://telegram.me/share/url?text=VulHawk%20Cross-architecture%20Vulnerability%20Detection%20with%20Entropy-based%20Binary%20Code%20Search&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f1.%25E8%25AE%25BA%25E6%2596%2587%25E9%2598%2585%25E8%25AF%25BB%2f%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E7%25BC%2596%25E8%25AF%2591%25E4%25BC%2598%25E5%258C%2596%25E5%2588%2586%25E6%259E%2590%2f%25E8%25AF%25A6%25E7%25BB%2586%25E7%25AC%2594%25E8%25AE%25B0%2fvulhawk-cross-architecture-vulnerability-detection-with-entropy-based-binary-code-search%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://examplesite.com/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>