<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>南大软件分析第十二节——Pointer Analysis - Context Sensitivity II - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 本节讲上下文敏感的过程间指针分析的算法 Context Sensitive Pointer Analysis：Algorithms C.S.和 C.I.的算法本质上没有什么区别，基本上就是把对象、变量前加了上下文的标识 唯一的区别在于 ProcessCall 中添加了 select 方法来找到目标函数 m 的上下文标识。 select 方法的细节在后面详细讲。
Context Sensitivity Variants 上下文的生成主要有三种策略：
call-site sensitivity object sensitivity type sensitivity call-site sensitivity call-site sensitivity 的策略如上图所示，就是在原来上下文链的基础上，把调用点处的上下文加上去。 下图是例子。但是这样的分析策略带来了一个问题，就是图中 15 行，bar 方法内又调用自己，那么这样分析就不会终止，就会生成一个无穷无尽的上下文链。并且在实际分析程序中，即使没有想图中这样的情况，但是因为程序本身就很复杂，生成的上下文链也会很长，这样就会影响分析性能。 所以，call-site sensitivity 设定了上下文链的长度最长为 k，因此它又被称为 k-CFA。 设置了长度限制可以
确保指针分析算法的终止 避免在实际分析中生成过长的上下文链 具体的操作就是对于生成的上下文链，如果长度大于 k，那么就只保留最后 k 个上下文。（在实际分析中，k 通常小于等于 3，并且在函数的上下文通常取2，堆上下文通常取1 的时候效果比较好） 这里老师举了个例子，还是挺绕的，建议去看看视频" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="南大软件分析第十二节——Pointer Analysis - Context Sensitivity II" />
<meta property="og:description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 本节讲上下文敏感的过程间指针分析的算法 Context Sensitive Pointer Analysis：Algorithms C.S.和 C.I.的算法本质上没有什么区别，基本上就是把对象、变量前加了上下文的标识 唯一的区别在于 ProcessCall 中添加了 select 方法来找到目标函数 m 的上下文标识。 select 方法的细节在后面详细讲。
Context Sensitivity Variants 上下文的生成主要有三种策略：
call-site sensitivity object sensitivity type sensitivity call-site sensitivity call-site sensitivity 的策略如上图所示，就是在原来上下文链的基础上，把调用点处的上下文加上去。 下图是例子。但是这样的分析策略带来了一个问题，就是图中 15 行，bar 方法内又调用自己，那么这样分析就不会终止，就会生成一个无穷无尽的上下文链。并且在实际分析程序中，即使没有想图中这样的情况，但是因为程序本身就很复杂，生成的上下文链也会很长，这样就会影响分析性能。 所以，call-site sensitivity 设定了上下文链的长度最长为 k，因此它又被称为 k-CFA。 设置了长度限制可以
确保指针分析算法的终止 避免在实际分析中生成过长的上下文链 具体的操作就是对于生成的上下文链，如果长度大于 k，那么就只保留最后 k 个上下文。（在实际分析中，k 通常小于等于 3，并且在函数的上下文通常取2，堆上下文通常取1 的时候效果比较好） 这里老师举了个例子，还是挺绕的，建议去看看视频" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82pointer-analysis-context-sensitivity-ii/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T02:01:58+05:30" />
<meta property="article:modified_time" content="2023-06-11T02:01:58+05:30" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="南大软件分析第十二节——Pointer Analysis - Context Sensitivity II"/>
<meta name="twitter:description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 本节讲上下文敏感的过程间指针分析的算法 Context Sensitive Pointer Analysis：Algorithms C.S.和 C.I.的算法本质上没有什么区别，基本上就是把对象、变量前加了上下文的标识 唯一的区别在于 ProcessCall 中添加了 select 方法来找到目标函数 m 的上下文标识。 select 方法的细节在后面详细讲。
Context Sensitivity Variants 上下文的生成主要有三种策略：
call-site sensitivity object sensitivity type sensitivity call-site sensitivity call-site sensitivity 的策略如上图所示，就是在原来上下文链的基础上，把调用点处的上下文加上去。 下图是例子。但是这样的分析策略带来了一个问题，就是图中 15 行，bar 方法内又调用自己，那么这样分析就不会终止，就会生成一个无穷无尽的上下文链。并且在实际分析程序中，即使没有想图中这样的情况，但是因为程序本身就很复杂，生成的上下文链也会很长，这样就会影响分析性能。 所以，call-site sensitivity 设定了上下文链的长度最长为 k，因此它又被称为 k-CFA。 设置了长度限制可以
确保指针分析算法的终止 避免在实际分析中生成过长的上下文链 具体的操作就是对于生成的上下文链，如果长度大于 k，那么就只保留最后 k 个上下文。（在实际分析中，k 通常小于等于 3，并且在函数的上下文通常取2，堆上下文通常取1 的时候效果比较好） 这里老师举了个例子，还是挺绕的，建议去看看视频"/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">南大软件分析第十二节——Pointer Analysis - Context Sensitivity II</h1>
			<div class="meta">Posted on Jun 11, 2023</div>
		</div>
		

		<section class="body">
			<p>视频：<a href="https://www.bilibili.com/video/BV1fb4y1i7HY/?spm_id_from=333.788&amp;vd_source=a3f6a4e5f57d8b5aa5eea112e1eeef1f">南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili</a>
课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">Static Program Analysis | Tai-e (pascal-lab.net)</a>
笔记参考：<a href="https://www.jianshu.com/p/5ab79839f686">【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com)</a>
<a href="https://blog.csdn.net/panhewu9919/article/details/106007155?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-106007155-blog-105689689.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-106007155-blog-105689689.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3">(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析</a>
PPT：<a href="https://cs.nju.edu.cn/tiantan/software-analysis/PTA-CS.pdf">Pointer Analysis: Context Sensitivity (nju.edu.cn)</a>
本节讲上下文敏感的过程间指针分析的算法
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409150746.png" alt=""></p>
<h2 id="context-sensitive-pointer-analysisalgorithms">Context Sensitive Pointer Analysis：Algorithms</h2>
<p>C.S.和 C.I.的算法本质上没有什么区别，基本上就是把对象、变量前加了上下文的标识
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410180712.png" alt="image.png">
唯一的区别在于 ProcessCall 中添加了 select 方法来找到目标函数 m 的上下文标识。
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410181406.png" alt="image.png"></p>
<p>select 方法的细节在后面详细讲。</p>
<h2 id="context-sensitivity-variants">Context Sensitivity Variants</h2>
<p>上下文的生成主要有三种策略：</p>
<ul>
<li>call-site sensitivity</li>
<li>object sensitivity</li>
<li>type sensitivity</li>
</ul>
<h4 id="call-site-sensitivity">call-site sensitivity</h4>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410181558.png" alt="image.png">
call-site sensitivity 的策略如上图所示，就是在原来上下文链的基础上，把调用点处的上下文加上去。
下图是例子。但是这样的分析策略带来了一个问题，就是图中 15 行，bar 方法内又调用自己，那么这样分析就不会终止，就会生成一个无穷无尽的上下文链。并且在实际分析程序中，即使没有想图中这样的情况，但是因为程序本身就很复杂，生成的上下文链也会很长，这样就会影响分析性能。
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410181720.png" alt="image.png">
所以，call-site sensitivity 设定了上下文链的长度最长为 k，因此它又被称为 k-CFA。
设置了长度限制可以</p>
<ul>
<li>确保指针分析算法的终止</li>
<li>避免在实际分析中生成过长的上下文链</li>
</ul>
<p>具体的操作就是对于生成的上下文链，如果长度大于 k，那么就只保留最后 k 个上下文。（在实际分析中，k 通常小于等于 3，并且在函数的上下文通常取2，堆上下文通常取1 的时候效果比较好）
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230410182333.png" alt="image.png">
这里老师举了个例子，还是挺绕的，建议去看看视频</p>
<h3 id="object-sensitivity">object sensitivity</h3>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411152934.png" alt="image.png">
基于对象的上下文敏感就是不适用行号作为上下文，而是用 receive object 作为上下文敏感链。
举例：<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411153222.png" alt="image.png">
如上图所示，1-object 的 object sensitivity。这样的优势是什么呢，如下图所示：
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411153238.png" alt="image.png">
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411153248.png" alt="image.png">
call-site 的 sensitivity 在 12 行处汇聚了 5 和 6 行调用点的数据流，出现了错误。但是用 2-call-site 的 call-site sensitivity 可以解决这个问题。
但其实 call-site 上下文敏感和 object 上下文敏感半斤八两，如下图所示
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230411153455.png" alt="image.png">
理论上他们两个没啥可比性，但是在实践中对于 OO 语言，object sensitivity 无论是精准度还是性能都优于 call-site sensitivity
最后老师还讲了一个类型上下文敏感，基于创建点所在的类型，是基于对象敏感粗粒度的抽象，精度较低。是对 object sensitivity 的抽象，精度要弱于 object。</p>

		</section>

		<div class="post-tags">
			
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
