<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>南大软件分析第十一节——Pointer Analysis - Context Sensitivity I - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 上下文不敏感带来的问题 对于上述这段代码，当我们不考虑上下文去处理第 5、6 行的 id 函数调用的时候，id 的参数和返回值会和两次调用的参数和返回值杂糅在一起，这样假如在进行常量传播的时候，变量 i 就会被分析为 NAC，这是不对的。所以要对函数调用添加上下文，这样去分析第 7 行的时候 get 指向的就只有对象 One 里面的 get 函数
Introduction btw 上下文不敏感的英文是 contex insensitivity，缩写是 C.I. 上下文敏感的英文是 contex sensitivity，缩写是 C.S.
目前 oldest 和 best-know 的上下文敏感策略是 call-site sensitivity（call-string） 使用 call site 链来表示每个方法的上下文（非重点） cloning-based 上下文敏感（最直观的方法去实现上下文敏感）、 每个上下文就会对变量和方法进行一次克隆 上下文敏感的堆 OO 程序是典型的堆敏感，因为程序会频繁的修改堆，所以也要对堆抽象添加上下文
老师在这里进行举例表示上下文敏感和堆的上下文敏感缺一不可
不考虑堆的上下文敏感，只考虑分析的上下文敏感
我们可以看到虽然分析的时候考虑了上下文敏感，但是当调用方法中存在 new 语句的时候 （堆操作），不考虑堆的 C." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="南大软件分析第十一节——Pointer Analysis - Context Sensitivity I" />
<meta property="og:description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 上下文不敏感带来的问题 对于上述这段代码，当我们不考虑上下文去处理第 5、6 行的 id 函数调用的时候，id 的参数和返回值会和两次调用的参数和返回值杂糅在一起，这样假如在进行常量传播的时候，变量 i 就会被分析为 NAC，这是不对的。所以要对函数调用添加上下文，这样去分析第 7 行的时候 get 指向的就只有对象 One 里面的 get 函数
Introduction btw 上下文不敏感的英文是 contex insensitivity，缩写是 C.I. 上下文敏感的英文是 contex sensitivity，缩写是 C.S.
目前 oldest 和 best-know 的上下文敏感策略是 call-site sensitivity（call-string） 使用 call site 链来表示每个方法的上下文（非重点） cloning-based 上下文敏感（最直观的方法去实现上下文敏感）、 每个上下文就会对变量和方法进行一次克隆 上下文敏感的堆 OO 程序是典型的堆敏感，因为程序会频繁的修改堆，所以也要对堆抽象添加上下文
老师在这里进行举例表示上下文敏感和堆的上下文敏感缺一不可
不考虑堆的上下文敏感，只考虑分析的上下文敏感
我们可以看到虽然分析的时候考虑了上下文敏感，但是当调用方法中存在 new 语句的时候 （堆操作），不考虑堆的 C." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/4.%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/%E5%8D%97%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82pointer-analysis-context-sensitivity-i/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T02:01:58+05:30" />
<meta property="article:modified_time" content="2023-06-11T02:01:58+05:30" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="南大软件分析第十一节——Pointer Analysis - Context Sensitivity I"/>
<meta name="twitter:description" content="视频：南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 笔记参考：【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com) (34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析 PPT：Pointer Analysis: Context Sensitivity (nju.edu.cn) 上下文不敏感带来的问题 对于上述这段代码，当我们不考虑上下文去处理第 5、6 行的 id 函数调用的时候，id 的参数和返回值会和两次调用的参数和返回值杂糅在一起，这样假如在进行常量传播的时候，变量 i 就会被分析为 NAC，这是不对的。所以要对函数调用添加上下文，这样去分析第 7 行的时候 get 指向的就只有对象 One 里面的 get 函数
Introduction btw 上下文不敏感的英文是 contex insensitivity，缩写是 C.I. 上下文敏感的英文是 contex sensitivity，缩写是 C.S.
目前 oldest 和 best-know 的上下文敏感策略是 call-site sensitivity（call-string） 使用 call site 链来表示每个方法的上下文（非重点） cloning-based 上下文敏感（最直观的方法去实现上下文敏感）、 每个上下文就会对变量和方法进行一次克隆 上下文敏感的堆 OO 程序是典型的堆敏感，因为程序会频繁的修改堆，所以也要对堆抽象添加上下文
老师在这里进行举例表示上下文敏感和堆的上下文敏感缺一不可
不考虑堆的上下文敏感，只考虑分析的上下文敏感
我们可以看到虽然分析的时候考虑了上下文敏感，但是当调用方法中存在 new 语句的时候 （堆操作），不考虑堆的 C."/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">南大软件分析第十一节——Pointer Analysis - Context Sensitivity I</h1>
			<div class="meta">Posted on Jun 11, 2023</div>
		</div>
		

		<section class="body">
			<p>视频：<a href="https://www.bilibili.com/video/BV1fb4y1i7HY/?spm_id_from=333.788&amp;vd_source=a3f6a4e5f57d8b5aa5eea112e1eeef1f">南京大学《软件分析》课程10（Pointer Analysis - Foundations II）哔哩哔哩_bilibili</a>
课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">Static Program Analysis | Tai-e (pascal-lab.net)</a>
笔记参考：<a href="https://www.jianshu.com/p/5ab79839f686">【课程笔记】南大软件分析课程8——指针分析-上下文敏感（课时11/12） - 简书 (jianshu.com)</a>
<a href="https://blog.csdn.net/panhewu9919/article/details/106007155?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-106007155-blog-105689689.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-106007155-blog-105689689.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3">(34条消息) 【课程笔记】南大软件分析课程—16课时完整版_bsauce的博客-CSDN博客_南京大学软件分析</a>
PPT：<a href="https://cs.nju.edu.cn/tiantan/software-analysis/PTA-CS.pdf">Pointer Analysis: Context Sensitivity (nju.edu.cn)</a>
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409150746.png" alt=""></p>
<h2 id="上下文不敏感带来的问题">上下文不敏感带来的问题</h2>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409151436.png" alt="image.png">
对于上述这段代码，当我们不考虑上下文去处理第 5、6 行的 id 函数调用的时候，id 的参数和返回值会和两次调用的参数和返回值杂糅在一起，这样假如在进行常量传播的时候，变量 i 就会被分析为 NAC，这是不对的。所以要对函数调用添加上下文，这样去分析第 7 行的时候 get 指向的就只有对象 One 里面的 get 函数</p>
<h2 id="introduction">Introduction</h2>
<p>btw
上下文不敏感的英文是 contex insensitivity，缩写是 C.I.
上下文敏感的英文是 contex sensitivity，缩写是 C.S.</p>
<ul>
<li>目前 oldest 和 best-know 的上下文敏感策略是 call-site sensitivity（call-string）
<ul>
<li>使用 call site 链来表示每个方法的上下文（非重点）</li>
</ul>
</li>
<li>cloning-based 上下文敏感（最直观的方法去实现上下文敏感）、
<ul>
<li>每个上下文就会对变量和方法进行一次克隆</li>
</ul>
</li>
<li>上下文敏感的堆
<ul>
<li>
<p>OO 程序是典型的堆敏感，因为程序会频繁的修改堆，所以也要对堆抽象添加上下文</p>
</li>
<li>
<p>老师在这里进行举例表示上下文敏感和堆的上下文敏感缺一不可</p>
</li>
<li>
<p>不考虑堆的上下文敏感，只考虑分析的上下文敏感</p>
<ul>
<li><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409154255.png" alt="image.png"></li>
<li>我们可以看到虽然分析的时候考虑了上下文敏感，但是当调用方法中存在 new 语句的时候 （堆操作），不考虑堆的 C.S.就会像左图一样</li>
</ul>
</li>
<li>
<p>考虑堆的上下文敏感，不考虑分析的上下文敏感</p>
<ul>
<li><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409153326.png" alt="image.png"></li>
<li>当分析的时候不考虑上下文敏感，只考虑对的上下文敏感，如左图所示，在变量 p 处就出现了错误，随后导致 o_8. f 指向 o 1 和 o 2，即使堆上下文敏感也没用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="context-sensitive-pointer-analysisrules">Context Sensitive Pointer Analysis：Rules</h2>
<p>就是在之前的规则上面增加了标记</p>
<ul>
<li>根据调用者的行数来区分不同上下文，只要区分了函数、变量、堆对象，就能够区分实例域、上下文敏感的指针（变量+对象域）。</li>
</ul>
<p>C：上下文（暂时用调用点的行数表示），O：对象，F：对象中的域。
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409155306.png" alt="image.png"></p>
<p><img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409155329.png" alt="image.png">
Call 规则有所改变
<img src="https://gitee.com/juhuahua/chart-bed/raw/master/20230409160023.png" alt="image.png"></p>
<ul>
<li>select (c, l, c&rsquo;: oi, m)根据调用时的信息来给调用目标函数选择上下文（c 是调用者的上下文，l 是调用者的行号，c&rsquo;: oi 是 x 对象的指向集合，m 是目标函数），ct 表示目标函数的上下文（后面会将如何 Select 如何选择上下文）。c 是可以累积的，一连串的调用，上下文将用一连串的行数来表示。</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
