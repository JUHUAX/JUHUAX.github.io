<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>overlapping heap（以0ctf babyheap为例） - Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="(68条消息) [pwn]堆：fastbin attack 详解_breezeO_o 的博客-CSDN 博客 (68条消息) [BUUCTF]PWN——babyheap_0ctf_2017_Angel~Yan 的博客-CSDN 博客 【学习分享】babyheap_0ctf_2017，一道入门堆的题 这个视频非常详细，非常好
（主要是对上面两个 writeup 的补充和思路的整理） 这道题主要分为两个步骤
泄露 libc 地址 修改 malloc_hook 为 onegadget 为什么我们需要泄露 libc 地址呢，因为我们需要知道 malloc_hook 的地址。而 malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过将 mall_hook 指向一个 onegadget 来 getshell。
泄露 libc 首先我们申请四个 chunk，编号 0、1、2、3。（实际大小应该还加上 presize 的 8 个字节）
alloc(0x18) #0 alloc(0x68) #1 alloc(0x68) #2 alloc(0x18) #3 然后，我们通过溢出 0 号 chunk 来修改 1 号 chunk 的大小（因为 1 号 chunk 的指针指不到自己的 size 的位置），将其修改为 chunk 1&#43;chunk2 的大小。 然后 free (1)，因为此时 1 号 chunk 的大小是 0xe0，所以会放到 unsortbin 链表。 我们为啥要让 1 和 2 chunk 作为一个 chunk 释放呢。因为 unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址 (unsorted bin 链表的头部），这个地址为 main_arena &#43; 0 x 58 ，而且 main_arena 又相对 libc 固定偏移 0 x3c4b20 ，所以得到这个 fd 的值，然后减去 0 x 58 再减去 main_arena 相对于 libc 的固定偏移，即得到 libc 的基地址。 所以我们要想方设法得到这个 fd 的值，但是我们对 chunk 释放后，指针也就失效了，读不到此时挂在 unsortbin 链表上 chunk 的内容。 所以我们让 chunk 1 和 2 堆叠释放，此时 unsortbin 链表上挂了一个大小为 0xe0 的 chunk，然后我们 alloc (0x68)，此时系统会将0xe0 的 chunk 分割，将0x68 分配，而剩下的0x68 大小的 chunk 就是我们之前 alloc 的 chunk 2，此时我们将 chunk 2 打印便可以得到 fd，也就得到 libc 的基址。" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="overlapping heap（以0ctf babyheap为例）" />
<meta property="og:description" content="(68条消息) [pwn]堆：fastbin attack 详解_breezeO_o 的博客-CSDN 博客 (68条消息) [BUUCTF]PWN——babyheap_0ctf_2017_Angel~Yan 的博客-CSDN 博客 【学习分享】babyheap_0ctf_2017，一道入门堆的题 这个视频非常详细，非常好
（主要是对上面两个 writeup 的补充和思路的整理） 这道题主要分为两个步骤
泄露 libc 地址 修改 malloc_hook 为 onegadget 为什么我们需要泄露 libc 地址呢，因为我们需要知道 malloc_hook 的地址。而 malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过将 mall_hook 指向一个 onegadget 来 getshell。
泄露 libc 首先我们申请四个 chunk，编号 0、1、2、3。（实际大小应该还加上 presize 的 8 个字节）
alloc(0x18) #0 alloc(0x68) #1 alloc(0x68) #2 alloc(0x18) #3 然后，我们通过溢出 0 号 chunk 来修改 1 号 chunk 的大小（因为 1 号 chunk 的指针指不到自己的 size 的位置），将其修改为 chunk 1&#43;chunk2 的大小。 然后 free (1)，因为此时 1 号 chunk 的大小是 0xe0，所以会放到 unsortbin 链表。 我们为啥要让 1 和 2 chunk 作为一个 chunk 释放呢。因为 unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址 (unsorted bin 链表的头部），这个地址为 main_arena &#43; 0 x 58 ，而且 main_arena 又相对 libc 固定偏移 0 x3c4b20 ，所以得到这个 fd 的值，然后减去 0 x 58 再减去 main_arena 相对于 libc 的固定偏移，即得到 libc 的基地址。 所以我们要想方设法得到这个 fd 的值，但是我们对 chunk 释放后，指针也就失效了，读不到此时挂在 unsortbin 链表上 chunk 的内容。 所以我们让 chunk 1 和 2 堆叠释放，此时 unsortbin 链表上挂了一个大小为 0xe0 的 chunk，然后我们 alloc (0x68)，此时系统会将0xe0 的 chunk 分割，将0x68 分配，而剩下的0x68 大小的 chunk 就是我们之前 alloc 的 chunk 2，此时我们将 chunk 2 打印便可以得到 fd，也就得到 libc 的基址。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/1.%E5%AD%A6%E4%B9%A0/2.%E5%88%B7%E9%A2%98/ctf/pwn/overlapping-heap%E4%BB%A50ctf-babyheap%E4%B8%BA%E4%BE%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="overlapping heap（以0ctf babyheap为例）"/>
<meta name="twitter:description" content="(68条消息) [pwn]堆：fastbin attack 详解_breezeO_o 的博客-CSDN 博客 (68条消息) [BUUCTF]PWN——babyheap_0ctf_2017_Angel~Yan 的博客-CSDN 博客 【学习分享】babyheap_0ctf_2017，一道入门堆的题 这个视频非常详细，非常好
（主要是对上面两个 writeup 的补充和思路的整理） 这道题主要分为两个步骤
泄露 libc 地址 修改 malloc_hook 为 onegadget 为什么我们需要泄露 libc 地址呢，因为我们需要知道 malloc_hook 的地址。而 malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过将 mall_hook 指向一个 onegadget 来 getshell。
泄露 libc 首先我们申请四个 chunk，编号 0、1、2、3。（实际大小应该还加上 presize 的 8 个字节）
alloc(0x18) #0 alloc(0x68) #1 alloc(0x68) #2 alloc(0x18) #3 然后，我们通过溢出 0 号 chunk 来修改 1 号 chunk 的大小（因为 1 号 chunk 的指针指不到自己的 size 的位置），将其修改为 chunk 1&#43;chunk2 的大小。 然后 free (1)，因为此时 1 号 chunk 的大小是 0xe0，所以会放到 unsortbin 链表。 我们为啥要让 1 和 2 chunk 作为一个 chunk 释放呢。因为 unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址 (unsorted bin 链表的头部），这个地址为 main_arena &#43; 0 x 58 ，而且 main_arena 又相对 libc 固定偏移 0 x3c4b20 ，所以得到这个 fd 的值，然后减去 0 x 58 再减去 main_arena 相对于 libc 的固定偏移，即得到 libc 的基地址。 所以我们要想方设法得到这个 fd 的值，但是我们对 chunk 释放后，指针也就失效了，读不到此时挂在 unsortbin 链表上 chunk 的内容。 所以我们让 chunk 1 和 2 堆叠释放，此时 unsortbin 链表上挂了一个大小为 0xe0 的 chunk，然后我们 alloc (0x68)，此时系统会将0xe0 的 chunk 分割，将0x68 分配，而剩下的0x68 大小的 chunk 就是我们之前 alloc 的 chunk 2，此时我们将 chunk 2 打印便可以得到 fd，也就得到 libc 的基址。"/>

	
        <link href="https://example.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://example.com/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://example.com/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css" media="(prefers-color-scheme: dark)"  />
	

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://example.com">Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/categories">Categories</a>
		
		<a href="/tags">Tags</a>
		
		<a href="/about">About</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">overlapping heap（以0ctf babyheap为例）</h1>
			<div class="meta">Posted on Jun 22, 2023</div>
		</div>
		

		<section class="body">
			<p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103788698">(68条消息) [pwn]堆：fastbin attack 详解_breezeO_o 的博客-CSDN 博客</a>
<a href="https://blog.csdn.net/mcmuyanga/article/details/108360375">(68条消息) [BUUCTF]PWN——babyheap_0ctf_2017_Angel~Yan 的博客-CSDN 博客</a>
<a href="https://www.bilibili.com/video/BV1x64y1r728/?share_source=copy_web&amp;vd_source=2f13b1acc8080cd58efdad54309f846e">【学习分享】babyheap_0ctf_2017，一道入门堆的题</a> 这个视频非常详细，非常好</p>
<p>（主要是对上面两个 writeup 的补充和思路的整理）
这道题主要分为两个步骤</p>
<ul>
<li>泄露 libc 地址</li>
<li>修改 malloc_hook 为 onegadget</li>
</ul>
<p>为什么我们需要泄露 libc 地址呢，因为我们需要知道 malloc_hook 的地址。而 malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过将 mall_hook 指向一个 onegadget 来 getshell。</p>
<h2 id="泄露-libc">泄露 libc</h2>
<p>首先我们申请四个 chunk，编号 0、1、2、3。（实际大小应该还加上 presize 的 8 个字节）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0x18</span>) <span style="color:#75715e">#0 </span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0x68</span>) <span style="color:#75715e">#1 </span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0x68</span>) <span style="color:#75715e">#2 </span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0x18</span>) <span style="color:#75715e">#3</span>
</span></span></code></pre></div><p>然后，我们通过溢出 0 号 chunk 来修改 1 号 chunk 的大小（因为 1 号 chunk 的指针指不到自己的 size 的位置），将其修改为 chunk 1+chunk2 的大小。
然后 free (1)，因为此时 1 号 chunk 的大小是 0xe0，所以会放到 unsortbin 链表。
我们为啥要让 1 和 2 chunk 作为一个 chunk 释放呢。因为 unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址 (unsorted bin 链表的头部），这个地址为 main_arena + 0 x 58 ，而且 main_arena 又相对 libc 固定偏移 0 x3c4b20 ，所以得到这个 fd 的值，然后减去 0 x 58 再减去 main_arena 相对于 libc 的固定偏移，即得到 libc 的基地址。
所以我们要想方设法得到这个 fd 的值，但是我们对 chunk 释放后，指针也就失效了，读不到此时挂在 unsortbin 链表上 chunk 的内容。
所以我们让 chunk 1 和 2 堆叠释放，此时 unsortbin 链表上挂了一个大小为 0xe0 的 chunk，然后我们 alloc (0x68)，此时系统会将0xe0 的 chunk 分割，将0x68 分配，而剩下的0x68 大小的 chunk 就是我们之前 alloc 的 chunk 2，此时我们将 chunk 2 打印便可以得到 fd，也就得到 libc 的基址。</p>
<h2 id="修改-malloc_hook-为-onegadget">修改 malloc_hook 为 onegadget</h2>
<p>大体思路是我们修改挂在 fastbin 链上的空闲 chunk 的 fb，让它指向 malloc_hook 所在的地址区域，让它以为自己后面还挂着一个空闲 chunk。我们将这个伪造的 fake chunk 申请到，我们就可以对其进行编辑了，也就是说可以对 malloc_hook 所在的地址区域进行编辑，那么就把 malloc_hook 的地方写入 onegadget。大功告成。
这里有个小细节，我们伪造的 fake chunk 的大小要符合 fastbin 链表的大小要求，所以在 malloc_hook 所在的地址区域要找一个值满足 fastbin 大小的地址才可以。</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/pwn%E7%9F%A5%E8%AF%86%E7%82%B9">PWN知识点</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2023  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
